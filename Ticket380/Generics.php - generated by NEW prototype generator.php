<?php
// module Generics.php generated by Generate.hs
// Prototype v3.0.1.2873, build time: 26-Jan-14 12:19:44 UTC (lib: Ampersand v3.0.1.1263, build time: 26-Jan-14 12:19:21 UTC)


$versionInfo = 'Prototype v3.0.1.2873, build time: 26-Jan-14 12:19:44 UTC (lib: Ampersand v3.0.1.1263, build time: 26-Jan-14 12:19:21 UTC)';

$dbName = 'CSA_Op';

$isDev = false;

$autoRefreshInterval = '0';

$allSpecializations =
  array
    ();

$relationTableInfo =
  array
    ( 'planCmpStat' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'Status', 'table' => 'Plan', 'srcCol' => 'Plan', 'tgtCol' => 'planCmpStat')
    , 'atStatusIsGreen' => array ('srcConcept' => 'ActivityType', 'tgtConcept' => 'ActivityType', 'table' => 'ActivityType', 'srcCol' => 'ActivityType', 'tgtCol' => 'atStatusIsGreen')
    , 'actCmpStat' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Status', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actCmpStat')
    , 'ouCmpStat' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'Status', 'table' => 'OrgUnit', 'srcCol' => 'OrgUnit', 'tgtCol' => 'ouCmpStat')
    , 'scCmpStat' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Status', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scCmpStat')
    , 'compCmpStat' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Status', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compCmpStat')
    , 'nwAllCompCommReqsSatisfied' => array ('srcConcept' => 'Network', 'tgtConcept' => 'Network', 'table' => 'Network', 'srcCol' => 'Network', 'tgtCol' => 'nwAllCompCommReqsSatisfied')
    , 'nwNoCompCommReqsSatisfied' => array ('srcConcept' => 'Network', 'tgtConcept' => 'Network', 'table' => 'Network', 'srcCol' => 'Network', 'tgtCol' => 'nwNoCompCommReqsSatisfied')
    , 'routerRoutesTo' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'routerRoutesTo', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'rrtDirect' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'rrtDirect', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'rrtStar' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'rrtStar', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'routerNeedsPathTo' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'routerNeedsPathTo', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'routerAllCommReqsSatisfied' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerAllCommReqsSatisfied')
    , 'routerNoCommReqsSatisfied' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerNoCommReqsSatisfied')
    , 'compReqCommWith' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'compReqCommWith', 'srcCol' => 'sComputer', 'tgtCol' => 'tComputer')
    , 'compHasCommWith' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'compHasCommWith', 'srcCol' => 'sComputer', 'tgtCol' => 'tComputer')
    , 'compRequiresComm' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compRequiresComm')
    , 'compAllReqCommSatisfied' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compAllReqCommSatisfied')
    , 'compNoReqCommSatisfied' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compNoReqCommSatisfied')
    , 'scAllReqCommSatisfied' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scAllReqCommSatisfied')
    , 'scNoReqCommSatisfied' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scNoReqCommSatisfied')
    , 'svcAllSvcCompReqsSatisfied' => array ('srcConcept' => 'Service', 'tgtConcept' => 'Service', 'table' => 'Service', 'srcCol' => 'Service', 'tgtCol' => 'svcAllSvcCompReqsSatisfied')
    , 'svcNoSvcCompReqsSatisfied' => array ('srcConcept' => 'Service', 'tgtConcept' => 'Service', 'table' => 'Service', 'srcCol' => 'Service', 'tgtCol' => 'svcNoSvcCompReqsSatisfied')
    , 'connectComputerToNetworkRouter' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'connectComputerToNetworkRouter')
    , 'routesToBeDiscarded' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'routesToBeDiscarded', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'computerToBeDisconnected' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Router', 'table' => 'computerToBeDisconnected', 'srcCol' => 'Computer', 'tgtCol' => 'Router')
    , 'setupComputerComputerCommunications' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'setupComputerComputerCommunications', 'srcCol' => 'sComputer', 'tgtCol' => 'tComputer')
    , 'startRunningServiceComponents' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'startRunningServiceComponents')
    , 'yesNo' => array ('srcConcept' => 'Yes/No answer', 'tgtConcept' => 'Yes/No answer', 'table' => 'yesNo', 'srcCol' => 'sYes/No answer', 'tgtCol' => 'tYes/No answer')
    , 'planID' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'PlanID', 'table' => 'Plan', 'srcCol' => 'Plan', 'tgtCol' => 'planID')
    , 'planStatus' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'Status', 'table' => 'Plan', 'srcCol' => 'Plan', 'tgtCol' => 'planStatus')
    , 'planMnlStat' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'Status', 'table' => 'Plan', 'srcCol' => 'Plan', 'tgtCol' => 'planMnlStat')
    , 'planAT' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'ActivityType', 'table' => 'planAT', 'srcCol' => 'Plan', 'tgtCol' => 'ActivityType')
    , 'atStatus' => array ('srcConcept' => 'ActivityType', 'tgtConcept' => 'Status', 'table' => 'ActivityType', 'srcCol' => 'ActivityType', 'tgtCol' => 'atStatus')
    , 'atReqsCpb' => array ('srcConcept' => 'ActivityType', 'tgtConcept' => 'Capability', 'table' => 'atReqsCpb', 'srcCol' => 'ActivityType', 'tgtCol' => 'Capability')
    , 'atReqsSvc' => array ('srcConcept' => 'ActivityType', 'tgtConcept' => 'Service', 'table' => 'atReqsSvc', 'srcCol' => 'ActivityType', 'tgtCol' => 'Service')
    , 'svcID' => array ('srcConcept' => 'Service', 'tgtConcept' => 'ServiceID', 'table' => 'Service', 'srcCol' => 'Service', 'tgtCol' => 'svcID')
    , 'svcStatus' => array ('srcConcept' => 'Service', 'tgtConcept' => 'Status', 'table' => 'Service', 'srcCol' => 'Service', 'tgtCol' => 'svcStatus')
    , 'actType' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'ActivityType', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actType')
    , 'actID' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'ActivityID', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actID')
    , 'actStatus' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Status', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actStatus')
    , 'actMnlStat' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Status', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actMnlStat')
    , 'actExecutingOU' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'OrgUnit', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actExecutingOU')
    , 'actPlan' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Plan', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actPlan')
    , 'actPlanStart' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actPlanStart')
    , 'actPlanEnd' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actPlanEnd')
    , 'actStartTime' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actStartTime')
    , 'actEndTime' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actEndTime')
    , 'actUseSC' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'SvcComponent', 'table' => 'actUseSC', 'srcCol' => 'Activity', 'tgtCol' => 'SvcComponent')
    , 'ouStatus' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'Status', 'table' => 'OrgUnit', 'srcCol' => 'OrgUnit', 'tgtCol' => 'ouStatus')
    , 'ouMnlStat' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'Status', 'table' => 'OrgUnit', 'srcCol' => 'OrgUnit', 'tgtCol' => 'ouMnlStat')
    , 'ouQualifiedFor' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'Capability', 'table' => 'ouQualifiedFor', 'srcCol' => 'OrgUnit', 'tgtCol' => 'Capability')
    , 'ouMayExecuteAT' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'ActivityType', 'table' => 'ouMayExecuteAT', 'srcCol' => 'OrgUnit', 'tgtCol' => 'ActivityType')
    , 'scStatus' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Status', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scStatus')
    , 'scMnlStat' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Status', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scMnlStat')
    , 'scImplements' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Service', 'table' => 'scImplements', 'srcCol' => 'SvcComponent', 'tgtCol' => 'Service')
    , 'scDeployedOn' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Computer', 'table' => 'scDeployedOn', 'srcCol' => 'SvcComponent', 'tgtCol' => 'Computer')
    , 'compID' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'ComputerID', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compID')
    , 'compName' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'ComputerName', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compName')
    , 'compStatus' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Status', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compStatus')
    , 'compMnlStat' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Status', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compMnlStat')
    , 'compOwner' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'OrgUnit', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compOwner')
    , 'compRouter' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Router', 'table' => 'compRouter', 'srcCol' => 'Computer', 'tgtCol' => 'Router')
    , 'nwID' => array ('srcConcept' => 'Network', 'tgtConcept' => 'NetworkID', 'table' => 'Network', 'srcCol' => 'Network', 'tgtCol' => 'nwID')
    , 'nwStatus' => array ('srcConcept' => 'Network', 'tgtConcept' => 'Status', 'table' => 'Network', 'srcCol' => 'Network', 'tgtCol' => 'nwStatus')
    , 'routerID' => array ('srcConcept' => 'Router', 'tgtConcept' => 'RouterID', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerID')
    , 'routerName' => array ('srcConcept' => 'Router', 'tgtConcept' => 'RouterName', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerName')
    , 'routerStatus' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Status', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerStatus')
    , 'routerNW' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Network', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerNW')
    , 'scID' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponentID', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scID')
    , 'scName' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponentName', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scName')
    , 'scReqCommWith' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'scReqCommWith', 'srcCol' => 'sSvcComponent', 'tgtCol' => 'tSvcComponent')
    , 'scHasCommWith' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'scHasCommWith', 'srcCol' => 'sSvcComponent', 'tgtCol' => 'tSvcComponent')
    );

$conceptTableInfo =
  array
    ( 'Plan' => array 
          ( array ( 'table' => 'Plan'
                  , 'cols' => array ('Plan')
                  )
          )
    , 'Status' => array 
          ( array ( 'table' => 'Status'
                  , 'cols' => array ('Status')
                  )
          )
    , 'ActivityType' => array 
          ( array ( 'table' => 'ActivityType'
                  , 'cols' => array ('ActivityType')
                  )
          )
    , 'Activity' => array 
          ( array ( 'table' => 'Activity'
                  , 'cols' => array ('Activity')
                  )
          )
    , 'OrgUnit' => array 
          ( array ( 'table' => 'OrgUnit'
                  , 'cols' => array ('OrgUnit')
                  )
          )
    , 'SvcComponent' => array 
          ( array ( 'table' => 'SvcComponent'
                  , 'cols' => array ('SvcComponent')
                  )
          )
    , 'Computer' => array 
          ( array ( 'table' => 'Computer'
                  , 'cols' => array ('Computer')
                  )
          )
    , 'Network' => array 
          ( array ( 'table' => 'Network'
                  , 'cols' => array ('Network')
                  )
          )
    , 'Router' => array 
          ( array ( 'table' => 'Router'
                  , 'cols' => array ('Router')
                  )
          )
    , 'Service' => array 
          ( array ( 'table' => 'Service'
                  , 'cols' => array ('Service')
                  )
          )
    , 'Yes/No answer' => array 
          ( array ( 'table' => 'Yes/No answer'
                  , 'cols' => array ('Yes/No answer')
                  )
          )
    , 'PlanID' => array 
          ( array ( 'table' => 'PlanID'
                  , 'cols' => array ('PlanID')
                  )
          )
    , 'Capability' => array 
          ( array ( 'table' => 'Capability'
                  , 'cols' => array ('Capability')
                  )
          )
    , 'ServiceID' => array 
          ( array ( 'table' => 'ServiceID'
                  , 'cols' => array ('ServiceID')
                  )
          )
    , 'ActivityID' => array 
          ( array ( 'table' => 'ActivityID'
                  , 'cols' => array ('ActivityID')
                  )
          )
    , 'Timestamp' => array 
          ( array ( 'table' => 'Timestamp'
                  , 'cols' => array ('Timestamp')
                  )
          )
    , 'ComputerID' => array 
          ( array ( 'table' => 'ComputerID'
                  , 'cols' => array ('ComputerID')
                  )
          )
    , 'ComputerName' => array 
          ( array ( 'table' => 'ComputerName'
                  , 'cols' => array ('ComputerName')
                  )
          )
    , 'NetworkID' => array 
          ( array ( 'table' => 'NetworkID'
                  , 'cols' => array ('NetworkID')
                  )
          )
    , 'RouterID' => array 
          ( array ( 'table' => 'RouterID'
                  , 'cols' => array ('RouterID')
                  )
          )
    , 'RouterName' => array 
          ( array ( 'table' => 'RouterName'
                  , 'cols' => array ('RouterName')
                  )
          )
    , 'SvcComponentID' => array 
          ( array ( 'table' => 'SvcComponentID'
                  , 'cols' => array ('SvcComponentID')
                  )
          )
    , 'SvcComponentName' => array 
          ( array ( 'table' => 'SvcComponentName'
                  , 'cols' => array ('SvcComponentName')
                  )
          )
    );

$tableColumnInfo =
  array
    ( 'Activity' =>
        array
          ( 'Activity' => array ( 'concept' => 'Activity', 'unique' => true, 'null' => false)
          , 'actCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'actType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => true)
          , 'actID' => array ( 'concept' => 'ActivityID', 'unique' => false, 'null' => true)
          , 'actStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'actMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'actExecutingOU' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => true)
          , 'actPlan' => array ( 'concept' => 'Plan', 'unique' => false, 'null' => true)
          , 'actPlanStart' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'actPlanEnd' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'actStartTime' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'actEndTime' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          )
    , 'Computer' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => false)
          , 'compCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'compRequiresComm' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compAllReqCommSatisfied' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compNoReqCommSatisfied' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'connectComputerToNetworkRouter' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compID' => array ( 'concept' => 'ComputerID', 'unique' => false, 'null' => true)
          , 'compName' => array ( 'concept' => 'ComputerName', 'unique' => false, 'null' => true)
          , 'compStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'compMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'compOwner' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => true)
          )
    , 'SvcComponent' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => true, 'null' => false)
          , 'scCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'scAllReqCommSatisfied' => array ( 'concept' => 'SvcComponent', 'unique' => true, 'null' => true)
          , 'scNoReqCommSatisfied' => array ( 'concept' => 'SvcComponent', 'unique' => true, 'null' => true)
          , 'startRunningServiceComponents' => array ( 'concept' => 'SvcComponent', 'unique' => true, 'null' => true)
          , 'scStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'scMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'scID' => array ( 'concept' => 'SvcComponentID', 'unique' => false, 'null' => true)
          , 'scName' => array ( 'concept' => 'SvcComponentName', 'unique' => false, 'null' => true)
          )
    , 'Router' =>
        array
          ( 'Router' => array ( 'concept' => 'Router', 'unique' => true, 'null' => false)
          , 'routerAllCommReqsSatisfied' => array ( 'concept' => 'Router', 'unique' => true, 'null' => true)
          , 'routerNoCommReqsSatisfied' => array ( 'concept' => 'Router', 'unique' => true, 'null' => true)
          , 'routerID' => array ( 'concept' => 'RouterID', 'unique' => false, 'null' => true)
          , 'routerName' => array ( 'concept' => 'RouterName', 'unique' => false, 'null' => true)
          , 'routerStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'routerNW' => array ( 'concept' => 'Network', 'unique' => false, 'null' => true)
          )
    , 'Service' =>
        array
          ( 'Service' => array ( 'concept' => 'Service', 'unique' => true, 'null' => false)
          , 'svcAllSvcCompReqsSatisfied' => array ( 'concept' => 'Service', 'unique' => true, 'null' => true)
          , 'svcNoSvcCompReqsSatisfied' => array ( 'concept' => 'Service', 'unique' => true, 'null' => true)
          , 'svcID' => array ( 'concept' => 'ServiceID', 'unique' => false, 'null' => true)
          , 'svcStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'Plan' =>
        array
          ( 'Plan' => array ( 'concept' => 'Plan', 'unique' => true, 'null' => false)
          , 'planCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'planID' => array ( 'concept' => 'PlanID', 'unique' => false, 'null' => true)
          , 'planStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'planMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'Network' =>
        array
          ( 'Network' => array ( 'concept' => 'Network', 'unique' => true, 'null' => false)
          , 'nwAllCompCommReqsSatisfied' => array ( 'concept' => 'Network', 'unique' => true, 'null' => true)
          , 'nwNoCompCommReqsSatisfied' => array ( 'concept' => 'Network', 'unique' => true, 'null' => true)
          , 'nwID' => array ( 'concept' => 'NetworkID', 'unique' => false, 'null' => true)
          , 'nwStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'OrgUnit' =>
        array
          ( 'OrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => true, 'null' => false)
          , 'ouCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'ouStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'ouMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'ActivityType' =>
        array
          ( 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => true, 'null' => false)
          , 'atStatusIsGreen' => array ( 'concept' => 'ActivityType', 'unique' => true, 'null' => true)
          , 'atStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'Yes/No answer' =>
        array
          ( 'Yes/No answer' => array ( 'concept' => 'Yes/No answer', 'unique' => true, 'null' => false)
          )
    , 'Timestamp' =>
        array
          ( 'Timestamp' => array ( 'concept' => 'Timestamp', 'unique' => true, 'null' => false)
          )
    , 'SvcComponentName' =>
        array
          ( 'SvcComponentName' => array ( 'concept' => 'SvcComponentName', 'unique' => true, 'null' => false)
          )
    , 'SvcComponentID' =>
        array
          ( 'SvcComponentID' => array ( 'concept' => 'SvcComponentID', 'unique' => true, 'null' => false)
          )
    , 'Status' =>
        array
          ( 'Status' => array ( 'concept' => 'Status', 'unique' => true, 'null' => false)
          )
    , 'ServiceID' =>
        array
          ( 'ServiceID' => array ( 'concept' => 'ServiceID', 'unique' => true, 'null' => false)
          )
    , 'RouterName' =>
        array
          ( 'RouterName' => array ( 'concept' => 'RouterName', 'unique' => true, 'null' => false)
          )
    , 'RouterID' =>
        array
          ( 'RouterID' => array ( 'concept' => 'RouterID', 'unique' => true, 'null' => false)
          )
    , 'PlanID' =>
        array
          ( 'PlanID' => array ( 'concept' => 'PlanID', 'unique' => true, 'null' => false)
          )
    , 'NetworkID' =>
        array
          ( 'NetworkID' => array ( 'concept' => 'NetworkID', 'unique' => true, 'null' => false)
          )
    , 'ComputerName' =>
        array
          ( 'ComputerName' => array ( 'concept' => 'ComputerName', 'unique' => true, 'null' => false)
          )
    , 'ComputerID' =>
        array
          ( 'ComputerID' => array ( 'concept' => 'ComputerID', 'unique' => true, 'null' => false)
          )
    , 'Capability' =>
        array
          ( 'Capability' => array ( 'concept' => 'Capability', 'unique' => true, 'null' => false)
          )
    , 'ActivityID' =>
        array
          ( 'ActivityID' => array ( 'concept' => 'ActivityID', 'unique' => true, 'null' => false)
          )
    , 'routerRoutesTo' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'rrtDirect' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'rrtStar' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'routerNeedsPathTo' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'compReqCommWith' =>
        array
          ( 'sComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'tComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'compHasCommWith' =>
        array
          ( 'sComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'tComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'routesToBeDiscarded' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'computerToBeDisconnected' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'Router' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'setupComputerComputerCommunications' =>
        array
          ( 'sComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'tComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'yesNo' =>
        array
          ( 'sYes/No answer' => array ( 'concept' => 'Yes/No answer', 'unique' => false, 'null' => false)
          , 'tYes/No answer' => array ( 'concept' => 'Yes/No answer', 'unique' => false, 'null' => false)
          )
    , 'planAT' =>
        array
          ( 'Plan' => array ( 'concept' => 'Plan', 'unique' => false, 'null' => false)
          , 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => false)
          )
    , 'atReqsCpb' =>
        array
          ( 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => false)
          , 'Capability' => array ( 'concept' => 'Capability', 'unique' => false, 'null' => false)
          )
    , 'atReqsSvc' =>
        array
          ( 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => false)
          , 'Service' => array ( 'concept' => 'Service', 'unique' => false, 'null' => false)
          )
    , 'actUseSC' =>
        array
          ( 'Activity' => array ( 'concept' => 'Activity', 'unique' => false, 'null' => false)
          , 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          )
    , 'ouQualifiedFor' =>
        array
          ( 'OrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => false)
          , 'Capability' => array ( 'concept' => 'Capability', 'unique' => false, 'null' => false)
          )
    , 'ouMayExecuteAT' =>
        array
          ( 'OrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => false)
          , 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => false)
          )
    , 'scImplements' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'Service' => array ( 'concept' => 'Service', 'unique' => false, 'null' => false)
          )
    , 'scDeployedOn' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'compRouter' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'Router' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'scReqCommWith' =>
        array
          ( 'sSvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'tSvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          )
    , 'scHasCommWith' =>
        array
          ( 'sSvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'tSvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          )
    );

$allRulesSql =
  array
    ( 'ActivityType OrgUnits' =>
        array ( 'name'          => 'ActivityType OrgUnits'
              , 'ruleAdl'       => 'I[ActivityType] |- (-atReqsCpb!ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~'
              , 'origin'        => 'line 98:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(I[ActivityType] |- (-atReqsCpb!ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~)
              // <=> { remove |- }
              //     -(-I[ActivityType] \\/ (-atReqsCpb!ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~)
              // <=> { De Morgan }
              //     I[ActivityType] /\\ -((-atReqsCpb!ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~)
              // <=> { De Morgan }
              //     I[ActivityType] /\\ -(-(atReqsCpb;-ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI ActivityType,ECpl (ECps (ECpl (ECps (EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability -},ECpl (EFlp (EDcD RELATION ouQualifiedFor [OrgUnit*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit is qualified for the Capability -})))),EFlp (EBrk (ERad (ECpl (EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability -}),EFlp (EDcD RELATION ouQualifiedFor [OrgUnit*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit is qualified for the Capability +})))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[ActivityType] /\\ -(-(atReqsCpb;-ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~) ([ActivityType*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcActivityType` AS src, isect0.`TrgActivityType` AS tgt
                          FROM ( /* I[ActivityType] */
                            SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `ActivityType` AS `TrgActivityType`
                            FROM `ActivityType`
                            WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                -(atReqsCpb;-ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                             FROM 
                                                  ( /* case: ECpl e
                                                       ECpl ( \"atReqsCpb;-ouQualifiedFor~\" ) */
                                                    SELECT DISTINCT cfst.`ActivityType` AS `SrcActivityType`, csnd.`OrgUnit` AS `TrgOrgUnit`
                                                    FROM `ActivityType` AS cfst,
                                                         `OrgUnit` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                atReqsCpb;-ouQualifiedFor~ */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgOrgUnit`
                                                             FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Capability` AS `TrgCapability`
                                                               FROM `atReqsCpb`
                                                               WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL ) AS ECps0,
                                                                  
                                                                  ( /* case: ECpl e
                                                                       ECpl ( \"ouQualifiedFor~\" ) */
                                                                    SELECT DISTINCT cfst.`Capability` AS `SrcCapability`, csnd.`OrgUnit` AS `TrgOrgUnit`
                                                                    FROM `Capability` AS cfst,
                                                                         `OrgUnit` AS csnd
                                                                    WHERE NOT EXISTS
                                                                     (SELECT * FROM 
                                                                           ( /* case: EFlp x. */
                                                                             SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `Capability` AS `SrcCapability`
                                                                             FROM `ouQualifiedFor`
                                                                             WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL
                                                                           ) AS cp
                                                                      WHERE cfst.`Capability`=cp.`SrcCapability` AND csnd.`OrgUnit`=cp.`TrgOrgUnit`)
                                                                  ) AS ECps1
                                                             WHERE ECps0.`TrgCapability`=ECps1.`SrcCapability`
                                                           ) AS cp
                                                      WHERE cfst.`ActivityType`=cp.`SrcActivityType` AND csnd.`OrgUnit`=cp.`TrgOrgUnit`)
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    /* case: ERad (l,r)
                                                       -atReqsCpb!ouQualifiedFor~ ([ActivityType*OrgUnit]) */
                                                    /* case: ECpl e
                                                       ECpl ( \"atReqsCpb;-ouQualifiedFor~\" ) */
                                                    SELECT DISTINCT cfst.`ActivityType` AS `TrgActivityType`, csnd.`OrgUnit` AS `SrcOrgUnit`
                                                    FROM `ActivityType` AS cfst,
                                                         `OrgUnit` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                atReqsCpb;-ouQualifiedFor~ */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgOrgUnit`
                                                             FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Capability` AS `TrgCapability`
                                                               FROM `atReqsCpb`
                                                               WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL ) AS ECps0,
                                                                  
                                                                  ( /* case: ECpl e
                                                                       ECpl ( \"ouQualifiedFor~\" ) */
                                                                    SELECT DISTINCT cfst.`Capability` AS `SrcCapability`, csnd.`OrgUnit` AS `TrgOrgUnit`
                                                                    FROM `Capability` AS cfst,
                                                                         `OrgUnit` AS csnd
                                                                    WHERE NOT EXISTS
                                                                     (SELECT * FROM 
                                                                           ( /* case: EFlp x. */
                                                                             SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `Capability` AS `SrcCapability`
                                                                             FROM `ouQualifiedFor`
                                                                             WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL
                                                                           ) AS cp
                                                                      WHERE cfst.`Capability`=cp.`SrcCapability` AND csnd.`OrgUnit`=cp.`TrgOrgUnit`)
                                                                  ) AS ECps1
                                                             WHERE ECps0.`TrgCapability`=ECps1.`SrcCapability`
                                                           ) AS cp
                                                      WHERE cfst.`ActivityType`=cp.`SrcActivityType` AND csnd.`OrgUnit`=cp.`TrgOrgUnit`)
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                                           ) AS cp
                                      WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'None of the OrgUnits is qualified for ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' activities')
                    )
              )
    , 'Service implementation' =>
        array ( 'name'          => 'Service implementation'
              , 'ruleAdl'       => 'I[Service] /\\ atReqsSvc~;atReqsSvc |- scImplements~;scImplements'
              , 'origin'        => 'line 103:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(I[Service] /\\ atReqsSvc~;atReqsSvc |- scImplements~;scImplements)
              // <=> { remove |- }
              //     -(-(I[Service] /\\ atReqsSvc~;atReqsSvc) \\/ scImplements~;scImplements)
              // <=> { De Morgan }
              //     I[Service] /\\ (atReqsSvc~;atReqsSvc /\\ -(scImplements~;scImplements))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Service,EIsc (ECps (EFlp (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -}),EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -}),ECpl (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Service] /\\ (atReqsSvc~;atReqsSvc /\\ -(scImplements~;scImplements)) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    atReqsSvc~;atReqsSvc */
                                 
                                 SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ActivityType` AS `TrgActivityType`, `Service` AS `SrcService`
                                        FROM `atReqsSvc`
                                        WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                   FROM `atReqsSvc`
                                   WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                               ) AS isect0, ( /* I[Service] */
                            SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcService` = isect0.`TrgService` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scImplements~;scImplements */
                                             
                                             SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                    FROM `scImplements`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                  ) AS ECps0,
                                                  ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                               FROM `scImplements`
                                               WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Service ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' lacks an SvcComponent that implements it')
                    )
              )
    , 'Capability relevance' =>
        array ( 'name'          => 'Capability relevance'
              , 'ruleAdl'       => 'actExecutingOU~;(actType;atReqsCpb) |- ouQualifiedFor'
              , 'origin'        => 'line 108:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'Capability'
              // Normalization steps:
              //     -(actExecutingOU~;(actType;atReqsCpb) |- ouQualifiedFor)
              // <=> { remove |- }
              //     -(-(actExecutingOU~;(actType;atReqsCpb)) \\/ ouQualifiedFor)
              // <=> { De Morgan }
              //     actExecutingOU~;(actType;atReqsCpb) /\\ -ouQualifiedFor
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -}),ECps (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -},EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability -})),ECpl (EDcD RELATION ouQualifiedFor [OrgUnit*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit is qualified for the Capability +}))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actExecutingOU~;(actType;atReqsCpb) /\\ -ouQualifiedFor ([OrgUnit*Capability]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS src, isect0.`TrgCapability` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU~;(actType;atReqsCpb) */
                                 
                                 SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps2.`TrgCapability`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps1,
                                      ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Capability` AS `TrgCapability`
                                   FROM `atReqsCpb`
                                   WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL ) AS ECps2
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                                   AND ECps1.`TrgActivityType`=ECps2.`SrcActivityType`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `Capability` AS `TrgCapability`
                                        FROM `ouQualifiedFor`
                                        WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TrgCapability`=cp.`TrgCapability`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgCapability` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'OrgUnit ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                 SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                 FROM `OrgUnit`
                                 WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be qualified for capability ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Capability'
                            , 'expSQL' =>
                                '/* I[Capability] */
                                 SELECT DISTINCT `Capability` AS src, `Capability` AS tgt
                                 FROM `Capability`
                                 WHERE `Capability` IS NOT NULL AND `Capability` IS NOT NULL'
                            )
                    )
              )
    , 'insouMayExecuteAT' =>
        array ( 'name'          => 'insouMayExecuteAT'
              , 'ruleAdl'       => '-(atReqsCpb;-ouQualifiedFor~)~ |- ouMayExecuteAT'
              , 'origin'        => 'line 115:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(-(-ouQualifiedFor;atReqsCpb~) |- ouMayExecuteAT)
              // <=> { remove |- }
              //     -(-ouQualifiedFor;atReqsCpb~ \\/ ouMayExecuteAT)
              // <=> { De Morgan }
              //     -(-ouQualifiedFor;atReqsCpb~) /\\ -ouMayExecuteAT
              // 
              // Normalized complement (== violationsSQL): EIsc (ECpl (ECps (ECpl (EDcD RELATION ouQualifiedFor [OrgUnit*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit is qualified for the Capability -}),EFlp (EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability -}))),ECpl (EDcD RELATION ouMayExecuteAT [OrgUnit*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit has all necessary capabilities for executing activities of the ActivityType +}))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             -(-ouQualifiedFor;atReqsCpb~) /\\ -ouMayExecuteAT ([OrgUnit*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS src, isect0.`TrgActivityType` AS tgt
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \"-ouQualifiedFor;atReqsCpb~\" ) */
                                 SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`ActivityType` AS `TrgActivityType`
                                 FROM `OrgUnit` AS cfst,
                                      `ActivityType` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             -ouQualifiedFor;atReqsCpb~ */
                                          
                                          SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgActivityType`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \"ouQualifiedFor\" ) */
                                                 SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`Capability` AS `TrgCapability`
                                                 FROM `OrgUnit` AS cfst,
                                                      `Capability` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `Capability` AS `TrgCapability`
                                                     FROM `ouQualifiedFor`
                                                     WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL ) AS cp
                                                   WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`Capability`=cp.`TrgCapability`)
                                               ) AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 SELECT DISTINCT `ActivityType` AS `TrgActivityType`, `Capability` AS `SrcCapability`
                                                 FROM `atReqsCpb`
                                                 WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL
                                               ) AS ECps1
                                          WHERE ECps0.`TrgCapability`=ECps1.`SrcCapability`
                                        ) AS cp
                                   WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`ActivityType`=cp.`TrgActivityType`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ActivityType` AS `TrgActivityType`
                                        FROM `ouMayExecuteAT`
                                        WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouMayExecuteAT;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                 SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                 FROM `OrgUnit`
                                 WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    )
              )
    , 'delouMayExecuteAT' =>
        array ( 'name'          => 'delouMayExecuteAT'
              , 'ruleAdl'       => 'ouMayExecuteAT |- -(atReqsCpb;-ouQualifiedFor~)~'
              , 'origin'        => 'line 118:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(ouMayExecuteAT |- -(-ouQualifiedFor;atReqsCpb~))
              // <=> { remove |- }
              //     -(-ouMayExecuteAT \\/ -(-ouQualifiedFor;atReqsCpb~))
              // <=> { De Morgan }
              //     ouMayExecuteAT /\\ -ouQualifiedFor;atReqsCpb~
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION ouMayExecuteAT [OrgUnit*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit has all necessary capabilities for executing activities of the ActivityType -},ECps (ECpl (EDcD RELATION ouQualifiedFor [OrgUnit*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit is qualified for the Capability -}),EFlp (EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability +})))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             ouMayExecuteAT /\\ -ouQualifiedFor;atReqsCpb~ ([OrgUnit*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS src, isect0.`TrgActivityType` AS tgt
                          FROM ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ActivityType` AS `TrgActivityType`
                            FROM `ouMayExecuteAT`
                            WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    -ouQualifiedFor;atReqsCpb~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgActivityType`
                                 FROM 
                                      ( /* case: ECpl e
                                           ECpl ( \"ouQualifiedFor\" ) */
                                        SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`Capability` AS `TrgCapability`
                                        FROM `OrgUnit` AS cfst,
                                             `Capability` AS csnd
                                        WHERE NOT EXISTS
                                         (SELECT * FROM ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `Capability` AS `TrgCapability`
                                            FROM `ouQualifiedFor`
                                            WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL ) AS cp
                                          WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`Capability`=cp.`TrgCapability`)
                                      ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ActivityType` AS `TrgActivityType`, `Capability` AS `SrcCapability`
                                        FROM `atReqsCpb`
                                        WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgCapability`=ECps1.`SrcCapability`
                               ) AS isect1
                          WHERE (isect0.`SrcOrgUnit` = isect1.`SrcOrgUnit` AND isect0.`TrgActivityType` = isect1.`TrgActivityType`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;ouMayExecuteAT;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                 SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                 FROM `OrgUnit`
                                 WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    )
              )
    , 'SvcComponent assignment' =>
        array ( 'name'          => 'SvcComponent assignment'
              , 'ruleAdl'       => 'actType;atReqsSvc |- actUseSC;scImplements'
              , 'origin'        => 'line 122:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(actType;atReqsSvc |- actUseSC;scImplements)
              // <=> { remove |- }
              //     -(-(actType;atReqsSvc) \\/ actUseSC;scImplements)
              // <=> { De Morgan }
              //     actType;atReqsSvc /\\ -(actUseSC;scImplements)
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -},EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -}),ECpl (ECps (EDcD RELATION actUseSC [Activity*SvcComponent] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity requires the availability of the SvcComponent -},EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +})))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actType;atReqsSvc /\\ -(actUseSC;scImplements) ([Activity*Service]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgService` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actType;atReqsSvc */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgService`
                                 FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                   FROM `atReqsSvc`
                                   WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actUseSC;scImplements */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgService`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `SvcComponent` AS `TrgSvcComponent`
                                               FROM `actUseSC`
                                               WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS ECps0,
                                                  ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                               FROM `scImplements`
                                               WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Activity ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                 SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be assigned a SvcComponent that implements Service ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'Activity Integrity' =>
        array ( 'name'          => 'Activity Integrity'
              , 'ruleAdl'       => 'actExecutingOU~;actUseSC |- compOwner~;scDeployedOn~'
              , 'origin'        => 'line 127:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(actExecutingOU~;actUseSC |- compOwner~;scDeployedOn~)
              // <=> { remove |- }
              //     -(-(actExecutingOU~;actUseSC) \\/ compOwner~;scDeployedOn~)
              // <=> { De Morgan }
              //     actExecutingOU~;actUseSC /\\ -(compOwner~;scDeployedOn~)
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -}),EDcD RELATION actUseSC [Activity*SvcComponent] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity requires the availability of the SvcComponent -}),ECpl (ECps (EFlp (EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" ""),EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actExecutingOU~;actUseSC /\\ -(compOwner~;scDeployedOn~) ([OrgUnit*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU~;actUseSC */
                                 
                                 SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgSvcComponent`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `SvcComponent` AS `TrgSvcComponent`
                                   FROM `actUseSC`
                                   WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compOwner~;scDeployedOn~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgSvcComponent`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `compOwner` AS `SrcOrgUnit`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                           ) AS cp
                                      WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'OrgUnit ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                 SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                 FROM `OrgUnit`
                                 WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' does not have ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' deployed on its computers')
                    )
              )
    , 'planCmpStatIsRed' =>
        array ( 'name'          => 'planCmpStatIsRed'
              , 'ruleAdl'       => 'I[Plan] /\\ planAT;((I[ActivityType] /\\ -atStatusIsGreen);planAT~) |- planCmpStat;(\'Red\'[Status];planCmpStat~)'
              , 'origin'        => 'line 14:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Plan'
              , 'tgtConcept'    => 'Plan'
              // Normalization steps:
              //     -(I[Plan] /\\ planAT;((I[ActivityType] /\\ -atStatusIsGreen);planAT~) |- planCmpStat;(\'Red\'[Status];planCmpStat~))
              // <=> { remove |- }
              //     -(-(I[Plan] /\\ planAT;((I[ActivityType] /\\ -atStatusIsGreen);planAT~)) \\/ planCmpStat;(\'Red\'[Status];planCmpStat~))
              // <=> { De Morgan }
              //     I[Plan] /\\ (planAT;((I[ActivityType] /\\ -atStatusIsGreen);planAT~) /\\ -(planCmpStat;(\'Red\'[Status];planCmpStat~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Plan,EIsc (ECps (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -},ECps (EIsc (EDcI ActivityType,ECpl (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" "")),EFlp (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType +}))),ECpl (ECps (EDcD RELATION planCmpStat [Plan*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Red" Status,EFlp (EDcD RELATION planCmpStat [Plan*Status] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Plan] /\\ (planAT;((I[ActivityType] /\\ -atStatusIsGreen);planAT~) /\\ -(planCmpStat;(\'Red\'[Status];planCmpStat~))) ([Plan*Plan]) */
                          SELECT DISTINCT isect0.`SrcPlan` AS src, isect0.`TrgPlan` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    planAT;((I[ActivityType] /\\ -atStatusIsGreen);planAT~) */
                                 
                                 SELECT DISTINCT ECps0.`SrcPlan`, ECps2.`TrgPlan`
                                 FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `ActivityType` AS `TrgActivityType`
                                   FROM `planAT`
                                   WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: (EIsc lst\'@(_:_:_))
                                           I[ActivityType] /\\ -atStatusIsGreen ([ActivityType*ActivityType]) */
                                        SELECT DISTINCT isect0.`SrcActivityType`, isect0.`TrgActivityType`
                                        FROM ( /* I[ActivityType] */
                                          SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `ActivityType` AS `TrgActivityType`
                                          FROM `ActivityType`
                                          WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                                      FROM `ActivityType`
                                                      WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS cp
                                                    WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL
                                      ) AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan` AS `TrgPlan`, `ActivityType` AS `SrcActivityType`
                                        FROM `planAT`
                                        WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                      ) AS ECps2
                                 WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                   AND ECps1.`TrgActivityType`=ECps2.`SrcActivityType`
                               ) AS isect0, ( /* I[Plan] */
                            SELECT DISTINCT `Plan` AS `SrcPlan`, `Plan` AS `TrgPlan`
                            FROM `Plan`
                            WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcPlan` = isect0.`TrgPlan` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                planCmpStat;(\'Red\'[Status];planCmpStat~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcPlan`, ECps2.`TrgPlan`
                                             FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planCmpStat` AS `TrgStatus`
                                               FROM `Plan`
                                               WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Red" AS `SrcStatus`, "Red" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan` AS `TrgPlan`, `planCmpStat` AS `SrcStatus`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgPlan`=cp.`TrgPlan`) AND isect0.`SrcPlan` IS NOT NULL AND isect0.`TrgPlan` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planCmpStat;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                '/* I[Plan] */
                                 SELECT DISTINCT `Plan` AS src, `Plan` AS tgt
                                 FROM `Plan`
                                 WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'planCmpStatIsYellow' =>
        array ( 'name'          => 'planCmpStatIsYellow'
              , 'ruleAdl'       => 'I[Plan] /\\ (-planAT!(atStatusIsGreen;planAT~) /\\ planAT;((I[ActivityType] /\\ -(actType~;actType));planAT~)) |- planCmpStat;(\'Yellow\'[Status];planCmpStat~)'
              , 'origin'        => 'line 18:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Plan'
              , 'tgtConcept'    => 'Plan'
              // Normalization steps:
              //     -(I[Plan] /\\ (-planAT!(atStatusIsGreen;planAT~) /\\ planAT;((I[ActivityType] /\\ -(actType~;actType));planAT~)) |- planCmpStat;(\'Yellow\'[Status];planCmpStat~))
              // <=> { remove |- }
              //     -(-(I[Plan] /\\ (-planAT!(atStatusIsGreen;planAT~) /\\ planAT;((I[ActivityType] /\\ -(actType~;actType));planAT~))) \\/ planCmpStat;(\'Yellow\'[Status];planCmpStat~))
              // <=> { De Morgan }
              //     I[Plan] /\\ (-planAT!(atStatusIsGreen;planAT~) /\\ (planAT;((I[ActivityType] /\\ -(actType~;actType));planAT~) /\\ -(planCmpStat;(\'Yellow\'[Status];planCmpStat~))))
              // <=> { De Morgan }
              //     I[Plan] /\\ (-(planAT;-(atStatusIsGreen;planAT~)) /\\ (planAT;((I[ActivityType] /\\ -(actType~;actType));planAT~) /\\ -(planCmpStat;(\'Yellow\'[Status];planCmpStat~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Plan,EIsc (ECpl (ECps (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -},ECpl (ECps (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -}))))),EIsc (ECps (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -},ECps (EIsc (EDcI ActivityType,ECpl (ECps (EFlp (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -}),EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -}))),EFlp (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType +}))),ECpl (ECps (EDcD RELATION planCmpStat [Plan*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Yellow" Status,EFlp (EDcD RELATION planCmpStat [Plan*Status] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Plan] /\\ (-(planAT;-(atStatusIsGreen;planAT~)) /\\ (planAT;((I[ActivityType] /\\ -(actType~;actType));planAT~) /\\ -(planCmpStat;(\'Yellow\'[Status];planCmpStat~)))) ([Plan*Plan]) */
                          SELECT DISTINCT isect0.`SrcPlan` AS src, isect0.`TrgPlan` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    planAT;((I[ActivityType] /\\ -(actType~;actType));planAT~) */
                                 
                                 SELECT DISTINCT ECps0.`SrcPlan`, ECps2.`TrgPlan`
                                 FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `ActivityType` AS `TrgActivityType`
                                   FROM `planAT`
                                   WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: (EIsc lst\'@(_:_:_))
                                           I[ActivityType] /\\ -(actType~;actType) ([ActivityType*ActivityType]) */
                                        SELECT DISTINCT isect0.`SrcActivityType`, isect0.`TrgActivityType`
                                        FROM ( /* I[ActivityType] */
                                          SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `ActivityType` AS `TrgActivityType`
                                          FROM `ActivityType`
                                          WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              actType~;actType */
                                                           
                                                           SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                                           FROM 
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Activity` AS `TrgActivity`, `actType` AS `SrcActivityType`
                                                                  FROM `Activity`
                                                                  WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                                                ) AS ECps0,
                                                                ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                                             FROM `Activity`
                                                             WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps1
                                                           WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                                                         ) AS cp
                                                    WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL
                                      ) AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan` AS `TrgPlan`, `ActivityType` AS `SrcActivityType`
                                        FROM `planAT`
                                        WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                      ) AS ECps2
                                 WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                   AND ECps1.`TrgActivityType`=ECps2.`SrcActivityType`
                               ) AS isect0, ( /* I[Plan] */
                            SELECT DISTINCT `Plan` AS `SrcPlan`, `Plan` AS `TrgPlan`
                            FROM `Plan`
                            WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcPlan` = isect0.`TrgPlan` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                planAT;-(atStatusIsGreen;planAT~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcPlan`, ECps1.`TrgPlan`
                                             FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `ActivityType` AS `TrgActivityType`
                                               FROM `planAT`
                                               WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"atStatusIsGreen;planAT~\" ) */
                                                    SELECT DISTINCT cfst.`ActivityType` AS `SrcActivityType`, csnd.`Plan` AS `TrgPlan`
                                                    FROM `ActivityType` AS cfst,
                                                         `Plan` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                atStatusIsGreen;planAT~ */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgPlan`
                                                             FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                                               FROM `ActivityType`
                                                               WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS ECps0,
                                                                  
                                                                  ( /* case: EFlp x. */
                                                                    SELECT DISTINCT `Plan` AS `TrgPlan`, `ActivityType` AS `SrcActivityType`
                                                                    FROM `planAT`
                                                                    WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                                  ) AS ECps1
                                                             WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                                           ) AS cp
                                                      WHERE cfst.`ActivityType`=cp.`SrcActivityType` AND csnd.`Plan`=cp.`TrgPlan`)
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                           ) AS cp
                                      WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgPlan`=cp.`TrgPlan`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                planCmpStat;(\'Yellow\'[Status];planCmpStat~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcPlan`, ECps2.`TrgPlan`
                                             FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planCmpStat` AS `TrgStatus`
                                               FROM `Plan`
                                               WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Yellow" AS `SrcStatus`, "Yellow" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan` AS `TrgPlan`, `planCmpStat` AS `SrcStatus`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgPlan`=cp.`TrgPlan`) AND isect0.`SrcPlan` IS NOT NULL AND isect0.`TrgPlan` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planCmpStat;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                '/* I[Plan] */
                                 SELECT DISTINCT `Plan` AS src, `Plan` AS tgt
                                 FROM `Plan`
                                 WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'planCmpStatIsGreen' =>
        array ( 'name'          => 'planCmpStatIsGreen'
              , 'ruleAdl'       => 'I[Plan] /\\ -planAT!((atStatusIsGreen /\\ actType~;actType);planAT~) |- planCmpStat;(\'Green\'[Status];planCmpStat~)'
              , 'origin'        => 'line 22:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Plan'
              , 'tgtConcept'    => 'Plan'
              // Normalization steps:
              //     -(I[Plan] /\\ -planAT!((atStatusIsGreen /\\ actType~;actType);planAT~) |- planCmpStat;(\'Green\'[Status];planCmpStat~))
              // <=> { remove |- }
              //     -(-(I[Plan] /\\ -planAT!((atStatusIsGreen /\\ actType~;actType);planAT~)) \\/ planCmpStat;(\'Green\'[Status];planCmpStat~))
              // <=> { De Morgan }
              //     I[Plan] /\\ (-planAT!((atStatusIsGreen /\\ actType~;actType);planAT~) /\\ -(planCmpStat;(\'Green\'[Status];planCmpStat~)))
              // <=> { De Morgan }
              //     I[Plan] /\\ (-(planAT;-((atStatusIsGreen /\\ actType~;actType);planAT~)) /\\ -(planCmpStat;(\'Green\'[Status];planCmpStat~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Plan,EIsc (ECpl (ECps (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -},ECpl (ECps (EIsc (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" "",ECps (EFlp (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -}),EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -})),EFlp (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType +}))))),ECpl (ECps (EDcD RELATION planCmpStat [Plan*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Green" Status,EFlp (EDcD RELATION planCmpStat [Plan*Status] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Plan] /\\ (-(planAT;-((atStatusIsGreen /\\ actType~;actType);planAT~)) /\\ -(planCmpStat;(\'Green\'[Status];planCmpStat~))) ([Plan*Plan]) */
                          SELECT DISTINCT isect0.`SrcPlan` AS src, isect0.`TrgPlan` AS tgt
                          FROM ( /* I[Plan] */
                            SELECT DISTINCT `Plan` AS `SrcPlan`, `Plan` AS `TrgPlan`
                            FROM `Plan`
                            WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                planAT;-((atStatusIsGreen /\\ actType~;actType);planAT~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcPlan`, ECps1.`TrgPlan`
                                             FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `ActivityType` AS `TrgActivityType`
                                               FROM `planAT`
                                               WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"(atStatusIsGreen /\\ actType~;actType);planAT~\" ) */
                                                    SELECT DISTINCT cfst.`ActivityType` AS `SrcActivityType`, csnd.`Plan` AS `TrgPlan`
                                                    FROM `ActivityType` AS cfst,
                                                         `Plan` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                (atStatusIsGreen /\\ actType~;actType);planAT~ */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgPlan`
                                                             FROM 
                                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                                       atStatusIsGreen /\\ actType~;actType ([ActivityType*ActivityType]) */
                                                                    SELECT DISTINCT isect0.`SrcActivityType`, isect0.`TrgActivityType`
                                                                    FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                                                      FROM `ActivityType`
                                                                      WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS isect0, 
                                                                         ( /* case: (ECps es), with two or more elements in es.
                                                                              actType~;actType */
                                                                           
                                                                           SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                                                           FROM 
                                                                                ( /* case: EFlp x. */
                                                                                  SELECT DISTINCT `Activity` AS `TrgActivity`, `actType` AS `SrcActivityType`
                                                                                  FROM `Activity`
                                                                                  WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                                                                ) AS ECps0,
                                                                                ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                                                             FROM `Activity`
                                                                             WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps1
                                                                           WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                                                                         ) AS isect1
                                                                    WHERE (isect0.`SrcActivityType` = isect1.`SrcActivityType` AND isect0.`TrgActivityType` = isect1.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL
                                                                  ) AS ECps0,
                                                                  
                                                                  ( /* case: EFlp x. */
                                                                    SELECT DISTINCT `Plan` AS `TrgPlan`, `ActivityType` AS `SrcActivityType`
                                                                    FROM `planAT`
                                                                    WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                                  ) AS ECps1
                                                             WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                                           ) AS cp
                                                      WHERE cfst.`ActivityType`=cp.`SrcActivityType` AND csnd.`Plan`=cp.`TrgPlan`)
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                           ) AS cp
                                      WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgPlan`=cp.`TrgPlan`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                planCmpStat;(\'Green\'[Status];planCmpStat~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcPlan`, ECps2.`TrgPlan`
                                             FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planCmpStat` AS `TrgStatus`
                                               FROM `Plan`
                                               WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Green" AS `SrcStatus`, "Green" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan` AS `TrgPlan`, `planCmpStat` AS `SrcStatus`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgPlan`=cp.`TrgPlan`) AND isect0.`SrcPlan` IS NOT NULL AND isect0.`TrgPlan` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planCmpStat;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                '/* I[Plan] */
                                 SELECT DISTINCT `Plan` AS src, `Plan` AS tgt
                                 FROM `Plan`
                                 WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'InsPlanStatus' =>
        array ( 'name'          => 'InsPlanStatus'
              , 'ruleAdl'       => 'planMnlStat \\/ (I[Plan] /\\ -(planMnlStat;planMnlStat~));planCmpStat |- planStatus'
              , 'origin'        => 'line 27:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Plan'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(planMnlStat \\/ (I[Plan] /\\ -(planMnlStat;planMnlStat~));planCmpStat |- planStatus)
              // <=> { remove |- }
              //     -(-(planMnlStat \\/ (I[Plan] /\\ -(planMnlStat;planMnlStat~));planCmpStat) \\/ planStatus)
              // <=> { De Morgan }
              //     -(-planMnlStat /\\ -((I[Plan] /\\ -(planMnlStat;planMnlStat~));planCmpStat)) /\\ -planStatus
              // 
              // Normalized complement (== violationsSQL): EIsc (ECpl (EIsc (ECpl (EDcD RELATION planMnlStat [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can be assigned a new status -}),ECpl (ECps (EIsc (EDcI Plan,ECpl (ECps (EDcD RELATION planMnlStat [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can be assigned a new status -},EFlp (EDcD RELATION planMnlStat [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can be assigned a new status -})))),EDcD RELATION planCmpStat [Plan*Status] Nothing PRAGMA "" "" "")))),ECpl (EDcD RELATION planStatus [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can have a status (colour) +}))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             -(-planMnlStat /\\ -((I[Plan] /\\ -(planMnlStat;planMnlStat~));planCmpStat)) /\\ -planStatus ([Plan*Status]) */
                          SELECT DISTINCT isect0.`SrcPlan` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \"-planMnlStat /\\ -((I[Plan] /\\ -(planMnlStat;planMnlStat~));planCmpStat)\" ) */
                                 SELECT DISTINCT cfst.`Plan` AS `SrcPlan`, csnd.`Status` AS `TrgStatus`
                                 FROM `Plan` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\'@(_:_:_))
                                             -planMnlStat /\\ -((I[Plan] /\\ -(planMnlStat;planMnlStat~));planCmpStat) ([Plan*Status]) */
                                          SELECT DISTINCT isect0.`SrcPlan`, isect0.`TrgStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \"planMnlStat\" ) */
                                                 SELECT DISTINCT cfst.`Plan` AS `SrcPlan`, csnd.`Status` AS `TrgStatus`
                                                 FROM `Plan` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planMnlStat` AS `TrgStatus`
                                                     FROM `Plan`
                                                     WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL ) AS cp
                                                   WHERE cfst.`Plan`=cp.`SrcPlan` AND csnd.`Status`=cp.`TrgStatus`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                (I[Plan] /\\ -(planMnlStat;planMnlStat~));planCmpStat */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcPlan`, ECps1.`TrgStatus`
                                                             FROM 
                                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                                       I[Plan] /\\ -(planMnlStat;planMnlStat~) ([Plan*Plan]) */
                                                                    SELECT DISTINCT isect0.`SrcPlan`, isect0.`TrgPlan`
                                                                    FROM ( /* I[Plan] */
                                                                      SELECT DISTINCT `Plan` AS `SrcPlan`, `Plan` AS `TrgPlan`
                                                                      FROM `Plan`
                                                                      WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL ) AS isect0
                                                                    WHERE NOT EXISTS (SELECT * FROM 
                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                          planMnlStat;planMnlStat~ */
                                                                                       
                                                                                       SELECT DISTINCT ECps0.`SrcPlan`, ECps1.`TrgPlan`
                                                                                       FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planMnlStat` AS `TrgStatus`
                                                                                         FROM `Plan`
                                                                                         WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL ) AS ECps0,
                                                                                            
                                                                                            ( /* case: EFlp x. */
                                                                                              SELECT DISTINCT `Plan` AS `TrgPlan`, `planMnlStat` AS `SrcStatus`
                                                                                              FROM `Plan`
                                                                                              WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL
                                                                                            ) AS ECps1
                                                                                       WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                                                                     ) AS cp
                                                                                WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgPlan`=cp.`TrgPlan`) AND isect0.`SrcPlan` IS NOT NULL AND isect0.`TrgPlan` IS NOT NULL
                                                                  ) AS ECps0,
                                                                  ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planCmpStat` AS `TrgStatus`
                                                               FROM `Plan`
                                                               WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL ) AS ECps1
                                                             WHERE ECps0.`TrgPlan`=ECps1.`SrcPlan`
                                                           ) AS cp
                                                      WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcPlan` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Plan`=cp.`SrcPlan` AND csnd.`Status`=cp.`TrgStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planStatus` AS `TrgStatus`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcPlan` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planStatus;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                '/* I[Plan] */
                                 SELECT DISTINCT `Plan` AS src, `Plan` AS tgt
                                 FROM `Plan`
                                 WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                 SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultPlanStatus' =>
        array ( 'name'          => 'defaultPlanStatus'
              , 'ruleAdl'       => 'I[Plan] |- planStatus;planStatus~'
              , 'origin'        => 'line 30:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Plan'
              , 'tgtConcept'    => 'Plan'
              // Normalization steps:
              //     -(I[Plan] |- planStatus;planStatus~)
              // <=> { remove |- }
              //     -(-I[Plan] \\/ planStatus;planStatus~)
              // <=> { De Morgan }
              //     I[Plan] /\\ -(planStatus;planStatus~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Plan,ECpl (ECps (EDcD RELATION planStatus [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can have a status (colour) -},EFlp (EDcD RELATION planStatus [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can have a status (colour) +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Plan] /\\ -(planStatus;planStatus~) ([Plan*Plan]) */
                          SELECT DISTINCT isect0.`SrcPlan` AS src, isect0.`TrgPlan` AS tgt
                          FROM ( /* I[Plan] */
                            SELECT DISTINCT `Plan` AS `SrcPlan`, `Plan` AS `TrgPlan`
                            FROM `Plan`
                            WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                planStatus;planStatus~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcPlan`, ECps1.`TrgPlan`
                                             FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planStatus` AS `TrgStatus`
                                               FROM `Plan`
                                               WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan` AS `TrgPlan`, `planStatus` AS `SrcStatus`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgPlan`=cp.`TrgPlan`) AND isect0.`SrcPlan` IS NOT NULL AND isect0.`TrgPlan` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planStatus;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                '/* I[Plan] */
                                 SELECT DISTINCT `Plan` AS src, `Plan` AS tgt
                                 FROM `Plan`
                                 WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'insatStatusIsGreen' =>
        array ( 'name'          => 'insatStatusIsGreen'
              , 'ruleAdl'       => 'I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ -(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~))) |- atStatusIsGreen'
              , 'origin'        => 'line 45:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ -(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~))) |- atStatusIsGreen)
              // <=> { remove |- }
              //     -(-(I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ -(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~)))) \\/ atStatusIsGreen)
              // <=> { De Morgan }
              //     I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ (-(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~)) /\\ -atStatusIsGreen))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI ActivityType,EIsc (ECps (EFlp (EDcD RELATION ouMayExecuteAT [OrgUnit*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit has all necessary capabilities for executing activities of the ActivityType -}),EDcD RELATION ouMayExecuteAT [OrgUnit*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit has all necessary capabilities for executing activities of the ActivityType -}),EIsc (ECpl (ECps (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -},ECps (ECpl (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -})),EFlp (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service +})))),ECpl (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ (-(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~)) /\\ -atStatusIsGreen)) ([ActivityType*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcActivityType` AS src, isect0.`TrgActivityType` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ouMayExecuteAT~;ouMayExecuteAT */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `ActivityType` AS `SrcActivityType`
                                        FROM `ouMayExecuteAT`
                                        WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ActivityType` AS `TrgActivityType`
                                   FROM `ouMayExecuteAT`
                                   WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                               ) AS isect0, ( /* I[ActivityType] */
                            SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `ActivityType` AS `TrgActivityType`
                            FROM `ActivityType`
                            WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcActivityType` = isect0.`TrgActivityType` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps2.`TrgActivityType`
                                             FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                               FROM `atReqsSvc`
                                               WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"scImplements~;scImplements\" ) */
                                                    SELECT DISTINCT cfst.`Service` AS `SrcService`, csnd.`Service` AS `TrgService`
                                                    FROM `Service` AS cfst,
                                                         `Service` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                scImplements~;scImplements */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                                             FROM 
                                                                  ( /* case: EFlp x. */
                                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                                    FROM `scImplements`
                                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                  ) AS ECps0,
                                                                  ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                               FROM `scImplements`
                                                               WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                           ) AS cp
                                                      WHERE cfst.`Service`=cp.`SrcService` AND csnd.`Service`=cp.`TrgService`)
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ActivityType` AS `TrgActivityType`, `Service` AS `SrcService`
                                                    FROM `atReqsSvc`
                                                    WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgService`=ECps1.`SrcService`
                                               AND ECps1.`TrgService`=ECps2.`SrcService`
                                           ) AS cp
                                      WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                        FROM `ActivityType`
                                        WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;atStatusIsGreen;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;atStatus;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'delatStatusIsGreen' =>
        array ( 'name'          => 'delatStatusIsGreen'
              , 'ruleAdl'       => 'atStatusIsGreen |- I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ -(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~)))'
              , 'origin'        => 'line 54:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(atStatusIsGreen |- I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ -(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~))))
              // <=> { remove |- }
              //     -(-atStatusIsGreen \\/ (I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ -(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~)))))
              // <=> { De Morgan }
              //     atStatusIsGreen /\\ -(I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ -(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI ActivityType,EIsc (ECps (EFlp (EDcD RELATION ouMayExecuteAT [OrgUnit*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit has all necessary capabilities for executing activities of the ActivityType -}),EDcD RELATION ouMayExecuteAT [OrgUnit*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit has all necessary capabilities for executing activities of the ActivityType -}),ECpl (ECps (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -},ECps (ECpl (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -})),EFlp (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service +}))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             atStatusIsGreen /\\ -(I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ -(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~)))) ([ActivityType*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcActivityType` AS src, isect0.`TrgActivityType` AS tgt
                          FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                            FROM `ActivityType`
                            WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[ActivityType] /\\ (ouMayExecuteAT~;ouMayExecuteAT /\\ -(atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~))) ([ActivityType*ActivityType]) */
                                             SELECT DISTINCT isect0.`SrcActivityType`, isect0.`TrgActivityType`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       ouMayExecuteAT~;ouMayExecuteAT */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `ActivityType` AS `SrcActivityType`
                                                           FROM `ouMayExecuteAT`
                                                           WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                         ) AS ECps0,
                                                         ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ActivityType` AS `TrgActivityType`
                                                      FROM `ouMayExecuteAT`
                                                      WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps1
                                                    WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                                                  ) AS isect0, ( /* I[ActivityType] */
                                               SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `ActivityType` AS `TrgActivityType`
                                               FROM `ActivityType`
                                               WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect1
                                             WHERE isect0.`SrcActivityType` = isect0.`TrgActivityType` AND NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   atReqsSvc;(-(scImplements~;scImplements);atReqsSvc~) */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcActivityType`, ECps2.`TrgActivityType`
                                                                FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                                                  FROM `atReqsSvc`
                                                                  WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                                                     
                                                                     ( /* case: ECpl e
                                                                          ECpl ( \"scImplements~;scImplements\" ) */
                                                                       SELECT DISTINCT cfst.`Service` AS `SrcService`, csnd.`Service` AS `TrgService`
                                                                       FROM `Service` AS cfst,
                                                                            `Service` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM 
                                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                                   scImplements~;scImplements */
                                                                                
                                                                                SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                                                                FROM 
                                                                                     ( /* case: EFlp x. */
                                                                                       SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                                                       FROM `scImplements`
                                                                                       WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                                     ) AS ECps0,
                                                                                     ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                                                  FROM `scImplements`
                                                                                  WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                                                WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                                              ) AS cp
                                                                         WHERE cfst.`Service`=cp.`SrcService` AND csnd.`Service`=cp.`TrgService`)
                                                                     ) AS ECps1,
                                                                     
                                                                     ( /* case: EFlp x. */
                                                                       SELECT DISTINCT `ActivityType` AS `TrgActivityType`, `Service` AS `SrcService`
                                                                       FROM `atReqsSvc`
                                                                       WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL
                                                                     ) AS ECps2
                                                                WHERE ECps0.`TrgService`=ECps1.`SrcService`
                                                                  AND ECps1.`TrgService`=ECps2.`SrcService`
                                                              ) AS cp
                                                         WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;atStatusIsGreen;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    )
              )
    , 'atStatusIsYellow' =>
        array ( 'name'          => 'atStatusIsYellow'
              , 'ruleAdl'       => 'I[ActivityType] /\\ (-atStatusIsGreen /\\ -(planAT~;planAT)) |- atStatus;(\'Yellow\'[Status];atStatus~)'
              , 'origin'        => 'line 62:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(I[ActivityType] /\\ (-atStatusIsGreen /\\ -(planAT~;planAT)) |- atStatus;(\'Yellow\'[Status];atStatus~))
              // <=> { remove |- }
              //     -(-(I[ActivityType] /\\ (-atStatusIsGreen /\\ -(planAT~;planAT))) \\/ atStatus;(\'Yellow\'[Status];atStatus~))
              // <=> { De Morgan }
              //     I[ActivityType] /\\ (-atStatusIsGreen /\\ (-(planAT~;planAT) /\\ -(atStatus;(\'Yellow\'[Status];atStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI ActivityType,EIsc (ECpl (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" ""),EIsc (ECpl (ECps (EFlp (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -}),EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType +})),ECpl (ECps (EDcD RELATION atStatus [ActivityType*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Yellow" Status,EFlp (EDcD RELATION atStatus [ActivityType*Status] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[ActivityType] /\\ (-atStatusIsGreen /\\ (-(planAT~;planAT) /\\ -(atStatus;(\'Yellow\'[Status];atStatus~)))) ([ActivityType*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcActivityType` AS src, isect0.`TrgActivityType` AS tgt
                          FROM ( /* I[ActivityType] */
                            SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `ActivityType` AS `TrgActivityType`
                            FROM `ActivityType`
                            WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                        FROM `ActivityType`
                                        WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                planAT~;planAT */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan` AS `TrgPlan`, `ActivityType` AS `SrcActivityType`
                                                    FROM `planAT`
                                                    WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                  ) AS ECps0,
                                                  ( SELECT DISTINCT `Plan` AS `SrcPlan`, `ActivityType` AS `TrgActivityType`
                                               FROM `planAT`
                                               WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps1
                                             WHERE ECps0.`TrgPlan`=ECps1.`SrcPlan`
                                           ) AS cp
                                      WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                atStatus;(\'Yellow\'[Status];atStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps2.`TrgActivityType`
                                             FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatus` AS `TrgStatus`
                                               FROM `ActivityType`
                                               WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Yellow" AS `SrcStatus`, "Yellow" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ActivityType` AS `TrgActivityType`, `atStatus` AS `SrcStatus`
                                                    FROM `ActivityType`
                                                    WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;atStatus;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'atStatusIsRed' =>
        array ( 'name'          => 'atStatusIsRed'
              , 'ruleAdl'       => 'I[ActivityType] /\\ (-atStatusIsGreen /\\ planAT~;planAT) |- atStatus;(\'Red\'[Status];atStatus~)'
              , 'origin'        => 'line 66:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(I[ActivityType] /\\ (-atStatusIsGreen /\\ planAT~;planAT) |- atStatus;(\'Red\'[Status];atStatus~))
              // <=> { remove |- }
              //     -(-(I[ActivityType] /\\ (-atStatusIsGreen /\\ planAT~;planAT)) \\/ atStatus;(\'Red\'[Status];atStatus~))
              // <=> { De Morgan }
              //     I[ActivityType] /\\ (-atStatusIsGreen /\\ (planAT~;planAT /\\ -(atStatus;(\'Red\'[Status];atStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI ActivityType,EIsc (ECpl (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" ""),EIsc (ECps (EFlp (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -}),EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType +}),ECpl (ECps (EDcD RELATION atStatus [ActivityType*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Red" Status,EFlp (EDcD RELATION atStatus [ActivityType*Status] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[ActivityType] /\\ (-atStatusIsGreen /\\ (planAT~;planAT /\\ -(atStatus;(\'Red\'[Status];atStatus~)))) ([ActivityType*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcActivityType` AS src, isect0.`TrgActivityType` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    planAT~;planAT */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan` AS `TrgPlan`, `ActivityType` AS `SrcActivityType`
                                        FROM `planAT`
                                        WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Plan` AS `SrcPlan`, `ActivityType` AS `TrgActivityType`
                                   FROM `planAT`
                                   WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgPlan`=ECps1.`SrcPlan`
                               ) AS isect0, ( /* I[ActivityType] */
                            SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `ActivityType` AS `TrgActivityType`
                            FROM `ActivityType`
                            WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcActivityType` = isect0.`TrgActivityType` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                        FROM `ActivityType`
                                        WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                atStatus;(\'Red\'[Status];atStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps2.`TrgActivityType`
                                             FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatus` AS `TrgStatus`
                                               FROM `ActivityType`
                                               WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Red" AS `SrcStatus`, "Red" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ActivityType` AS `TrgActivityType`, `atStatus` AS `SrcStatus`
                                                    FROM `ActivityType`
                                                    WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;atStatus;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                '/* I[ActivityType] */
                                 SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'actCmpStatIsRed' =>
        array ( 'name'          => 'actCmpStatIsRed'
              , 'ruleAdl'       => 'I[Activity] /\\ (-(actExecutingOU;actExecutingOU~) \\/ -(actPlanStart;actPlanStart~)) |- actCmpStat;(\'Red\'[Status];actCmpStat~)'
              , 'origin'        => 'line 82:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] /\\ (-(actExecutingOU;actExecutingOU~) \\/ -(actPlanStart;actPlanStart~)) |- actCmpStat;(\'Red\'[Status];actCmpStat~))
              // <=> { remove |- }
              //     -(-(I[Activity] /\\ (-(actExecutingOU;actExecutingOU~) \\/ -(actPlanStart;actPlanStart~))) \\/ actCmpStat;(\'Red\'[Status];actCmpStat~))
              // <=> { De Morgan }
              //     I[Activity] /\\ ((-(actExecutingOU;actExecutingOU~) \\/ -(actPlanStart;actPlanStart~)) /\\ -(actCmpStat;(\'Red\'[Status];actCmpStat~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Activity,EIsc (EUni (ECpl (ECps (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -},EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -}))),ECpl (ECps (EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. -},EFlp (EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. +})))),ECpl (ECps (EDcD RELATION actCmpStat [Activity*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Red" Status,EFlp (EDcD RELATION actCmpStat [Activity*Status] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Activity] /\\ ((-(actExecutingOU;actExecutingOU~) \\/ -(actPlanStart;actPlanStart~)) /\\ -(actCmpStat;(\'Red\'[Status];actCmpStat~))) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgActivity` AS tgt
                          FROM 
                               ( /* case: EUni (l,r)
                                    -(actExecutingOU;actExecutingOU~) \\/ -(actPlanStart;actPlanStart~) ([Activity*Activity]) */
                                 (/* case: ECpl e
                                        ECpl ( \"actExecutingOU;actExecutingOU~\" ) */
                                     SELECT DISTINCT cfst.`Activity` AS `SrcActivity`, csnd.`Activity` AS `TrgActivity`
                                     FROM `Activity` AS cfst,
                                          `Activity` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actExecutingOU;actExecutingOU~ */
                                              
                                              SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                              FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actExecutingOU` AS `TrgOrgUnit`
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL ) AS ECps0,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                                     FROM `Activity`
                                                     WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                                            ) AS cp
                                       WHERE cfst.`Activity`=cp.`SrcActivity` AND csnd.`Activity`=cp.`TrgActivity`)
                                 ) UNION (/* case: ECpl e
                                        ECpl ( \"actPlanStart;actPlanStart~\" ) */
                                     SELECT DISTINCT cfst.`Activity` AS `SrcActivity`, csnd.`Activity` AS `TrgActivity`
                                     FROM `Activity` AS cfst,
                                          `Activity` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actPlanStart;actPlanStart~ */
                                              
                                              SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                              FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actPlanStart` AS `TrgTimestamp`
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL ) AS ECps0,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlanStart` AS `SrcTimestamp`
                                                     FROM `Activity`
                                                     WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`TrgTimestamp`=ECps1.`SrcTimestamp`
                                            ) AS cp
                                       WHERE cfst.`Activity`=cp.`SrcActivity` AND csnd.`Activity`=cp.`TrgActivity`)
                                 )
                               ) AS isect0, ( /* I[Activity] */
                            SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                            FROM `Activity`
                            WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcActivity` = isect0.`TrgActivity` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actCmpStat;(\'Red\'[Status];actCmpStat~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps2.`TrgActivity`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actCmpStat` AS `TrgStatus`
                                               FROM `Activity`
                                               WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Red" AS `SrcStatus`, "Red" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity` AS `TrgActivity`, `actCmpStat` AS `SrcStatus`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                 SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'actCmpStatIsYellow' =>
        array ( 'name'          => 'actCmpStatIsYellow'
              , 'ruleAdl'       => 'I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (I[Activity] /\\ -(actType;(-atReqsSvc!(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))))))) |- actCmpStat;(\'Yellow\'[Status];actCmpStat~)'
              , 'origin'        => 'line 86:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (I[Activity] /\\ -(actType;(-atReqsSvc!(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))))))) |- actCmpStat;(\'Yellow\'[Status];actCmpStat~))
              // <=> { remove |- }
              //     -(-(I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (I[Activity] /\\ -(actType;(-atReqsSvc!(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))))))))) \\/ actCmpStat;(\'Yellow\'[Status];actCmpStat~))
              // <=> { De Morgan }
              //     I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (I[Activity] /\\ (-(actType;(-atReqsSvc!(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))))) /\\ -(actCmpStat;(\'Yellow\'[Status];actCmpStat~))))))
              // <=> { I[Activity] /\\ I[Activity] = I[Activity] }
              //     I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (-(actType;(-atReqsSvc!(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))))) /\\ -(actCmpStat;(\'Yellow\'[Status];actCmpStat~)))))
              // <=> { De Morgan }
              //     I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (-(actType;-(atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))))) /\\ -(actCmpStat;(\'Yellow\'[Status];actCmpStat~)))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Activity,EIsc (ECps (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -},EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -})),EIsc (ECps (EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. -},EFlp (EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. -})),EIsc (ECpl (ECps (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -},ECpl (ECps (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -},ECpl (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EIsc (EFlp (EDcD RELATION actUseSC [Activity*SvcComponent] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity requires the availability of the SvcComponent -}),ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},ECps (EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit +})))))))))),ECpl (ECps (EDcD RELATION actCmpStat [Activity*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Yellow" Status,EFlp (EDcD RELATION actCmpStat [Activity*Status] Nothing PRAGMA "" "" ""))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (-(actType;-(atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))))) /\\ -(actCmpStat;(\'Yellow\'[Status];actCmpStat~))))) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgActivity` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU;actExecutingOU~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                 FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actExecutingOU` AS `TrgOrgUnit`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actPlanStart;actPlanStart~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                 FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actPlanStart` AS `TrgTimestamp`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlanStart` AS `SrcTimestamp`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgTimestamp`=ECps1.`SrcTimestamp`
                               ) AS isect1, ( /* I[Activity] */
                            SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                            FROM `Activity`
                            WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcActivity` = isect1.`SrcActivity` AND isect0.`TrgActivity` = isect1.`TrgActivity`) AND isect0.`SrcActivity` = isect0.`TrgActivity` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actType;-(atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))) */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                               FROM `Activity`
                                               WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))\" ) */
                                                    SELECT DISTINCT cfst.`ActivityType` AS `SrcActivityType`, csnd.`Activity` AS `TrgActivity`
                                                    FROM `ActivityType` AS cfst,
                                                         `Activity` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))) */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivity`
                                                             FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                                               FROM `atReqsSvc`
                                                               WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                                                  
                                                                  ( /* case: ECpl e
                                                                       ECpl ( \"scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))\" ) */
                                                                    SELECT DISTINCT cfst.`Service` AS `SrcService`, csnd.`Activity` AS `TrgActivity`
                                                                    FROM `Service` AS cfst,
                                                                         `Activity` AS csnd
                                                                    WHERE NOT EXISTS
                                                                     (SELECT * FROM 
                                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                                scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)) */
                                                                             
                                                                             SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgActivity`
                                                                             FROM 
                                                                                  ( /* case: EFlp x. */
                                                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                                                    FROM `scImplements`
                                                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                                  ) AS ECps0,
                                                                                  
                                                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                                                       actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~) ([SvcComponent*Activity]) */
                                                                                    SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TrgActivity`
                                                                                    FROM 
                                                                                         ( /* case: EFlp x. */
                                                                                           SELECT DISTINCT `Activity` AS `TrgActivity`, `SvcComponent` AS `SrcSvcComponent`
                                                                                           FROM `actUseSC`
                                                                                           WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL
                                                                                         ) AS isect0, 
                                                                                         ( /* case: (ECps es), with two or more elements in es.
                                                                                              scDeployedOn;(compOwner;actExecutingOU~) */
                                                                                           
                                                                                           SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgActivity`
                                                                                           FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                                                             FROM `scDeployedOn`
                                                                                             WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                                                                ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compOwner` AS `TrgOrgUnit`
                                                                                             FROM `Computer`
                                                                                             WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL ) AS ECps1,
                                                                                                
                                                                                                ( /* case: EFlp x. */
                                                                                                  SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                                                                                  FROM `Activity`
                                                                                                  WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                                                                ) AS ECps2
                                                                                           WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                                                             AND ECps1.`TrgOrgUnit`=ECps2.`SrcOrgUnit`
                                                                                         ) AS isect1
                                                                                    WHERE (isect0.`SrcSvcComponent` = isect1.`SrcSvcComponent` AND isect0.`TrgActivity` = isect1.`TrgActivity`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL
                                                                                  ) AS ECps1
                                                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                                           ) AS cp
                                                                      WHERE cfst.`Service`=cp.`SrcService` AND csnd.`Activity`=cp.`TrgActivity`)
                                                                  ) AS ECps1
                                                             WHERE ECps0.`TrgService`=ECps1.`SrcService`
                                                           ) AS cp
                                                      WHERE cfst.`ActivityType`=cp.`SrcActivityType` AND csnd.`Activity`=cp.`TrgActivity`)
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actCmpStat;(\'Yellow\'[Status];actCmpStat~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps2.`TrgActivity`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actCmpStat` AS `TrgStatus`
                                               FROM `Activity`
                                               WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Yellow" AS `SrcStatus`, "Yellow" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity` AS `TrgActivity`, `actCmpStat` AS `SrcStatus`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                 SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'actCmpStatIsGreen' =>
        array ( 'name'          => 'actCmpStatIsGreen'
              , 'ruleAdl'       => 'I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ actType;(-atReqsSvc!(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))))) |- actCmpStat;(\'Green\'[Status];actCmpStat~)'
              , 'origin'        => 'line 92:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ actType;(-atReqsSvc!(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))))) |- actCmpStat;(\'Green\'[Status];actCmpStat~))
              // <=> { remove |- }
              //     -(-(I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ actType;(-atReqsSvc!(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))))))) \\/ actCmpStat;(\'Green\'[Status];actCmpStat~))
              // <=> { De Morgan }
              //     I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (actType;(-atReqsSvc!(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))) /\\ -(actCmpStat;(\'Green\'[Status];actCmpStat~)))))
              // <=> { De Morgan }
              //     I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (actType;-(atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))) /\\ -(actCmpStat;(\'Green\'[Status];actCmpStat~)))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Activity,EIsc (ECps (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -},EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -})),EIsc (ECps (EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. -},EFlp (EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. -})),EIsc (ECps (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -},ECpl (ECps (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -},ECpl (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EIsc (EFlp (EDcD RELATION actUseSC [Activity*SvcComponent] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity requires the availability of the SvcComponent -}),ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},ECps (EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit +}))))))))),ECpl (ECps (EDcD RELATION actCmpStat [Activity*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Green" Status,EFlp (EDcD RELATION actCmpStat [Activity*Status] Nothing PRAGMA "" "" ""))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Activity] /\\ (actExecutingOU;actExecutingOU~ /\\ (actPlanStart;actPlanStart~ /\\ (actType;-(atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))) /\\ -(actCmpStat;(\'Green\'[Status];actCmpStat~))))) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgActivity` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU;actExecutingOU~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                 FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actExecutingOU` AS `TrgOrgUnit`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actPlanStart;actPlanStart~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                 FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actPlanStart` AS `TrgTimestamp`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlanStart` AS `SrcTimestamp`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgTimestamp`=ECps1.`SrcTimestamp`
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actType;-(atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))) */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                 FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: ECpl e
                                           ECpl ( \"atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)))\" ) */
                                        SELECT DISTINCT cfst.`ActivityType` AS `SrcActivityType`, csnd.`Activity` AS `TrgActivity`
                                        FROM `ActivityType` AS cfst,
                                             `Activity` AS csnd
                                        WHERE NOT EXISTS
                                         (SELECT * FROM 
                                               ( /* case: (ECps es), with two or more elements in es.
                                                    atReqsSvc;-(scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))) */
                                                 
                                                 SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivity`
                                                 FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                                   FROM `atReqsSvc`
                                                   WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                                      
                                                      ( /* case: ECpl e
                                                           ECpl ( \"scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~))\" ) */
                                                        SELECT DISTINCT cfst.`Service` AS `SrcService`, csnd.`Activity` AS `TrgActivity`
                                                        FROM `Service` AS cfst,
                                                             `Activity` AS csnd
                                                        WHERE NOT EXISTS
                                                         (SELECT * FROM 
                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                    scImplements~;(actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~)) */
                                                                 
                                                                 SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgActivity`
                                                                 FROM 
                                                                      ( /* case: EFlp x. */
                                                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                                        FROM `scImplements`
                                                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                      ) AS ECps0,
                                                                      
                                                                      ( /* case: (EIsc lst\'@(_:_:_))
                                                                           actUseSC~ /\\ scDeployedOn;(compOwner;actExecutingOU~) ([SvcComponent*Activity]) */
                                                                        SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TrgActivity`
                                                                        FROM 
                                                                             ( /* case: EFlp x. */
                                                                               SELECT DISTINCT `Activity` AS `TrgActivity`, `SvcComponent` AS `SrcSvcComponent`
                                                                               FROM `actUseSC`
                                                                               WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL
                                                                             ) AS isect0, 
                                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                                  scDeployedOn;(compOwner;actExecutingOU~) */
                                                                               
                                                                               SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgActivity`
                                                                               FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                                                 FROM `scDeployedOn`
                                                                                 WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                                                    ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compOwner` AS `TrgOrgUnit`
                                                                                 FROM `Computer`
                                                                                 WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL ) AS ECps1,
                                                                                    
                                                                                    ( /* case: EFlp x. */
                                                                                      SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                                                                      FROM `Activity`
                                                                                      WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                                                    ) AS ECps2
                                                                               WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                                                 AND ECps1.`TrgOrgUnit`=ECps2.`SrcOrgUnit`
                                                                             ) AS isect1
                                                                        WHERE (isect0.`SrcSvcComponent` = isect1.`SrcSvcComponent` AND isect0.`TrgActivity` = isect1.`TrgActivity`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL
                                                                      ) AS ECps1
                                                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                               ) AS cp
                                                          WHERE cfst.`Service`=cp.`SrcService` AND csnd.`Activity`=cp.`TrgActivity`)
                                                      ) AS ECps1
                                                 WHERE ECps0.`TrgService`=ECps1.`SrcService`
                                               ) AS cp
                                          WHERE cfst.`ActivityType`=cp.`SrcActivityType` AND csnd.`Activity`=cp.`TrgActivity`)
                                      ) AS ECps1
                                 WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                               ) AS isect2, ( /* I[Activity] */
                            SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                            FROM `Activity`
                            WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect3
                          WHERE (isect0.`SrcActivity` = isect1.`SrcActivity` AND isect0.`TrgActivity` = isect1.`TrgActivity`) AND (isect0.`SrcActivity` = isect2.`SrcActivity` AND isect0.`TrgActivity` = isect2.`TrgActivity`) AND isect0.`SrcActivity` = isect0.`TrgActivity` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actCmpStat;(\'Green\'[Status];actCmpStat~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps2.`TrgActivity`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actCmpStat` AS `TrgStatus`
                                               FROM `Activity`
                                               WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Green" AS `SrcStatus`, "Green" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity` AS `TrgActivity`, `actCmpStat` AS `SrcStatus`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                 SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'InsActivityStatus' =>
        array ( 'name'          => 'InsActivityStatus'
              , 'ruleAdl'       => 'actMnlStat \\/ (I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat |- actStatus'
              , 'origin'        => 'line 99:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(actMnlStat \\/ (I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat |- actStatus)
              // <=> { remove |- }
              //     -(-(actMnlStat \\/ (I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat) \\/ actStatus)
              // <=> { De Morgan }
              //     -(-actMnlStat /\\ -((I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat)) /\\ -actStatus
              // 
              // Normalized complement (== violationsSQL): EIsc (ECpl (EIsc (ECpl (EDcD RELATION actMnlStat [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can be assigned a new status -}),ECpl (ECps (EIsc (EDcI Activity,ECpl (ECps (EDcD RELATION actMnlStat [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can be assigned a new status -},EFlp (EDcD RELATION actMnlStat [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can be assigned a new status -})))),EDcD RELATION actCmpStat [Activity*Status] Nothing PRAGMA "" "" "")))),ECpl (EDcD RELATION actStatus [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can have a status (colour) +}))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             -(-actMnlStat /\\ -((I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat)) /\\ -actStatus ([Activity*Status]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \"-actMnlStat /\\ -((I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat)\" ) */
                                 SELECT DISTINCT cfst.`Activity` AS `SrcActivity`, csnd.`Status` AS `TrgStatus`
                                 FROM `Activity` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\'@(_:_:_))
                                             -actMnlStat /\\ -((I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat) ([Activity*Status]) */
                                          SELECT DISTINCT isect0.`SrcActivity`, isect0.`TrgStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \"actMnlStat\" ) */
                                                 SELECT DISTINCT cfst.`Activity` AS `SrcActivity`, csnd.`Status` AS `TrgStatus`
                                                 FROM `Activity` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actMnlStat` AS `TrgStatus`
                                                     FROM `Activity`
                                                     WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL ) AS cp
                                                   WHERE cfst.`Activity`=cp.`SrcActivity` AND csnd.`Status`=cp.`TrgStatus`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                (I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgStatus`
                                                             FROM 
                                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                                       I[Activity] /\\ -(actMnlStat;actMnlStat~) ([Activity*Activity]) */
                                                                    SELECT DISTINCT isect0.`SrcActivity`, isect0.`TrgActivity`
                                                                    FROM ( /* I[Activity] */
                                                                      SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                                                                      FROM `Activity`
                                                                      WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect0
                                                                    WHERE NOT EXISTS (SELECT * FROM 
                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                          actMnlStat;actMnlStat~ */
                                                                                       
                                                                                       SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                                                                       FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actMnlStat` AS `TrgStatus`
                                                                                         FROM `Activity`
                                                                                         WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL ) AS ECps0,
                                                                                            
                                                                                            ( /* case: EFlp x. */
                                                                                              SELECT DISTINCT `Activity` AS `TrgActivity`, `actMnlStat` AS `SrcStatus`
                                                                                              FROM `Activity`
                                                                                              WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL
                                                                                            ) AS ECps1
                                                                                       WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                                                                     ) AS cp
                                                                                WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL
                                                                  ) AS ECps0,
                                                                  ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actCmpStat` AS `TrgStatus`
                                                               FROM `Activity`
                                                               WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL ) AS ECps1
                                                             WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                                                           ) AS cp
                                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Activity`=cp.`SrcActivity` AND csnd.`Status`=cp.`TrgStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actStatus` AS `TrgStatus`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actStatus;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                 SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                 SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultActivityStatus' =>
        array ( 'name'          => 'defaultActivityStatus'
              , 'ruleAdl'       => 'I[Activity] |- actStatus;actStatus~'
              , 'origin'        => 'line 102:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] |- actStatus;actStatus~)
              // <=> { remove |- }
              //     -(-I[Activity] \\/ actStatus;actStatus~)
              // <=> { De Morgan }
              //     I[Activity] /\\ -(actStatus;actStatus~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Activity,ECpl (ECps (EDcD RELATION actStatus [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can have a status (colour) -},EFlp (EDcD RELATION actStatus [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can have a status (colour) +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Activity] /\\ -(actStatus;actStatus~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgActivity` AS tgt
                          FROM ( /* I[Activity] */
                            SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                            FROM `Activity`
                            WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actStatus;actStatus~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actStatus` AS `TrgStatus`
                                               FROM `Activity`
                                               WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity` AS `TrgActivity`, `actStatus` AS `SrcStatus`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actStatus;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                 SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'InsOrgUnitStatus' =>
        array ( 'name'          => 'InsOrgUnitStatus'
              , 'ruleAdl'       => 'ouMnlStat \\/ (I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat |- ouStatus'
              , 'origin'        => 'line 108:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(ouMnlStat \\/ (I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat |- ouStatus)
              // <=> { remove |- }
              //     -(-(ouMnlStat \\/ (I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat) \\/ ouStatus)
              // <=> { De Morgan }
              //     -(-ouMnlStat /\\ -((I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat)) /\\ -ouStatus
              // 
              // Normalized complement (== violationsSQL): EIsc (ECpl (EIsc (ECpl (EDcD RELATION ouMnlStat [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can be assigned a new status -}),ECpl (ECps (EIsc (EDcI OrgUnit,ECpl (ECps (EDcD RELATION ouMnlStat [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can be assigned a new status -},EFlp (EDcD RELATION ouMnlStat [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can be assigned a new status -})))),EDcD RELATION ouCmpStat [OrgUnit*Status] Nothing PRAGMA "" "" "")))),ECpl (EDcD RELATION ouStatus [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can have a status (colour) +}))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             -(-ouMnlStat /\\ -((I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat)) /\\ -ouStatus ([OrgUnit*Status]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \"-ouMnlStat /\\ -((I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat)\" ) */
                                 SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`Status` AS `TrgStatus`
                                 FROM `OrgUnit` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\'@(_:_:_))
                                             -ouMnlStat /\\ -((I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat) ([OrgUnit*Status]) */
                                          SELECT DISTINCT isect0.`SrcOrgUnit`, isect0.`TrgStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \"ouMnlStat\" ) */
                                                 SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`Status` AS `TrgStatus`
                                                 FROM `OrgUnit` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ouMnlStat` AS `TrgStatus`
                                                     FROM `OrgUnit`
                                                     WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL ) AS cp
                                                   WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`Status`=cp.`TrgStatus`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                (I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgStatus`
                                                             FROM 
                                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                                       I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~) ([OrgUnit*OrgUnit]) */
                                                                    SELECT DISTINCT isect0.`SrcOrgUnit`, isect0.`TrgOrgUnit`
                                                                    FROM ( /* I[OrgUnit] */
                                                                      SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `OrgUnit` AS `TrgOrgUnit`
                                                                      FROM `OrgUnit`
                                                                      WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL ) AS isect0
                                                                    WHERE NOT EXISTS (SELECT * FROM 
                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                          ouMnlStat;ouMnlStat~ */
                                                                                       
                                                                                       SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgOrgUnit`
                                                                                       FROM ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ouMnlStat` AS `TrgStatus`
                                                                                         FROM `OrgUnit`
                                                                                         WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL ) AS ECps0,
                                                                                            
                                                                                            ( /* case: EFlp x. */
                                                                                              SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `ouMnlStat` AS `SrcStatus`
                                                                                              FROM `OrgUnit`
                                                                                              WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL
                                                                                            ) AS ECps1
                                                                                       WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                                                                     ) AS cp
                                                                                WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TrgOrgUnit`=cp.`TrgOrgUnit`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgOrgUnit` IS NOT NULL
                                                                  ) AS ECps0,
                                                                  ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ouCmpStat` AS `TrgStatus`
                                                               FROM `OrgUnit`
                                                               WHERE `OrgUnit` IS NOT NULL AND `ouCmpStat` IS NOT NULL ) AS ECps1
                                                             WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                                                           ) AS cp
                                                      WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`Status`=cp.`TrgStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ouStatus` AS `TrgStatus`
                                        FROM `OrgUnit`
                                        WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouStatus;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                 SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                 FROM `OrgUnit`
                                 WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                 SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultOrgUnitStatus' =>
        array ( 'name'          => 'defaultOrgUnitStatus'
              , 'ruleAdl'       => 'I[OrgUnit] |- ouStatus;ouStatus~'
              , 'origin'        => 'line 111:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(I[OrgUnit] |- ouStatus;ouStatus~)
              // <=> { remove |- }
              //     -(-I[OrgUnit] \\/ ouStatus;ouStatus~)
              // <=> { De Morgan }
              //     I[OrgUnit] /\\ -(ouStatus;ouStatus~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI OrgUnit,ECpl (ECps (EDcD RELATION ouStatus [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can have a status (colour) -},EFlp (EDcD RELATION ouStatus [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can have a status (colour) +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[OrgUnit] /\\ -(ouStatus;ouStatus~) ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS src, isect0.`TrgOrgUnit` AS tgt
                          FROM ( /* I[OrgUnit] */
                            SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `OrgUnit` AS `TrgOrgUnit`
                            FROM `OrgUnit`
                            WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ouStatus;ouStatus~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgOrgUnit`
                                             FROM ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ouStatus` AS `TrgStatus`
                                               FROM `OrgUnit`
                                               WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `ouStatus` AS `SrcStatus`
                                                    FROM `OrgUnit`
                                                    WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TrgOrgUnit`=cp.`TrgOrgUnit`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouStatus;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                 SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                 FROM `OrgUnit`
                                 WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'InsSvcComponentStatus' =>
        array ( 'name'          => 'InsSvcComponentStatus'
              , 'ruleAdl'       => 'scMnlStat \\/ (I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat |- scStatus'
              , 'origin'        => 'line 117:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(scMnlStat \\/ (I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat |- scStatus)
              // <=> { remove |- }
              //     -(-(scMnlStat \\/ (I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat) \\/ scStatus)
              // <=> { De Morgan }
              //     -(-scMnlStat /\\ -((I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat)) /\\ -scStatus
              // 
              // Normalized complement (== violationsSQL): EIsc (ECpl (EIsc (ECpl (EDcD RELATION scMnlStat [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can be assigned a new status -}),ECpl (ECps (EIsc (EDcI SvcComponent,ECpl (ECps (EDcD RELATION scMnlStat [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can be assigned a new status -},EFlp (EDcD RELATION scMnlStat [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can be assigned a new status -})))),EDcD RELATION scCmpStat [SvcComponent*Status] Nothing PRAGMA "" "" "")))),ECpl (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +}))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             -(-scMnlStat /\\ -((I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat)) /\\ -scStatus ([SvcComponent*Status]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \"-scMnlStat /\\ -((I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat)\" ) */
                                 SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`Status` AS `TrgStatus`
                                 FROM `SvcComponent` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\'@(_:_:_))
                                             -scMnlStat /\\ -((I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat) ([SvcComponent*Status]) */
                                          SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TrgStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \"scMnlStat\" ) */
                                                 SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`Status` AS `TrgStatus`
                                                 FROM `SvcComponent` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scMnlStat` AS `TrgStatus`
                                                     FROM `SvcComponent`
                                                     WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL ) AS cp
                                                   WHERE cfst.`SvcComponent`=cp.`SrcSvcComponent` AND csnd.`Status`=cp.`TrgStatus`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                (I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgStatus`
                                                             FROM 
                                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                                       I[SvcComponent] /\\ -(scMnlStat;scMnlStat~) ([SvcComponent*SvcComponent]) */
                                                                    SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TrgSvcComponent`
                                                                    FROM ( /* I[SvcComponent] */
                                                                      SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                                                                      FROM `SvcComponent`
                                                                      WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect0
                                                                    WHERE NOT EXISTS (SELECT * FROM 
                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                          scMnlStat;scMnlStat~ */
                                                                                       
                                                                                       SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                                                                       FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scMnlStat` AS `TrgStatus`
                                                                                         FROM `SvcComponent`
                                                                                         WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL ) AS ECps0,
                                                                                            
                                                                                            ( /* case: EFlp x. */
                                                                                              SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scMnlStat` AS `SrcStatus`
                                                                                              FROM `SvcComponent`
                                                                                              WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL
                                                                                            ) AS ECps1
                                                                                       WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                                                                     ) AS cp
                                                                                WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL
                                                                  ) AS ECps0,
                                                                  ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scCmpStat` AS `TrgStatus`
                                                               FROM `SvcComponent`
                                                               WHERE `SvcComponent` IS NOT NULL AND `scCmpStat` IS NOT NULL ) AS ECps1
                                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                           ) AS cp
                                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`SvcComponent`=cp.`SrcSvcComponent` AND csnd.`Status`=cp.`TrgStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scStatus` AS `TrgStatus`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                 SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultSvcComponentStatus' =>
        array ( 'name'          => 'defaultSvcComponentStatus'
              , 'ruleAdl'       => 'I[SvcComponent] |- scStatus;scStatus~'
              , 'origin'        => 'line 120:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] |- scStatus;scStatus~)
              // <=> { remove |- }
              //     -(-I[SvcComponent] \\/ scStatus;scStatus~)
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ -(scStatus;scStatus~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,ECpl (ECps (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) -},EFlp (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ -(scStatus;scStatus~) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scStatus;scStatus~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scStatus` AS `TrgStatus`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scStatus` AS `SrcStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'InsComputerStatus' =>
        array ( 'name'          => 'InsComputerStatus'
              , 'ruleAdl'       => 'compMnlStat \\/ (I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat |- compStatus'
              , 'origin'        => 'line 126:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(compMnlStat \\/ (I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat |- compStatus)
              // <=> { remove |- }
              //     -(-(compMnlStat \\/ (I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat) \\/ compStatus)
              // <=> { De Morgan }
              //     -(-compMnlStat /\\ -((I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat)) /\\ -compStatus
              // 
              // Normalized complement (== violationsSQL): EIsc (ECpl (EIsc (ECpl (EDcD RELATION compMnlStat [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can be assigned a new status -}),ECpl (ECps (EIsc (EDcI Computer,ECpl (ECps (EDcD RELATION compMnlStat [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can be assigned a new status -},EFlp (EDcD RELATION compMnlStat [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can be assigned a new status -})))),EDcD RELATION compCmpStat [Computer*Status] Nothing PRAGMA "" "" "")))),ECpl (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             -(-compMnlStat /\\ -((I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat)) /\\ -compStatus ([Computer*Status]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \"-compMnlStat /\\ -((I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat)\" ) */
                                 SELECT DISTINCT cfst.`Computer` AS `SrcComputer`, csnd.`Status` AS `TrgStatus`
                                 FROM `Computer` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\'@(_:_:_))
                                             -compMnlStat /\\ -((I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat) ([Computer*Status]) */
                                          SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \"compMnlStat\" ) */
                                                 SELECT DISTINCT cfst.`Computer` AS `SrcComputer`, csnd.`Status` AS `TrgStatus`
                                                 FROM `Computer` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compMnlStat` AS `TrgStatus`
                                                     FROM `Computer`
                                                     WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL ) AS cp
                                                   WHERE cfst.`Computer`=cp.`SrcComputer` AND csnd.`Status`=cp.`TrgStatus`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                (I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgStatus`
                                                             FROM 
                                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                                       I[Computer] /\\ -(compMnlStat;compMnlStat~) ([Computer*Computer]) */
                                                                    SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                                                    FROM ( /* I[Computer] */
                                                                      SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                                                                      FROM `Computer`
                                                                      WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect0
                                                                    WHERE NOT EXISTS (SELECT * FROM 
                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                          compMnlStat;compMnlStat~ */
                                                                                       
                                                                                       SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                                                                       FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compMnlStat` AS `TrgStatus`
                                                                                         FROM `Computer`
                                                                                         WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL ) AS ECps0,
                                                                                            
                                                                                            ( /* case: EFlp x. */
                                                                                              SELECT DISTINCT `Computer` AS `TrgComputer`, `compMnlStat` AS `SrcStatus`
                                                                                              FROM `Computer`
                                                                                              WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL
                                                                                            ) AS ECps1
                                                                                       WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                                                                     ) AS cp
                                                                                WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                                                  ) AS ECps0,
                                                                  ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compCmpStat` AS `TrgStatus`
                                                               FROM `Computer`
                                                               WHERE `Computer` IS NOT NULL AND `compCmpStat` IS NOT NULL ) AS ECps1
                                                             WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                           ) AS cp
                                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Computer`=cp.`SrcComputer` AND csnd.`Status`=cp.`TrgStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compStatus` AS `TrgStatus`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgStatus`=cp.`TrgStatus`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                 SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultComputerStatus' =>
        array ( 'name'          => 'defaultComputerStatus'
              , 'ruleAdl'       => 'I[Computer] |- compStatus;compStatus~'
              , 'origin'        => 'line 129:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] |- compStatus;compStatus~)
              // <=> { remove |- }
              //     -(-I[Computer] \\/ compStatus;compStatus~)
              // <=> { De Morgan }
              //     I[Computer] /\\ -(compStatus;compStatus~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,ECpl (ECps (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) -},EFlp (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ -(compStatus;compStatus~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compStatus;compStatus~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compStatus` AS `TrgStatus`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `compStatus` AS `SrcStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'Create path within network' =>
        array ( 'name'          => 'Create path within network'
              , 'ruleAdl'       => 'routerNeedsPathTo /\\ (routerNW;routerNW~ /\\ -I[Router]) |- rrtStar'
              , 'origin'        => 'line 10:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNeedsPathTo /\\ (routerNW;routerNW~ /\\ -I[Router]) |- rrtStar)
              // <=> { remove |- }
              //     -(-(routerNeedsPathTo /\\ (routerNW;routerNW~ /\\ -I[Router])) \\/ rrtStar)
              // <=> { De Morgan }
              //     routerNeedsPathTo /\\ (routerNW;routerNW~ /\\ (-I[Router] /\\ -rrtStar))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" "",EIsc (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")),EIsc (ECpl (EDcI Router),ECpl (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerNeedsPathTo /\\ (routerNW;routerNW~ /\\ (-I[Router] /\\ -rrtStar)) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                            FROM `routerNeedsPathTo`
                            WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW;routerNW~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect1
                          WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TrgRouter` = isect1.`TrgRouter`) AND isect0.`SrcRouter` <> isect0.`TrgRouter` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                        FROM `rrtStar`
                                        WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;rrtDirect;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Remove routes from non-network routers' =>
        array ( 'name'          => 'Remove routes from non-network routers'
              , 'ruleAdl'       => 'rrtDirect |- routerNW;((I[Network] \\/ -I[Network]);routerNW~)'
              , 'origin'        => 'line 15:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(rrtDirect |- routerNW;((I[Network] \\/ -I[Network]);routerNW~))
              // <=> { remove |- }
              //     -(-rrtDirect \\/ routerNW;((I[Network] \\/ -I[Network]);routerNW~))
              // <=> { De Morgan }
              //     rrtDirect /\\ -(routerNW;((I[Network] \\/ -I[Network]);routerNW~))
              // <=> { distribute ; over \\/ }
              //     rrtDirect /\\ -(routerNW;(I[Network];routerNW~ \\/ -I[Network];routerNW~))
              // <=> { distribute ; over \\/ }
              //     rrtDirect /\\ -(routerNW;(I[Network];routerNW~) \\/ routerNW;(-I[Network];routerNW~))
              // <=> { De Morgan }
              //     rrtDirect /\\ (-(routerNW;(I[Network];routerNW~)) /\\ -(routerNW;(-I[Network];routerNW~)))
              // <=> { I;x = x }
              //     rrtDirect /\\ (-(routerNW;routerNW~) /\\ -(routerNW;(-I[Network];routerNW~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" "",EIsc (ECpl (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))),ECpl (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",ECps (ECpl (EDcI Network),EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             rrtDirect /\\ (-(routerNW;routerNW~) /\\ -(routerNW;(-I[Network];routerNW~))) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                            FROM `rrtDirect`
                            WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerNW;routerNW~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerNW;(-I[Network];routerNW~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps2.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"I[Network]\" ) */
                                                    SELECT DISTINCT cfst.`Network` AS `SrcNetwork`, csnd.`Network` AS `TrgNetwork`
                                                    FROM `Network` AS cfst,
                                                         `Network` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM ( /* I[Network] */
                                                        SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                                                        FROM `Network`
                                                        WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS cp
                                                      WHERE cfst.`Network`=cp.`SrcNetwork` AND csnd.`Network`=cp.`TrgNetwork`)
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                               AND ECps1.`TrgNetwork`=ECps2.`SrcNetwork`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerRoutesTo;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Remove computers from non-network routers' =>
        array ( 'name'          => 'Remove computers from non-network routers'
              , 'ruleAdl'       => 'compRouter |- compRouter;(I[Router] /\\ routerNW;routerNW~)'
              , 'origin'        => 'line 21:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(compRouter |- compRouter;(I[Router] /\\ routerNW;routerNW~))
              // <=> { remove |- }
              //     -(-compRouter \\/ compRouter;(I[Router] /\\ routerNW;routerNW~))
              // <=> { De Morgan }
              //     compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EIsc (EDcI Router,ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)) ([Computer*Router]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                            FROM `compRouter`
                            WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compRouter;(I[Router] /\\ routerNW;routerNW~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                               FROM `compRouter`
                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                       I[Router] /\\ routerNW;routerNW~ ([Router*Router]) */
                                                    SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              routerNW;routerNW~ */
                                                           
                                                           SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                           FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                             FROM `Router`
                                                             WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                                         ) AS isect0, ( /* I[Router] */
                                                      SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                      FROM `Router`
                                                      WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                    WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compRouter;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InsnwAllCompCommReqsSatisfied' =>
        array ( 'name'          => 'InsnwAllCompCommReqsSatisfied'
              , 'ruleAdl'       => 'I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW) |- nwAllCompCommReqsSatisfied'
              , 'origin'        => 'line 29:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW) |- nwAllCompCommReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW)) \\/ nwAllCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Network] /\\ (-routerNW~!(routerAllCommReqsSatisfied;routerNW) /\\ -nwAllCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Network] /\\ (-(routerNW~;-(routerAllCommReqsSatisfied;routerNW)) /\\ -nwAllCompCommReqsSatisfied)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Network,EIsc (ECpl (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),ECpl (ECps (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")))),ECpl (EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Network] /\\ (-(routerNW~;-(routerAllCommReqsSatisfied;routerNW)) /\\ -nwAllCompCommReqsSatisfied) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM ( /* I[Network] */
                            SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerNW~;-(routerAllCommReqsSatisfied;routerNW) */
                                             
                                             SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"routerAllCommReqsSatisfied;routerNW\" ) */
                                                    SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Network` AS `TrgNetwork`
                                                    FROM `Router` AS cfst,
                                                         `Network` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                routerAllCommReqsSatisfied;routerNW */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgNetwork`
                                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                                                               FROM `Router`
                                                               WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                                                  ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                               FROM `Router`
                                                               WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps1
                                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                           ) AS cp
                                                      WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Network`=cp.`TrgNetwork`)
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                                        FROM `Network`
                                        WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwAllCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'DelnwAllCompCommReqsSatisfied' =>
        array ( 'name'          => 'DelnwAllCompCommReqsSatisfied'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied |- I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW)'
              , 'origin'        => 'line 32:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied |- I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW))
              // <=> { remove |- }
              //     -(-nwAllCompCommReqsSatisfied \\/ (I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW)))
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied /\\ -(I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW))
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied /\\ -(I[Network] /\\ -(routerNW~;-(routerAllCommReqsSatisfied;routerNW)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Network,ECpl (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),ECpl (ECps (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwAllCompCommReqsSatisfied /\\ -(I[Network] /\\ -(routerNW~;-(routerAllCommReqsSatisfied;routerNW))) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Network] /\\ -(routerNW~;-(routerAllCommReqsSatisfied;routerNW)) ([Network*Network]) */
                                             SELECT DISTINCT isect0.`SrcNetwork`, isect0.`TrgNetwork`
                                             FROM ( /* I[Network] */
                                               SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                                               FROM `Network`
                                               WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect0
                                             WHERE NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   routerNW~;-(routerAllCommReqsSatisfied;routerNW) */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                                                FROM 
                                                                     ( /* case: EFlp x. */
                                                                       SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                       FROM `Router`
                                                                       WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                     ) AS ECps0,
                                                                     
                                                                     ( /* case: ECpl e
                                                                          ECpl ( \"routerAllCommReqsSatisfied;routerNW\" ) */
                                                                       SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Network` AS `TrgNetwork`
                                                                       FROM `Router` AS cfst,
                                                                            `Network` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM 
                                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                                   routerAllCommReqsSatisfied;routerNW */
                                                                                
                                                                                SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgNetwork`
                                                                                FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                                                                                  FROM `Router`
                                                                                  WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                                                                     ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                                                  FROM `Router`
                                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps1
                                                                                WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                                              ) AS cp
                                                                         WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Network`=cp.`TrgNetwork`)
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                              ) AS cp
                                                         WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;nwAllCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'InsnwNoCompCommReqsSatisfied' =>
        array ( 'name'          => 'InsnwNoCompCommReqsSatisfied'
              , 'ruleAdl'       => 'I[Network] /\\ -(routerNW~;(-routerNoCommReqsSatisfied;routerNW)) |- nwNoCompCommReqsSatisfied'
              , 'origin'        => 'line 37:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ -(routerNW~;(-routerNoCommReqsSatisfied;routerNW)) |- nwNoCompCommReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Network] /\\ -(routerNW~;(-routerNoCommReqsSatisfied;routerNW))) \\/ nwNoCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Network] /\\ (-(routerNW~;(-routerNoCommReqsSatisfied;routerNW)) /\\ -nwNoCompCommReqsSatisfied)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Network,EIsc (ECpl (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),ECps (ECpl (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" ""),EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))),ECpl (EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Network] /\\ (-(routerNW~;(-routerNoCommReqsSatisfied;routerNW)) /\\ -nwNoCompCommReqsSatisfied) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM ( /* I[Network] */
                            SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerNW~;(-routerNoCommReqsSatisfied;routerNW) */
                                             
                                             SELECT DISTINCT ECps0.`SrcNetwork`, ECps2.`TrgNetwork`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"routerNoCommReqsSatisfied\" ) */
                                                    SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Router` AS `TrgRouter`
                                                    FROM `Router` AS cfst,
                                                         `Router` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                                                        FROM `Router`
                                                        WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS cp
                                                      WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Router`=cp.`TrgRouter`)
                                                  ) AS ECps1,
                                                  ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps2
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                               AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                                        FROM `Network`
                                        WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwNoCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'DelnwNoCompCommReqsSatisfied' =>
        array ( 'name'          => 'DelnwNoCompCommReqsSatisfied'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied |- I[Network] /\\ -(routerNW~;(-routerNoCommReqsSatisfied;routerNW))'
              , 'origin'        => 'line 40:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied |- I[Network] /\\ -(routerNW~;(-routerNoCommReqsSatisfied;routerNW)))
              // <=> { remove |- }
              //     -(-nwNoCompCommReqsSatisfied \\/ (I[Network] /\\ -(routerNW~;(-routerNoCommReqsSatisfied;routerNW))))
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied /\\ -(I[Network] /\\ -(routerNW~;(-routerNoCommReqsSatisfied;routerNW)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Network,ECpl (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),ECps (ECpl (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" ""),EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwNoCompCommReqsSatisfied /\\ -(I[Network] /\\ -(routerNW~;(-routerNoCommReqsSatisfied;routerNW))) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Network] /\\ -(routerNW~;(-routerNoCommReqsSatisfied;routerNW)) ([Network*Network]) */
                                             SELECT DISTINCT isect0.`SrcNetwork`, isect0.`TrgNetwork`
                                             FROM ( /* I[Network] */
                                               SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                                               FROM `Network`
                                               WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect0
                                             WHERE NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   routerNW~;(-routerNoCommReqsSatisfied;routerNW) */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcNetwork`, ECps2.`TrgNetwork`
                                                                FROM 
                                                                     ( /* case: EFlp x. */
                                                                       SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                       FROM `Router`
                                                                       WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                     ) AS ECps0,
                                                                     
                                                                     ( /* case: ECpl e
                                                                          ECpl ( \"routerNoCommReqsSatisfied\" ) */
                                                                       SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Router` AS `TrgRouter`
                                                                       FROM `Router` AS cfst,
                                                                            `Router` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                                                                           FROM `Router`
                                                                           WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS cp
                                                                         WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Router`=cp.`TrgRouter`)
                                                                     ) AS ECps1,
                                                                     ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps2
                                                                WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                                  AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                              ) AS cp
                                                         WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;nwNoCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'rrtCompTransitiveClosure' =>
        array ( 'name'          => 'rrtCompTransitiveClosure'
              , 'ruleAdl'       => 'routerRoutesTo = rrtDirect'
              , 'origin'        => 'line 50:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerRoutesTo = rrtDirect)
              // <=> { remove = }
              //     -((routerRoutesTo |- rrtDirect) /\\ (rrtDirect |- routerRoutesTo))
              // <=> { remove |- and remove |- }
              //     -((-routerRoutesTo \\/ rrtDirect) /\\ (-rrtDirect \\/ routerRoutesTo))
              // 
              // Normalized complement (== violationsSQL): ECpl (EIsc (EUni (ECpl (EDcD RELATION routerRoutesTo [Router*Router] Nothing PRAGMA "" "" ""),EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" ""),EUni (ECpl (EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" ""),EDcD RELATION routerRoutesTo [Router*Router] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: ECpl e
                             ECpl ( \"(-routerRoutesTo \\/ rrtDirect) /\\ (-rrtDirect \\/ routerRoutesTo)\" ) */
                          SELECT DISTINCT cfst.`Router` AS src, csnd.`Router` AS tgt
                          FROM `Router` AS cfst,
                               `Router` AS csnd
                          WHERE NOT EXISTS
                           (SELECT * FROM 
                                 ( /* case: (EIsc lst\'@(_:_:_))
                                      (-routerRoutesTo \\/ rrtDirect) /\\ (-rrtDirect \\/ routerRoutesTo) ([Router*Router]) */
                                   SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                   FROM 
                                        ( /* case: EUni (l,r)
                                             -routerRoutesTo \\/ rrtDirect ([Router*Router]) */
                                          (/* case: ECpl e
                                                 ECpl ( \"routerRoutesTo\" ) */
                                              SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Router` AS `TrgRouter`
                                              FROM `Router` AS cfst,
                                                   `Router` AS csnd
                                              WHERE NOT EXISTS
                                               (SELECT * FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                  FROM `routerRoutesTo`
                                                  WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS cp
                                                WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Router`=cp.`TrgRouter`)
                                          ) UNION (SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                              FROM `rrtDirect`
                                              WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                          )
                                        ) AS isect0, 
                                        ( /* case: EUni (l,r)
                                             -rrtDirect \\/ routerRoutesTo ([Router*Router]) */
                                          (/* case: ECpl e
                                                 ECpl ( \"rrtDirect\" ) */
                                              SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Router` AS `TrgRouter`
                                              FROM `Router` AS cfst,
                                                   `Router` AS csnd
                                              WHERE NOT EXISTS
                                               (SELECT * FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                  FROM `rrtDirect`
                                                  WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS cp
                                                WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Router`=cp.`TrgRouter`)
                                          ) UNION (SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                              FROM `routerRoutesTo`
                                              WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                          )
                                        ) AS isect1
                                   WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TrgRouter` = isect1.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                 ) AS cp
                            WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Router`=cp.`TrgRouter`)'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} TransitiveClosure;routerRoutesTo;Router;rrtDirect;rrtStar')
                    )
              )
    , 'rrtStar Transitive closure integrity' =>
        array ( 'name'          => 'rrtStar Transitive closure integrity'
              , 'ruleAdl'       => 'rrtStar;rrtStar |- rrtStar'
              , 'origin'        => 'line 55:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(rrtStar;rrtStar |- rrtStar)
              // <=> { remove |- }
              //     -(-(rrtStar;rrtStar) \\/ rrtStar)
              // <=> { De Morgan }
              //     rrtStar;rrtStar /\\ -rrtStar
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" "",EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" ""),ECpl (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" ""))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             rrtStar;rrtStar /\\ -rrtStar ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    rrtStar;rrtStar */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                   FROM `rrtStar`
                                   WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                   FROM `rrtStar`
                                   WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                        FROM `rrtStar`
                                        WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'InsrouterNeedsPathTo' =>
        array ( 'name'          => 'InsrouterNeedsPathTo'
              , 'ruleAdl'       => 'compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ -I[Router] |- routerNeedsPathTo'
              , 'origin'        => 'line 61:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ -I[Router] |- routerNeedsPathTo)
              // <=> { remove |- }
              //     -(-(compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ -I[Router]) \\/ routerNeedsPathTo)
              // <=> { De Morgan }
              //     compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ (-I[Router] /\\ -routerNeedsPathTo)
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""),ECps (EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))))),EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")),EIsc (ECpl (EDcI Router),ECpl (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ (-I[Router] /\\ -routerNeedsPathTo) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps2.`TrgRouter`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps0,
                                      
                                      ( /* case: (EIsc lst\'@(_:_:_))
                                           compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)) ([Computer*Computer]) */
                                        SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                        FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                          FROM `compReqCommWith`
                                          WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              compRouter;(rrtStar;compRouter~) */
                                                           
                                                           SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                                           FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                             FROM `compRouter`
                                                             WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                                ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                             FROM `rrtStar`
                                                             WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                                  FROM `compRouter`
                                                                  WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                ) AS ECps2
                                                           WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                             AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                         ) AS cp
                                                    WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                      ) AS ECps1,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                   FROM `compRouter`
                                   WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps2
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                   AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TrgRouter` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                        FROM `routerNeedsPathTo`
                                        WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerNeedsPathTo;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'DelrouterNeedsPathTo' =>
        array ( 'name'          => 'DelrouterNeedsPathTo'
              , 'ruleAdl'       => 'routerNeedsPathTo |- compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ -I[Router]'
              , 'origin'        => 'line 65:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNeedsPathTo |- compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ -I[Router])
              // <=> { remove |- }
              //     -(-routerNeedsPathTo \\/ (compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ -I[Router]))
              // <=> { De Morgan }
              //     routerNeedsPathTo /\\ -(compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ -I[Router])
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" "",ECpl (EIsc (ECps (EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""),ECps (EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))))),EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")),ECpl (EDcI Router))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerNeedsPathTo /\\ -(compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ -I[Router]) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                            FROM `routerNeedsPathTo`
                            WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) /\\ -I[Router] ([Router*Router]) */
                                             SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       compRouter~;((compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)));compRouter) */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcRouter`, ECps2.`TrgRouter`
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                           FROM `compRouter`
                                                           WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                         ) AS ECps0,
                                                         
                                                         ( /* case: (EIsc lst\'@(_:_:_))
                                                              compReqCommWith /\\ -(compRouter;(rrtStar;compRouter~)) ([Computer*Computer]) */
                                                           SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                                           FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                             FROM `compReqCommWith`
                                                             WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                                                           WHERE NOT EXISTS (SELECT * FROM 
                                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                                 compRouter;(rrtStar;compRouter~) */
                                                                              
                                                                              SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                                                              FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                                                FROM `compRouter`
                                                                                WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                                                   ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                                                FROM `rrtStar`
                                                                                WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1,
                                                                                   
                                                                                   ( /* case: EFlp x. */
                                                                                     SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                                                     FROM `compRouter`
                                                                                     WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                                   ) AS ECps2
                                                                              WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                                                AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                                            ) AS cp
                                                                       WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                                         ) AS ECps1,
                                                         ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                      FROM `compRouter`
                                                      WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps2
                                                    WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                      AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                                                  ) AS isect0
                                             WHERE isect0.`SrcRouter` <> isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerNeedsPathTo;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InsrouterAllCommReqsSatisfied' =>
        array ( 'name'          => 'InsrouterAllCommReqsSatisfied'
              , 'ruleAdl'       => 'I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~) |- routerAllCommReqsSatisfied'
              , 'origin'        => 'line 70:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~) |- routerAllCommReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~)) \\/ routerAllCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Router] /\\ (-(routerNeedsPathTo;routerNeedsPathTo~) /\\ -routerAllCommReqsSatisfied)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Router,EIsc (ECpl (ECps (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" ""))),ECpl (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Router] /\\ (-(routerNeedsPathTo;routerNeedsPathTo~) /\\ -routerAllCommReqsSatisfied) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( /* I[Router] */
                            SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerNeedsPathTo;routerNeedsPathTo~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                             FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                               FROM `routerNeedsPathTo`
                                               WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `sRouter` AS `TrgRouter`, `tRouter` AS `SrcRouter`
                                                    FROM `routerNeedsPathTo`
                                                    WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerAllCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'DelrouterAllCommReqsSatisfied' =>
        array ( 'name'          => 'DelrouterAllCommReqsSatisfied'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied |- I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~)'
              , 'origin'        => 'line 73:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied |- I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~))
              // <=> { remove |- }
              //     -(-routerAllCommReqsSatisfied \\/ (I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~)))
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied /\\ -(I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Router,ECpl (ECps (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerAllCommReqsSatisfied /\\ -(I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~)) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~) ([Router*Router]) */
                                             SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                             FROM ( /* I[Router] */
                                               SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                                             WHERE NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   routerNeedsPathTo;routerNeedsPathTo~ */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                                FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                                  FROM `routerNeedsPathTo`
                                                                  WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps0,
                                                                     
                                                                     ( /* case: EFlp x. */
                                                                       SELECT DISTINCT `sRouter` AS `TrgRouter`, `tRouter` AS `SrcRouter`
                                                                       FROM `routerNeedsPathTo`
                                                                       WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                              ) AS cp
                                                         WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerAllCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InsrouterNoCommReqsSatisfied' =>
        array ( 'name'          => 'InsrouterNoCommReqsSatisfied'
              , 'ruleAdl'       => 'I[Router] /\\ compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter) |- routerNoCommReqsSatisfied'
              , 'origin'        => 'line 78:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter) |- routerNoCommReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter)) \\/ routerNoCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Router] /\\ (compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter) /\\ -routerNoCommReqsSatisfied)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Router,EIsc (ECps (EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""),ECps (EIsc (EDcI Computer,EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" ""))),EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")),ECpl (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Router] /\\ (compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter) /\\ -routerNoCommReqsSatisfied) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter) */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps2.`TrgRouter`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps0,
                                      
                                      ( /* case: (EIsc lst\'@(_:_:_))
                                           I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith) ([Computer*Computer]) */
                                        SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                        FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                          FROM `compReqCommWith`
                                          WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0, ( /* I[Computer] */
                                          SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                                          FROM `Computer`
                                          WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                                        WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                      FROM `compHasCommWith`
                                                      WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                                    WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                      ) AS ECps1,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                   FROM `compRouter`
                                   WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps2
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                   AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                               ) AS isect0, ( /* I[Router] */
                            SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerNoCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'DelrouterNoCommReqsSatisfied' =>
        array ( 'name'          => 'DelrouterNoCommReqsSatisfied'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied |- I[Router] /\\ compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter)'
              , 'origin'        => 'line 81:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied |- I[Router] /\\ compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter))
              // <=> { remove |- }
              //     -(-routerNoCommReqsSatisfied \\/ (I[Router] /\\ compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter)))
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied /\\ -(I[Router] /\\ compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Router,ECps (EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""),ECps (EIsc (EDcI Computer,EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" ""))),EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerNoCommReqsSatisfied /\\ -(I[Router] /\\ compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter)) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Router] /\\ compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter) ([Router*Router]) */
                                             SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       compRouter~;((I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith));compRouter) */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcRouter`, ECps2.`TrgRouter`
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                           FROM `compRouter`
                                                           WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                         ) AS ECps0,
                                                         
                                                         ( /* case: (EIsc lst\'@(_:_:_))
                                                              I[Computer] /\\ (compReqCommWith /\\ -compHasCommWith) ([Computer*Computer]) */
                                                           SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                                           FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                             FROM `compReqCommWith`
                                                             WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0, ( /* I[Computer] */
                                                             SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                                                             FROM `Computer`
                                                             WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                                                           WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                         FROM `compHasCommWith`
                                                                         WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                                                       WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                                         ) AS ECps1,
                                                         ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                      FROM `compRouter`
                                                      WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps2
                                                    WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                      AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                                                  ) AS isect0, ( /* I[Router] */
                                               SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                             WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerNoCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InscompReqCommWith' =>
        array ( 'name'          => 'InscompReqCommWith'
              , 'ruleAdl'       => 'scDeployedOn~;(scReqCommWith;scDeployedOn) |- compReqCommWith'
              , 'origin'        => 'line 88:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(scDeployedOn~;(scReqCommWith;scDeployedOn) |- compReqCommWith)
              // <=> { remove |- }
              //     -(-(scDeployedOn~;(scReqCommWith;scDeployedOn)) \\/ compReqCommWith)
              // <=> { De Morgan }
              //     scDeployedOn~;(scReqCommWith;scDeployedOn) /\\ -compReqCommWith
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -}),ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +})),ECpl (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" ""))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scDeployedOn~;(scReqCommWith;scDeployedOn) /\\ -compReqCommWith ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scDeployedOn~;(scReqCommWith;scDeployedOn) */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                   FROM `scReqCommWith`
                                   WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps1,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                   FROM `scDeployedOn`
                                   WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps2
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                   AND ECps1.`TrgSvcComponent`=ECps2.`SrcSvcComponent`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                        FROM `compReqCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compReqCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelcompReqCommWith' =>
        array ( 'name'          => 'DelcompReqCommWith'
              , 'ruleAdl'       => 'compReqCommWith |- scDeployedOn~;(scReqCommWith;scDeployedOn)'
              , 'origin'        => 'line 91:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compReqCommWith |- scDeployedOn~;(scReqCommWith;scDeployedOn))
              // <=> { remove |- }
              //     -(-compReqCommWith \\/ scDeployedOn~;(scReqCommWith;scDeployedOn))
              // <=> { De Morgan }
              //     compReqCommWith /\\ -(scDeployedOn~;(scReqCommWith;scDeployedOn))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (ECps (EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -}),ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compReqCommWith /\\ -(scDeployedOn~;(scReqCommWith;scDeployedOn)) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                            FROM `compReqCommWith`
                            WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scDeployedOn~;(scReqCommWith;scDeployedOn) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps0,
                                                  ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                               FROM `scReqCommWith`
                                               WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps1,
                                                  ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                               FROM `scDeployedOn`
                                               WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps2
                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                               AND ECps1.`TrgSvcComponent`=ECps2.`SrcSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compReqCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompHasCommWith' =>
        array ( 'name'          => 'InscompHasCommWith'
              , 'ruleAdl'       => 'compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ -I[Computer]) |- compHasCommWith'
              , 'origin'        => 'line 96:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ -I[Computer]) |- compHasCommWith)
              // <=> { remove |- }
              //     -(-(compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ -I[Computer])) \\/ compHasCommWith)
              // <=> { De Morgan }
              //     compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ (-I[Computer] /\\ -compHasCommWith))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EIsc (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))),EIsc (ECpl (EDcI Computer),ECpl (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ (-I[Computer] /\\ -compHasCommWith)) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                            FROM `compReqCommWith`
                            WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter;(rrtStar;compRouter~) */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                   FROM `compRouter`
                                   WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                   FROM `rrtStar`
                                   WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps2
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                   AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                               ) AS isect1
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TrgComputer` = isect1.`TrgComputer`) AND isect0.`SrcComputer` <> isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                        FROM `compHasCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compHasCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelcompHasCommWith' =>
        array ( 'name'          => 'DelcompHasCommWith'
              , 'ruleAdl'       => 'compHasCommWith |- compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ -I[Computer])'
              , 'origin'        => 'line 99:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compHasCommWith |- compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ -I[Computer]))
              // <=> { remove |- }
              //     -(-compHasCommWith \\/ (compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ -I[Computer])))
              // <=> { De Morgan }
              //     compHasCommWith /\\ -(compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ -I[Computer]))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EIsc (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))),ECpl (EDcI Computer)))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compHasCommWith /\\ -(compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ -I[Computer])) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                            FROM `compHasCommWith`
                            WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                compReqCommWith /\\ (compRouter;(rrtStar;compRouter~) /\\ -I[Computer]) ([Computer*Computer]) */
                                             SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                             FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                               FROM `compReqCommWith`
                                               WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0, 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       compRouter;(rrtStar;compRouter~) */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                                    FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                      FROM `compRouter`
                                                      WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                         ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                      FROM `rrtStar`
                                                      WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                           FROM `compRouter`
                                                           WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                         ) AS ECps2
                                                    WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                      AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                  ) AS isect1
                                             WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TrgComputer` = isect1.`TrgComputer`) AND isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compHasCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompRequiresComm' =>
        array ( 'name'          => 'InscompRequiresComm'
              , 'ruleAdl'       => 'I[Computer] /\\ compReqCommWith;compReqCommWith~ |- compRequiresComm'
              , 'origin'        => 'line 104:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compReqCommWith;compReqCommWith~ |- compRequiresComm)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compReqCommWith;compReqCommWith~) \\/ compRequiresComm)
              // <=> { De Morgan }
              //     I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -compRequiresComm)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (ECps (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "")),ECpl (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -compRequiresComm) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compReqCommWith;compReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                   FROM `compReqCommWith`
                                   WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sComputer` AS `TrgComputer`, `tComputer` AS `SrcComputer`
                                        FROM `compReqCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0, ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compRequiresComm;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelcompRequiresComm' =>
        array ( 'name'          => 'DelcompRequiresComm'
              , 'ruleAdl'       => 'compRequiresComm |- I[Computer] /\\ compReqCommWith;compReqCommWith~'
              , 'origin'        => 'line 107:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm |- I[Computer] /\\ compReqCommWith;compReqCommWith~)
              // <=> { remove |- }
              //     -(-compRequiresComm \\/ (I[Computer] /\\ compReqCommWith;compReqCommWith~))
              // <=> { De Morgan }
              //     compRequiresComm /\\ -(I[Computer] /\\ compReqCommWith;compReqCommWith~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Computer,ECps (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "")))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compRequiresComm /\\ -(I[Computer] /\\ compReqCommWith;compReqCommWith~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Computer] /\\ compReqCommWith;compReqCommWith~ ([Computer*Computer]) */
                                             SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       compReqCommWith;compReqCommWith~ */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                                    FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                      FROM `compReqCommWith`
                                                      WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `sComputer` AS `TrgComputer`, `tComputer` AS `SrcComputer`
                                                           FROM `compReqCommWith`
                                                           WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                                         ) AS ECps1
                                                    WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                  ) AS isect0, ( /* I[Computer] */
                                               SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                                             WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compRequiresComm;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompAllReqCommSatisfied' =>
        array ( 'name'          => 'InscompAllReqCommSatisfied'
              , 'ruleAdl'       => 'I[Computer] /\\ -compReqCommWith!(compRouter;(rrtStar;compRouter~))~ |- compAllReqCommSatisfied'
              , 'origin'        => 'line 112:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ -compReqCommWith!(compRouter;(rrtStar;compRouter~))~ |- compAllReqCommSatisfied)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ -compReqCommWith!(compRouter;(rrtStar;compRouter~))~) \\/ compAllReqCommSatisfied)
              // <=> { De Morgan }
              //     I[Computer] /\\ (-compReqCommWith!(compRouter;(rrtStar;compRouter~))~ /\\ -compAllReqCommSatisfied)
              // <=> { De Morgan }
              //     I[Computer] /\\ (-(compReqCommWith;-(compRouter;(rrtStar;compRouter~))~) /\\ -compAllReqCommSatisfied)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (ECpl (ECps (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EFlp (EBrk (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")))))))),ECpl (EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (-(compReqCommWith;-(compRouter;(rrtStar;compRouter~))~) /\\ -compAllReqCommSatisfied) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compReqCommWith;-(compRouter;(rrtStar;compRouter~))~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                             FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                               FROM `compReqCommWith`
                                               WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"(compRouter;(rrtStar;compRouter~))~\" ) */
                                                    SELECT DISTINCT cfst.`Computer` AS `SrcComputer`, csnd.`Computer` AS `TrgComputer`
                                                    FROM `Computer` AS cfst,
                                                         `Computer` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: EFlp x. */
                                                             /* case: (ECps es), with two or more elements in es.
                                                                compRouter;(rrtStar;compRouter~) */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcComputer` AS `TrgComputer`, ECps2.`TrgComputer` AS `SrcComputer`
                                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                               FROM `compRouter`
                                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                                  ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                               FROM `rrtStar`
                                                               WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1,
                                                                  
                                                                  ( /* case: EFlp x. */
                                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                                    FROM `compRouter`
                                                                    WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                  ) AS ECps2
                                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                               AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                           ) AS cp
                                                      WHERE cfst.`Computer`=cp.`SrcComputer` AND csnd.`Computer`=cp.`TrgComputer`)
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compAllReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelCompAllReqCommSatisfied' =>
        array ( 'name'          => 'DelCompAllReqCommSatisfied'
              , 'ruleAdl'       => 'compAllReqCommSatisfied |- I[Computer] /\\ -compReqCommWith!(compRouter;(rrtStar;compRouter~))~'
              , 'origin'        => 'line 115:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied |- I[Computer] /\\ -compReqCommWith!(compRouter;(rrtStar;compRouter~))~)
              // <=> { remove |- }
              //     -(-compAllReqCommSatisfied \\/ (I[Computer] /\\ -compReqCommWith!(compRouter;(rrtStar;compRouter~))~))
              // <=> { De Morgan }
              //     compAllReqCommSatisfied /\\ -(I[Computer] /\\ -compReqCommWith!(compRouter;(rrtStar;compRouter~))~)
              // <=> { De Morgan }
              //     compAllReqCommSatisfied /\\ -(I[Computer] /\\ -(compReqCommWith;-(compRouter;(rrtStar;compRouter~))~))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Computer,ECpl (ECps (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EFlp (EBrk (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")))))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compAllReqCommSatisfied /\\ -(I[Computer] /\\ -(compReqCommWith;-(compRouter;(rrtStar;compRouter~))~)) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Computer] /\\ -(compReqCommWith;-(compRouter;(rrtStar;compRouter~))~) ([Computer*Computer]) */
                                             SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                             FROM ( /* I[Computer] */
                                               SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect0
                                             WHERE NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   compReqCommWith;-(compRouter;(rrtStar;compRouter~))~ */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                                                FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                  FROM `compReqCommWith`
                                                                  WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                                                     
                                                                     ( /* case: ECpl e
                                                                          ECpl ( \"(compRouter;(rrtStar;compRouter~))~\" ) */
                                                                       SELECT DISTINCT cfst.`Computer` AS `SrcComputer`, csnd.`Computer` AS `TrgComputer`
                                                                       FROM `Computer` AS cfst,
                                                                            `Computer` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM 
                                                                              ( /* case: EFlp x. */
                                                                                /* case: (ECps es), with two or more elements in es.
                                                                                   compRouter;(rrtStar;compRouter~) */
                                                                                
                                                                                SELECT DISTINCT ECps0.`SrcComputer` AS `TrgComputer`, ECps2.`TrgComputer` AS `SrcComputer`
                                                                                FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                                                  FROM `compRouter`
                                                                                  WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                                                     ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                                                  FROM `rrtStar`
                                                                                  WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1,
                                                                                     
                                                                                     ( /* case: EFlp x. */
                                                                                       SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                                                       FROM `compRouter`
                                                                                       WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                                     ) AS ECps2
                                                                                WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                                                  AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                                              ) AS cp
                                                                         WHERE cfst.`Computer`=cp.`SrcComputer` AND csnd.`Computer`=cp.`TrgComputer`)
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                              ) AS cp
                                                         WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compAllReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompNoReqCommSatisfied' =>
        array ( 'name'          => 'InscompNoReqCommSatisfied'
              , 'ruleAdl'       => 'I[Computer] /\\ -(compReqCommWith;(compRouter;(rrtStar;compRouter~))~) |- compNoReqCommSatisfied'
              , 'origin'        => 'line 120:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ -(compReqCommWith;(compRouter;(rrtStar;compRouter~))~) |- compNoReqCommSatisfied)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ -(compReqCommWith;(compRouter;(rrtStar;compRouter~))~)) \\/ compNoReqCommSatisfied)
              // <=> { De Morgan }
              //     I[Computer] /\\ (-(compReqCommWith;(compRouter;(rrtStar;compRouter~))~) /\\ -compNoReqCommSatisfied)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (ECpl (ECps (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EBrk (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))))))),ECpl (EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (-(compReqCommWith;(compRouter;(rrtStar;compRouter~))~) /\\ -compNoReqCommSatisfied) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compReqCommWith;(compRouter;(rrtStar;compRouter~))~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                             FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                               FROM `compReqCommWith`
                                               WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    /* case: (ECps es), with two or more elements in es.
                                                       compRouter;(rrtStar;compRouter~) */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcComputer` AS `TrgComputer`, ECps2.`TrgComputer` AS `SrcComputer`
                                                    FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                      FROM `compRouter`
                                                      WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                         ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                      FROM `rrtStar`
                                                      WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                           FROM `compRouter`
                                                           WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                         ) AS ECps2
                                                    WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                      AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compNoReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelCompNoReqCommSatisfied' =>
        array ( 'name'          => 'DelCompNoReqCommSatisfied'
              , 'ruleAdl'       => 'compNoReqCommSatisfied |- I[Computer] /\\ -(compReqCommWith;(compRouter;(rrtStar;compRouter~))~)'
              , 'origin'        => 'line 123:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied |- I[Computer] /\\ -(compReqCommWith;(compRouter;(rrtStar;compRouter~))~))
              // <=> { remove |- }
              //     -(-compNoReqCommSatisfied \\/ (I[Computer] /\\ -(compReqCommWith;(compRouter;(rrtStar;compRouter~))~)))
              // <=> { De Morgan }
              //     compNoReqCommSatisfied /\\ -(I[Computer] /\\ -(compReqCommWith;(compRouter;(rrtStar;compRouter~))~))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Computer,ECpl (ECps (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EBrk (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EDcD RELATION rrtStar [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compNoReqCommSatisfied /\\ -(I[Computer] /\\ -(compReqCommWith;(compRouter;(rrtStar;compRouter~))~)) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Computer] /\\ -(compReqCommWith;(compRouter;(rrtStar;compRouter~))~) ([Computer*Computer]) */
                                             SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                             FROM ( /* I[Computer] */
                                               SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect0
                                             WHERE NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   compReqCommWith;(compRouter;(rrtStar;compRouter~))~ */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                                                FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                  FROM `compReqCommWith`
                                                                  WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                                                     
                                                                     ( /* case: EFlp x. */
                                                                       /* case: (ECps es), with two or more elements in es.
                                                                          compRouter;(rrtStar;compRouter~) */
                                                                       
                                                                       SELECT DISTINCT ECps0.`SrcComputer` AS `TrgComputer`, ECps2.`TrgComputer` AS `SrcComputer`
                                                                       FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                                         FROM `compRouter`
                                                                         WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                                            ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                                         FROM `rrtStar`
                                                                         WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1,
                                                                            
                                                                            ( /* case: EFlp x. */
                                                                              SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                                              FROM `compRouter`
                                                                              WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                            ) AS ECps2
                                                                       WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                                         AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                              ) AS cp
                                                         WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compNoReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InsscHasCommWith' =>
        array ( 'name'          => 'InsscHasCommWith'
              , 'ruleAdl'       => 'scReqCommWith /\\ scDeployedOn;(compHasCommWith;scDeployedOn~) |- scHasCommWith'
              , 'origin'        => 'line 129:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scReqCommWith /\\ scDeployedOn;(compHasCommWith;scDeployedOn~) |- scHasCommWith)
              // <=> { remove |- }
              //     -(-(scReqCommWith /\\ scDeployedOn;(compHasCommWith;scDeployedOn~)) \\/ scHasCommWith)
              // <=> { De Morgan }
              //     scReqCommWith /\\ (scDeployedOn;(compHasCommWith;scDeployedOn~) /\\ -scHasCommWith)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EIsc (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},ECps (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +}))),ECpl (EDcD RELATION scHasCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scReqCommWith /\\ (scDeployedOn;(compHasCommWith;scDeployedOn~) /\\ -scHasCommWith) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                            FROM `scReqCommWith`
                            WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scDeployedOn;(compHasCommWith;scDeployedOn~) */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                   FROM `scDeployedOn`
                                   WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                   FROM `compHasCommWith`
                                   WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps2
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                   AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                               ) AS isect1
                          WHERE (isect0.`SrcSvcComponent` = isect1.`SrcSvcComponent` AND isect0.`TrgSvcComponent` = isect1.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                        FROM `scHasCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scHasCommWith;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'DelscHasCommWith' =>
        array ( 'name'          => 'DelscHasCommWith'
              , 'ruleAdl'       => 'scHasCommWith |- scReqCommWith /\\ scDeployedOn;(compHasCommWith;scDeployedOn~)'
              , 'origin'        => 'line 132:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scHasCommWith |- scReqCommWith /\\ scDeployedOn;(compHasCommWith;scDeployedOn~))
              // <=> { remove |- }
              //     -(-scHasCommWith \\/ (scReqCommWith /\\ scDeployedOn;(compHasCommWith;scDeployedOn~)))
              // <=> { De Morgan }
              //     scHasCommWith /\\ -(scReqCommWith /\\ scDeployedOn;(compHasCommWith;scDeployedOn~))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION scHasCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},ECps (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +}))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scHasCommWith /\\ -(scReqCommWith /\\ scDeployedOn;(compHasCommWith;scDeployedOn~)) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                            FROM `scHasCommWith`
                            WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                scReqCommWith /\\ scDeployedOn;(compHasCommWith;scDeployedOn~) ([SvcComponent*SvcComponent]) */
                                             SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                               FROM `scReqCommWith`
                                               WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS isect0, 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       scDeployedOn;(compHasCommWith;scDeployedOn~) */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgSvcComponent`
                                                    FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                      FROM `scDeployedOn`
                                                      WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                         ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                      FROM `compHasCommWith`
                                                      WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                           FROM `scDeployedOn`
                                                           WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                         ) AS ECps2
                                                    WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                      AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                                                  ) AS isect1
                                             WHERE (isect0.`SrcSvcComponent` = isect1.`SrcSvcComponent` AND isect0.`TrgSvcComponent` = isect1.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;scHasCommWith;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'InsscAllReqCommSatisfied' =>
        array ( 'name'          => 'InsscAllReqCommSatisfied'
              , 'ruleAdl'       => 'I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -scReqCommWith!(scDeployedOn;(compHasCommWith;scDeployedOn~))~) |- scAllReqCommSatisfied'
              , 'origin'        => 'line 139:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -scReqCommWith!(scDeployedOn;(compHasCommWith;scDeployedOn~))~) |- scAllReqCommSatisfied)
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -scReqCommWith!(scDeployedOn;(compHasCommWith;scDeployedOn~))~)) \\/ scAllReqCommSatisfied)
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (-scReqCommWith!(scDeployedOn;(compHasCommWith;scDeployedOn~))~ /\\ -scAllReqCommSatisfied))
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (-(scReqCommWith;-(scDeployedOn;(compHasCommWith;scDeployedOn~))~) /\\ -scAllReqCommSatisfied))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")),EIsc (ECpl (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (EFlp (EBrk (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},ECps (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +})))))))),ECpl (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (-(scReqCommWith;-(scDeployedOn;(compHasCommWith;scDeployedOn~))~) /\\ -scAllReqCommSatisfied)) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scReqCommWith;scReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                   FROM `scReqCommWith`
                                   WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scReqCommWith;-(scDeployedOn;(compHasCommWith;scDeployedOn~))~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                               FROM `scReqCommWith`
                                               WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"(scDeployedOn;(compHasCommWith;scDeployedOn~))~\" ) */
                                                    SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`SvcComponent` AS `TrgSvcComponent`
                                                    FROM `SvcComponent` AS cfst,
                                                         `SvcComponent` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: EFlp x. */
                                                             /* case: (ECps es), with two or more elements in es.
                                                                scDeployedOn;(compHasCommWith;scDeployedOn~) */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcSvcComponent` AS `TrgSvcComponent`, ECps2.`TrgSvcComponent` AS `SrcSvcComponent`
                                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                               FROM `scDeployedOn`
                                                               WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                                  ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                               FROM `compHasCommWith`
                                                               WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps1,
                                                                  
                                                                  ( /* case: EFlp x. */
                                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                                    FROM `scDeployedOn`
                                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                                  ) AS ECps2
                                                             WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                               AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                                                           ) AS cp
                                                      WHERE cfst.`SvcComponent`=cp.`SrcSvcComponent` AND csnd.`SvcComponent`=cp.`TrgSvcComponent`)
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scAllReqCommSatisfied;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'DelscAllReqCommSatisfied' =>
        array ( 'name'          => 'DelscAllReqCommSatisfied'
              , 'ruleAdl'       => 'scAllReqCommSatisfied |- I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -scReqCommWith!(scDeployedOn;(compHasCommWith;scDeployedOn~))~)'
              , 'origin'        => 'line 142:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scAllReqCommSatisfied |- I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -scReqCommWith!(scDeployedOn;(compHasCommWith;scDeployedOn~))~))
              // <=> { remove |- }
              //     -(-scAllReqCommSatisfied \\/ (I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -scReqCommWith!(scDeployedOn;(compHasCommWith;scDeployedOn~))~)))
              // <=> { De Morgan }
              //     scAllReqCommSatisfied /\\ -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -scReqCommWith!(scDeployedOn;(compHasCommWith;scDeployedOn~))~))
              // <=> { De Morgan }
              //     scAllReqCommSatisfied /\\ -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;-(scDeployedOn;(compHasCommWith;scDeployedOn~))~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")),ECpl (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (EFlp (EBrk (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},ECps (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +}))))))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scAllReqCommSatisfied /\\ -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;-(scDeployedOn;(compHasCommWith;scDeployedOn~))~))) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;-(scDeployedOn;(compHasCommWith;scDeployedOn~))~)) ([SvcComponent*SvcComponent]) */
                                             SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TrgSvcComponent`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       scReqCommWith;scReqCommWith~ */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                                    FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                                      FROM `scReqCommWith`
                                                      WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                                           FROM `scReqCommWith`
                                                           WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                                         ) AS ECps1
                                                    WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                  ) AS isect0, ( /* I[SvcComponent] */
                                               SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                                             WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   scReqCommWith;-(scDeployedOn;(compHasCommWith;scDeployedOn~))~ */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                                                FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                                                  FROM `scReqCommWith`
                                                                  WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                                                     
                                                                     ( /* case: ECpl e
                                                                          ECpl ( \"(scDeployedOn;(compHasCommWith;scDeployedOn~))~\" ) */
                                                                       SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`SvcComponent` AS `TrgSvcComponent`
                                                                       FROM `SvcComponent` AS cfst,
                                                                            `SvcComponent` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM 
                                                                              ( /* case: EFlp x. */
                                                                                /* case: (ECps es), with two or more elements in es.
                                                                                   scDeployedOn;(compHasCommWith;scDeployedOn~) */
                                                                                
                                                                                SELECT DISTINCT ECps0.`SrcSvcComponent` AS `TrgSvcComponent`, ECps2.`TrgSvcComponent` AS `SrcSvcComponent`
                                                                                FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                                                  FROM `scDeployedOn`
                                                                                  WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                                                     ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                                  FROM `compHasCommWith`
                                                                                  WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps1,
                                                                                     
                                                                                     ( /* case: EFlp x. */
                                                                                       SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                                                       FROM `scDeployedOn`
                                                                                       WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                                                     ) AS ECps2
                                                                                WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                                                  AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                                                                              ) AS cp
                                                                         WHERE cfst.`SvcComponent`=cp.`SrcSvcComponent` AND csnd.`SvcComponent`=cp.`TrgSvcComponent`)
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                              ) AS cp
                                                         WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;scAllReqCommSatisfied;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'InsscNoReqCommSatisfied' =>
        array ( 'name'          => 'InsscNoReqCommSatisfied'
              , 'ruleAdl'       => 'I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~)) |- scNoReqCommSatisfied'
              , 'origin'        => 'line 147:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~)) |- scNoReqCommSatisfied)
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~))) \\/ scNoReqCommSatisfied)
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (-(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~) /\\ -scNoReqCommSatisfied))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")),EIsc (ECpl (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EBrk (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},ECps (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +}))))))),ECpl (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (-(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~) /\\ -scNoReqCommSatisfied)) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scReqCommWith;scReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                   FROM `scReqCommWith`
                                   WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                               FROM `scReqCommWith`
                                               WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    /* case: (ECps es), with two or more elements in es.
                                                       scDeployedOn;(compHasCommWith;scDeployedOn~) */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcSvcComponent` AS `TrgSvcComponent`, ECps2.`TrgSvcComponent` AS `SrcSvcComponent`
                                                    FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                      FROM `scDeployedOn`
                                                      WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                         ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                      FROM `compHasCommWith`
                                                      WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                           FROM `scDeployedOn`
                                                           WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                         ) AS ECps2
                                                    WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                      AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scNoReqCommSatisfied;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'DelscNoReqCommSatisfied' =>
        array ( 'name'          => 'DelscNoReqCommSatisfied'
              , 'ruleAdl'       => 'scNoReqCommSatisfied |- I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~))'
              , 'origin'        => 'line 150:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scNoReqCommSatisfied |- I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~)))
              // <=> { remove |- }
              //     -(-scNoReqCommSatisfied \\/ (I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~))))
              // <=> { De Morgan }
              //     scNoReqCommSatisfied /\\ -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")),ECpl (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EBrk (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},ECps (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +})))))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scNoReqCommSatisfied /\\ -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~))) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~)) ([SvcComponent*SvcComponent]) */
                                             SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TrgSvcComponent`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       scReqCommWith;scReqCommWith~ */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                                    FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                                      FROM `scReqCommWith`
                                                      WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                                           FROM `scReqCommWith`
                                                           WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                                         ) AS ECps1
                                                    WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                  ) AS isect0, ( /* I[SvcComponent] */
                                               SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                                             WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   scReqCommWith;(scDeployedOn;(compHasCommWith;scDeployedOn~))~ */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                                                FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                                                  FROM `scReqCommWith`
                                                                  WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                                                     
                                                                     ( /* case: EFlp x. */
                                                                       /* case: (ECps es), with two or more elements in es.
                                                                          scDeployedOn;(compHasCommWith;scDeployedOn~) */
                                                                       
                                                                       SELECT DISTINCT ECps0.`SrcSvcComponent` AS `TrgSvcComponent`, ECps2.`TrgSvcComponent` AS `SrcSvcComponent`
                                                                       FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                                         FROM `scDeployedOn`
                                                                         WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                                            ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                         FROM `compHasCommWith`
                                                                         WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps1,
                                                                            
                                                                            ( /* case: EFlp x. */
                                                                              SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                                              FROM `scDeployedOn`
                                                                              WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                                            ) AS ECps2
                                                                       WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                                         AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                              ) AS cp
                                                         WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;scNoReqCommSatisfied;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'InssvcAllSvcCompReqsSatisfied' =>
        array ( 'name'          => 'InssvcAllSvcCompReqsSatisfied'
              , 'ruleAdl'       => 'I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scAllReqCommSatisfied;scImplements)) |- svcAllSvcCompReqsSatisfied'
              , 'origin'        => 'line 157:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scAllReqCommSatisfied;scImplements)) |- svcAllSvcCompReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scAllReqCommSatisfied;scImplements))) \\/ svcAllSvcCompReqsSatisfied)
              // <=> { De Morgan }
              //     I[Service] /\\ (scImplements~;scImplements /\\ (-scImplements~!(scAllReqCommSatisfied;scImplements) /\\ -svcAllSvcCompReqsSatisfied))
              // <=> { De Morgan }
              //     I[Service] /\\ (scImplements~;scImplements /\\ (-(scImplements~;-(scAllReqCommSatisfied;scImplements)) /\\ -svcAllSvcCompReqsSatisfied))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Service,EIsc (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EIsc (ECpl (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),ECpl (ECps (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +})))),ECpl (EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Service] /\\ (scImplements~;scImplements /\\ (-(scImplements~;-(scAllReqCommSatisfied;scImplements)) /\\ -svcAllSvcCompReqsSatisfied)) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scImplements~;scImplements */
                                 
                                 SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                        FROM `scImplements`
                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                   FROM `scImplements`
                                   WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0, ( /* I[Service] */
                            SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcService` = isect0.`TrgService` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scImplements~;-(scAllReqCommSatisfied;scImplements) */
                                             
                                             SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                    FROM `scImplements`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"scAllReqCommSatisfied;scImplements\" ) */
                                                    SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`Service` AS `TrgService`
                                                    FROM `SvcComponent` AS cfst,
                                                         `Service` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                scAllReqCommSatisfied;scImplements */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgService`
                                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                                                               FROM `SvcComponent`
                                                               WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                                                  ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                               FROM `scImplements`
                                                               WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                           ) AS cp
                                                      WHERE cfst.`SvcComponent`=cp.`SrcSvcComponent` AND csnd.`Service`=cp.`TrgService`)
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                                        FROM `Service`
                                        WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcAllSvcCompReqsSatisfied;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'DelsvcAllSvcCompReqsSatisfied' =>
        array ( 'name'          => 'DelsvcAllSvcCompReqsSatisfied'
              , 'ruleAdl'       => 'svcAllSvcCompReqsSatisfied |- I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scAllReqCommSatisfied;scImplements))'
              , 'origin'        => 'line 161:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcAllSvcCompReqsSatisfied |- I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scAllReqCommSatisfied;scImplements)))
              // <=> { remove |- }
              //     -(-svcAllSvcCompReqsSatisfied \\/ (I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scAllReqCommSatisfied;scImplements))))
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied /\\ -(I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scAllReqCommSatisfied;scImplements)))
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied /\\ -(I[Service] /\\ (scImplements~;scImplements /\\ -(scImplements~;-(scAllReqCommSatisfied;scImplements))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Service,EIsc (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),ECpl (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),ECpl (ECps (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +}))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcAllSvcCompReqsSatisfied /\\ -(I[Service] /\\ (scImplements~;scImplements /\\ -(scImplements~;-(scAllReqCommSatisfied;scImplements)))) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Service] /\\ (scImplements~;scImplements /\\ -(scImplements~;-(scAllReqCommSatisfied;scImplements))) ([Service*Service]) */
                                             SELECT DISTINCT isect0.`SrcService`, isect0.`TrgService`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       scImplements~;scImplements */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                           FROM `scImplements`
                                                           WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                         ) AS ECps0,
                                                         ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                      FROM `scImplements`
                                                      WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                    WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                  ) AS isect0, ( /* I[Service] */
                                               SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                                               FROM `Service`
                                               WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect1
                                             WHERE isect0.`SrcService` = isect0.`TrgService` AND NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   scImplements~;-(scAllReqCommSatisfied;scImplements) */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                                                FROM 
                                                                     ( /* case: EFlp x. */
                                                                       SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                                       FROM `scImplements`
                                                                       WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                     ) AS ECps0,
                                                                     
                                                                     ( /* case: ECpl e
                                                                          ECpl ( \"scAllReqCommSatisfied;scImplements\" ) */
                                                                       SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`Service` AS `TrgService`
                                                                       FROM `SvcComponent` AS cfst,
                                                                            `Service` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM 
                                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                                   scAllReqCommSatisfied;scImplements */
                                                                                
                                                                                SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgService`
                                                                                FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                                                                                  FROM `SvcComponent`
                                                                                  WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                                                                     ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                                                  FROM `scImplements`
                                                                                  WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                                                WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                                              ) AS cp
                                                                         WHERE cfst.`SvcComponent`=cp.`SrcSvcComponent` AND csnd.`Service`=cp.`TrgService`)
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                              ) AS cp
                                                         WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;svcAllSvcCompReqsSatisfied;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'InssvcNoSvcCompReqsSatisfied' =>
        array ( 'name'          => 'InssvcNoSvcCompReqsSatisfied'
              , 'ruleAdl'       => 'I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scNoReqCommSatisfied;scImplements)) |- svcNoSvcCompReqsSatisfied'
              , 'origin'        => 'line 167:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scNoReqCommSatisfied;scImplements)) |- svcNoSvcCompReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scNoReqCommSatisfied;scImplements))) \\/ svcNoSvcCompReqsSatisfied)
              // <=> { De Morgan }
              //     I[Service] /\\ (scImplements~;scImplements /\\ (-scImplements~!(scNoReqCommSatisfied;scImplements) /\\ -svcNoSvcCompReqsSatisfied))
              // <=> { De Morgan }
              //     I[Service] /\\ (scImplements~;scImplements /\\ (-(scImplements~;-(scNoReqCommSatisfied;scImplements)) /\\ -svcNoSvcCompReqsSatisfied))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Service,EIsc (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EIsc (ECpl (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),ECpl (ECps (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +})))),ECpl (EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Service] /\\ (scImplements~;scImplements /\\ (-(scImplements~;-(scNoReqCommSatisfied;scImplements)) /\\ -svcNoSvcCompReqsSatisfied)) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scImplements~;scImplements */
                                 
                                 SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                        FROM `scImplements`
                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                   FROM `scImplements`
                                   WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0, ( /* I[Service] */
                            SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcService` = isect0.`TrgService` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scImplements~;-(scNoReqCommSatisfied;scImplements) */
                                             
                                             SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                    FROM `scImplements`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl ( \"scNoReqCommSatisfied;scImplements\" ) */
                                                    SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`Service` AS `TrgService`
                                                    FROM `SvcComponent` AS cfst,
                                                         `Service` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                scNoReqCommSatisfied;scImplements */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgService`
                                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                                                               FROM `SvcComponent`
                                                               WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                                                  ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                               FROM `scImplements`
                                                               WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                           ) AS cp
                                                      WHERE cfst.`SvcComponent`=cp.`SrcSvcComponent` AND csnd.`Service`=cp.`TrgService`)
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                                        FROM `Service`
                                        WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcNoSvcCompReqsSatisfied;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'DelsvcNoSvcCompReqsSatisfied' =>
        array ( 'name'          => 'DelsvcNoSvcCompReqsSatisfied'
              , 'ruleAdl'       => 'svcNoSvcCompReqsSatisfied |- I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scNoReqCommSatisfied;scImplements))'
              , 'origin'        => 'line 171:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcNoSvcCompReqsSatisfied |- I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scNoReqCommSatisfied;scImplements)))
              // <=> { remove |- }
              //     -(-svcNoSvcCompReqsSatisfied \\/ (I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scNoReqCommSatisfied;scImplements))))
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied /\\ -(I[Service] /\\ (scImplements~;scImplements /\\ -scImplements~!(scNoReqCommSatisfied;scImplements)))
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied /\\ -(I[Service] /\\ (scImplements~;scImplements /\\ -(scImplements~;-(scNoReqCommSatisfied;scImplements))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Service,EIsc (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),ECpl (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),ECpl (ECps (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +}))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcNoSvcCompReqsSatisfied /\\ -(I[Service] /\\ (scImplements~;scImplements /\\ -(scImplements~;-(scNoReqCommSatisfied;scImplements)))) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Service] /\\ (scImplements~;scImplements /\\ -(scImplements~;-(scNoReqCommSatisfied;scImplements))) ([Service*Service]) */
                                             SELECT DISTINCT isect0.`SrcService`, isect0.`TrgService`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       scImplements~;scImplements */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                           FROM `scImplements`
                                                           WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                         ) AS ECps0,
                                                         ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                      FROM `scImplements`
                                                      WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                    WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                  ) AS isect0, ( /* I[Service] */
                                               SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                                               FROM `Service`
                                               WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect1
                                             WHERE isect0.`SrcService` = isect0.`TrgService` AND NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   scImplements~;-(scNoReqCommSatisfied;scImplements) */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                                                FROM 
                                                                     ( /* case: EFlp x. */
                                                                       SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                                       FROM `scImplements`
                                                                       WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                     ) AS ECps0,
                                                                     
                                                                     ( /* case: ECpl e
                                                                          ECpl ( \"scNoReqCommSatisfied;scImplements\" ) */
                                                                       SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`Service` AS `TrgService`
                                                                       FROM `SvcComponent` AS cfst,
                                                                            `Service` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM 
                                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                                   scNoReqCommSatisfied;scImplements */
                                                                                
                                                                                SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgService`
                                                                                FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                                                                                  FROM `SvcComponent`
                                                                                  WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                                                                     ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                                                  FROM `scImplements`
                                                                                  WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                                                WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                                              ) AS cp
                                                                         WHERE cfst.`SvcComponent`=cp.`SrcSvcComponent` AND csnd.`Service`=cp.`TrgService`)
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                              ) AS cp
                                                         WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;svcNoSvcCompReqsSatisfied;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'Connect computer to network router' =>
        array ( 'name'          => 'Connect computer to network router'
              , 'ruleAdl'       => 'I[Computer] /\\ compReqCommWith;compReqCommWith~ |- compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~)'
              , 'origin'        => 'line 12:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compReqCommWith;compReqCommWith~ |- compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~))
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compReqCommWith;compReqCommWith~) \\/ compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~))
              // <=> { De Morgan }
              //     I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (ECps (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "")),ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EIsc (EDcI Router,ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))),EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~))) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compReqCommWith;compReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                   FROM `compReqCommWith`
                                   WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sComputer` AS `TrgComputer`, `tComputer` AS `SrcComputer`
                                        FROM `compReqCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0, ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                               FROM `compRouter`
                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                       I[Router] /\\ routerNW;routerNW~ ([Router*Router]) */
                                                    SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              routerNW;routerNW~ */
                                                           
                                                           SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                           FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                             FROM `Router`
                                                             WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                                         ) AS isect0, ( /* I[Router] */
                                                      SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                      FROM `Router`
                                                      WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                    WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                    FROM `compRouter`
                                                    WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                               AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be connected to a network-router.')
                    )
              )
    , 'insconnectComputerToNetworkRouter' =>
        array ( 'name'          => 'insconnectComputerToNetworkRouter'
              , 'ruleAdl'       => '(I[Computer] /\\ compReqCommWith;compReqCommWith~) /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~)) |- connectComputerToNetworkRouter'
              , 'origin'        => 'line 17:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~))) |- connectComputerToNetworkRouter)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~)))) \\/ connectComputerToNetworkRouter)
              // <=> { De Morgan }
              //     I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ (-(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~)) /\\ -connectComputerToNetworkRouter))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (ECps (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "")),EIsc (ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EIsc (EDcI Router,ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))),EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")))),ECpl (EDcD RELATION connectComputerToNetworkRouter [Computer*Computer] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ (-(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~)) /\\ -connectComputerToNetworkRouter)) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compReqCommWith;compReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                   FROM `compReqCommWith`
                                   WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sComputer` AS `TrgComputer`, `tComputer` AS `SrcComputer`
                                        FROM `compReqCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0, ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                               FROM `compRouter`
                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                       I[Router] /\\ routerNW;routerNW~ ([Router*Router]) */
                                                    SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              routerNW;routerNW~ */
                                                           
                                                           SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                           FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                             FROM `Router`
                                                             WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                                         ) AS isect0, ( /* I[Router] */
                                                      SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                      FROM `Router`
                                                      WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                    WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                    FROM `compRouter`
                                                    WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                               AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `connectComputerToNetworkRouter` AS `TrgComputer`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `connectComputerToNetworkRouter` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;connectComputerToNetworkRouter;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'delconnectComputerToNetworkRouter' =>
        array ( 'name'          => 'delconnectComputerToNetworkRouter'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter |- (I[Computer] /\\ compReqCommWith;compReqCommWith~) /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~))'
              , 'origin'        => 'line 20:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter |- I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~))))
              // <=> { remove |- }
              //     -(-connectComputerToNetworkRouter \\/ (I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~)))))
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter /\\ -(I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION connectComputerToNetworkRouter [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI Computer,EIsc (ECps (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "")),ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECps (EIsc (EDcI Router,ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))),EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             connectComputerToNetworkRouter /\\ -(I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~)))) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `connectComputerToNetworkRouter` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `connectComputerToNetworkRouter` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[Computer] /\\ (compReqCommWith;compReqCommWith~ /\\ -(compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~))) ([Computer*Computer]) */
                                             SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       compReqCommWith;compReqCommWith~ */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                                    FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                      FROM `compReqCommWith`
                                                      WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `sComputer` AS `TrgComputer`, `tComputer` AS `SrcComputer`
                                                           FROM `compReqCommWith`
                                                           WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                                         ) AS ECps1
                                                    WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                  ) AS isect0, ( /* I[Computer] */
                                               SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                                             WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   compRouter;((I[Router] /\\ routerNW;routerNW~);compRouter~) */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                                                FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                                  FROM `compRouter`
                                                                  WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                                     
                                                                     ( /* case: (EIsc lst\'@(_:_:_))
                                                                          I[Router] /\\ routerNW;routerNW~ ([Router*Router]) */
                                                                       SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                                       FROM 
                                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                                 routerNW;routerNW~ */
                                                                              
                                                                              SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                                              FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                                                FROM `Router`
                                                                                WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                                                   
                                                                                   ( /* case: EFlp x. */
                                                                                     SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                                     FROM `Router`
                                                                                     WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                                   ) AS ECps1
                                                                              WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                                                            ) AS isect0, ( /* I[Router] */
                                                                         SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                                         FROM `Router`
                                                                         WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                                       WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                                     ) AS ECps1,
                                                                     
                                                                     ( /* case: EFlp x. */
                                                                       SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                                       FROM `compRouter`
                                                                       WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                     ) AS ECps2
                                                                WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                                  AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                              ) AS cp
                                                         WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;connectComputerToNetworkRouter;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'Create router paths' =>
        array ( 'name'          => 'Create router paths'
              , 'ruleAdl'       => 'routerNeedsPathTo |- -V[Router*Router]'
              , 'origin'        => 'line 24:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNeedsPathTo |- -V[Router*Router])
              // <=> { remove |- }
              //     -(-routerNeedsPathTo \\/ -V[Router*Router])
              // <=> { De Morgan }
              //     routerNeedsPathTo /\\ V[Router*Router]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" "",EDcV [Router*Router])
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerNeedsPathTo /\\ V[Router*Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                            FROM `routerNeedsPathTo`
                            WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS isect0, ( /* case: (EDcV (Sign s t))
                               V [ \"[Router*Router]\" ] */
                            SELECT DISTINCT cfst0.`Router` AS `SrcRouter`, cfst1.`Router` AS `TrgRouter`
                            FROM `Router` AS cfst0, `Router` AS cfst1 ) AS isect1
                          WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TrgRouter` = isect1.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'A path must exist from router ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' to ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Routes to be discarded' =>
        array ( 'name'          => 'Routes to be discarded'
              , 'ruleAdl'       => 'rrtDirect |- routerNW;(V[Network*Network];routerNW~)'
              , 'origin'        => 'line 29:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(rrtDirect |- routerNW;(V[Network*Network];routerNW~))
              // <=> { remove |- }
              //     -(-rrtDirect \\/ routerNW;(V[Network*Network];routerNW~))
              // <=> { De Morgan }
              //     rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",ECps (EDcV [Network*Network],EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~)) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                            FROM `rrtDirect`
                            WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case:  (e:ERel (V _) _:f:fx)
                                                routerNW */
                                             SELECT DISTINCT fst.`SrcRouter`, snd.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS fst,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS snd
                                             WHERE fst.`SrcRouter` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Route from ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' to ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' should be removed.')
                    )
              )
    , 'insroutesToBeDiscarded' =>
        array ( 'name'          => 'insroutesToBeDiscarded'
              , 'ruleAdl'       => 'rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~)) |- routesToBeDiscarded'
              , 'origin'        => 'line 34:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~)) |- routesToBeDiscarded)
              // <=> { remove |- }
              //     -(-(rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~))) \\/ routesToBeDiscarded)
              // <=> { De Morgan }
              //     rrtDirect /\\ (-(routerNW;(V[Network*Network];routerNW~)) /\\ -routesToBeDiscarded)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" "",EIsc (ECpl (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",ECps (EDcV [Network*Network],EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")))),ECpl (EDcD RELATION routesToBeDiscarded [Router*Router] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             rrtDirect /\\ (-(routerNW;(V[Network*Network];routerNW~)) /\\ -routesToBeDiscarded) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                            FROM `rrtDirect`
                            WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case:  (e:ERel (V _) _:f:fx)
                                                routerNW */
                                             SELECT DISTINCT fst.`SrcRouter`, snd.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS fst,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS snd
                                             WHERE fst.`SrcRouter` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                        FROM `routesToBeDiscarded`
                                        WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routesToBeDiscarded;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'delroutesToBeDiscarded' =>
        array ( 'name'          => 'delroutesToBeDiscarded'
              , 'ruleAdl'       => 'routesToBeDiscarded |- rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~))'
              , 'origin'        => 'line 37:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routesToBeDiscarded |- rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~)))
              // <=> { remove |- }
              //     -(-routesToBeDiscarded \\/ (rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~))))
              // <=> { De Morgan }
              //     routesToBeDiscarded /\\ -(rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION routesToBeDiscarded [Router*Router] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",ECps (EDcV [Network*Network],EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routesToBeDiscarded /\\ -(rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~))) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                            FROM `routesToBeDiscarded`
                            WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                rrtDirect /\\ -(routerNW;(V[Network*Network];routerNW~)) ([Router*Router]) */
                                             SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                             FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                               FROM `rrtDirect`
                                               WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS isect0
                                             WHERE NOT EXISTS (SELECT * FROM 
                                                              ( /* case:  (e:ERel (V _) _:f:fx)
                                                                   routerNW */
                                                                SELECT DISTINCT fst.`SrcRouter`, snd.`TrgRouter`
                                                                FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS fst,
                                                                     
                                                                     ( /* case: EFlp x. */
                                                                       SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                       FROM `Router`
                                                                       WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                     ) AS snd
                                                                WHERE fst.`SrcRouter` IS NOT NULL
                                                              ) AS cp
                                                         WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routesToBeDiscarded;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Computers to be disconnected' =>
        array ( 'name'          => 'Computers to be disconnected'
              , 'ruleAdl'       => 'compRouter |- compRouter;(I[Router] /\\ routerNW;routerNW~)'
              , 'origin'        => 'line 41:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(compRouter |- compRouter;(I[Router] /\\ routerNW;routerNW~))
              // <=> { remove |- }
              //     -(-compRouter \\/ compRouter;(I[Router] /\\ routerNW;routerNW~))
              // <=> { De Morgan }
              //     compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EIsc (EDcI Router,ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)) ([Computer*Router]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                            FROM `compRouter`
                            WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compRouter;(I[Router] /\\ routerNW;routerNW~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                               FROM `compRouter`
                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                       I[Router] /\\ routerNW;routerNW~ ([Router*Router]) */
                                                    SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              routerNW;routerNW~ */
                                                           
                                                           SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                           FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                             FROM `Router`
                                                             WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                                         ) AS isect0, ( /* I[Router] */
                                                      SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                      FROM `Router`
                                                      WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                    WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Computer ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' cannot be connected to router ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' as the latter is not connected to a network.')
                    )
              )
    , 'inscomputerToBeDisconnected' =>
        array ( 'name'          => 'inscomputerToBeDisconnected'
              , 'ruleAdl'       => 'compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)) |- computerToBeDisconnected'
              , 'origin'        => 'line 46:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)) |- computerToBeDisconnected)
              // <=> { remove |- }
              //     -(-(compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))) \\/ computerToBeDisconnected)
              // <=> { De Morgan }
              //     compRouter /\\ (-(compRouter;(I[Router] /\\ routerNW;routerNW~)) /\\ -computerToBeDisconnected)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EIsc (ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EIsc (EDcI Router,ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))))),ECpl (EDcD RELATION computerToBeDisconnected [Computer*Router] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compRouter /\\ (-(compRouter;(I[Router] /\\ routerNW;routerNW~)) /\\ -computerToBeDisconnected) ([Computer*Router]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                            FROM `compRouter`
                            WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compRouter;(I[Router] /\\ routerNW;routerNW~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                               FROM `compRouter`
                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst\'@(_:_:_))
                                                       I[Router] /\\ routerNW;routerNW~ ([Router*Router]) */
                                                    SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              routerNW;routerNW~ */
                                                           
                                                           SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                           FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                             FROM `Router`
                                                             WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                                         ) AS isect0, ( /* I[Router] */
                                                      SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                      FROM `Router`
                                                      WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                    WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                        FROM `computerToBeDisconnected`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;computerToBeDisconnected;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'delcomputerToBeDisconnected' =>
        array ( 'name'          => 'delcomputerToBeDisconnected'
              , 'ruleAdl'       => 'computerToBeDisconnected |- compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))'
              , 'origin'        => 'line 49:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(computerToBeDisconnected |- compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)))
              // <=> { remove |- }
              //     -(-computerToBeDisconnected \\/ (compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))))
              // <=> { De Morgan }
              //     computerToBeDisconnected /\\ -(compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION computerToBeDisconnected [Computer*Router] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EIsc (EDcI Router,ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             computerToBeDisconnected /\\ -(compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))) ([Computer*Router]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                            FROM `computerToBeDisconnected`
                            WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)) ([Computer*Router]) */
                                             SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                               FROM `compRouter`
                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                                             WHERE NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   compRouter;(I[Router] /\\ routerNW;routerNW~) */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgRouter`
                                                                FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                                  FROM `compRouter`
                                                                  WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                                     
                                                                     ( /* case: (EIsc lst\'@(_:_:_))
                                                                          I[Router] /\\ routerNW;routerNW~ ([Router*Router]) */
                                                                       SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                                       FROM 
                                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                                 routerNW;routerNW~ */
                                                                              
                                                                              SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                                              FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                                                FROM `Router`
                                                                                WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                                                   
                                                                                   ( /* case: EFlp x. */
                                                                                     SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                                     FROM `Router`
                                                                                     WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                                   ) AS ECps1
                                                                              WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                                                            ) AS isect0, ( /* I[Router] */
                                                                         SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                                         FROM `Router`
                                                                         WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                                       WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                              ) AS cp
                                                         WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;computerToBeDisconnected;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Set up computer-computer communications' =>
        array ( 'name'          => 'Set up computer-computer communications'
              , 'ruleAdl'       => 'compReqCommWith |- compHasCommWith'
              , 'origin'        => 'line 53:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compReqCommWith |- compHasCommWith)
              // <=> { remove |- }
              //     -(-compReqCommWith \\/ compHasCommWith)
              // <=> { De Morgan }
              //     compReqCommWith /\\ -compHasCommWith
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" ""))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compReqCommWith /\\ -compHasCommWith ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                            FROM `compReqCommWith`
                            WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                        FROM `compHasCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Computer ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' requires a comm.link with ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'inssetupComputerComputerCommunications' =>
        array ( 'name'          => 'inssetupComputerComputerCommunications'
              , 'ruleAdl'       => 'compReqCommWith /\\ -compHasCommWith |- setupComputerComputerCommunications'
              , 'origin'        => 'line 58:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compReqCommWith /\\ -compHasCommWith |- setupComputerComputerCommunications)
              // <=> { remove |- }
              //     -(-(compReqCommWith /\\ -compHasCommWith) \\/ setupComputerComputerCommunications)
              // <=> { De Morgan }
              //     compReqCommWith /\\ (-compHasCommWith /\\ -setupComputerComputerCommunications)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",EIsc (ECpl (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (EDcD RELATION setupComputerComputerCommunications [Computer*Computer] Nothing PRAGMA "" "" "")))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compReqCommWith /\\ (-compHasCommWith /\\ -setupComputerComputerCommunications) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                            FROM `compReqCommWith`
                            WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                        FROM `compHasCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                        FROM `setupComputerComputerCommunications`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;setupComputerComputerCommunications;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'delsetupComputerComputerCommunications' =>
        array ( 'name'          => 'delsetupComputerComputerCommunications'
              , 'ruleAdl'       => 'setupComputerComputerCommunications |- compReqCommWith /\\ -compHasCommWith'
              , 'origin'        => 'line 61:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(setupComputerComputerCommunications |- compReqCommWith /\\ -compHasCommWith)
              // <=> { remove |- }
              //     -(-setupComputerComputerCommunications \\/ (compReqCommWith /\\ -compHasCommWith))
              // <=> { De Morgan }
              //     setupComputerComputerCommunications /\\ -(compReqCommWith /\\ -compHasCommWith)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION setupComputerComputerCommunications [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             setupComputerComputerCommunications /\\ -(compReqCommWith /\\ -compHasCommWith) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                            FROM `setupComputerComputerCommunications`
                            WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                compReqCommWith /\\ -compHasCommWith ([Computer*Computer]) */
                                             SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                             FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                               FROM `compReqCommWith`
                                               WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                                             WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                           FROM `compHasCommWith`
                                                           WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                                         WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;setupComputerComputerCommunications;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'Start running service components' =>
        array ( 'name'          => 'Start running service components'
              , 'ruleAdl'       => 'I[SvcComponent] /\\ scImplements;scImplements~ |- scDeployedOn;scDeployedOn~'
              , 'origin'        => 'line 65:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ scImplements;scImplements~ |- scDeployedOn;scDeployedOn~)
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ scImplements;scImplements~) \\/ scDeployedOn;scDeployedOn~)
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (scImplements;scImplements~ /\\ -(scDeployedOn;scDeployedOn~))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -},EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -})),ECpl (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +})))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (scImplements;scImplements~ /\\ -(scDeployedOn;scDeployedOn~)) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scImplements;scImplements~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                   FROM `scImplements`
                                   WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                        FROM `scImplements`
                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgService`=ECps1.`SrcService`
                               ) AS isect0, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scDeployedOn;scDeployedOn~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                               FROM `scDeployedOn`
                                               WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'An instance of ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be started on some computer.')
                    )
              )
    , 'insstartRunningServiceComponents' =>
        array ( 'name'          => 'insstartRunningServiceComponents'
              , 'ruleAdl'       => '(I[SvcComponent] /\\ scImplements;scImplements~) /\\ -(scDeployedOn;scDeployedOn~) |- startRunningServiceComponents'
              , 'origin'        => 'line 70:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ (scImplements;scImplements~ /\\ -(scDeployedOn;scDeployedOn~)) |- startRunningServiceComponents)
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ (scImplements;scImplements~ /\\ -(scDeployedOn;scDeployedOn~))) \\/ startRunningServiceComponents)
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (scImplements;scImplements~ /\\ (-(scDeployedOn;scDeployedOn~) /\\ -startRunningServiceComponents))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -},EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -})),EIsc (ECpl (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +}))),ECpl (EDcD RELATION startRunningServiceComponents [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (scImplements;scImplements~ /\\ (-(scDeployedOn;scDeployedOn~) /\\ -startRunningServiceComponents)) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scImplements;scImplements~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                   FROM `scImplements`
                                   WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                        FROM `scImplements`
                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgService`=ECps1.`SrcService`
                               ) AS isect0, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scDeployedOn;scDeployedOn~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                               FROM `scDeployedOn`
                                               WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `startRunningServiceComponents` AS `TrgSvcComponent`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `startRunningServiceComponents` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;startRunningServiceComponents;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'delstartRunningServiceComponents' =>
        array ( 'name'          => 'delstartRunningServiceComponents'
              , 'ruleAdl'       => 'startRunningServiceComponents |- (I[SvcComponent] /\\ scImplements;scImplements~) /\\ -(scDeployedOn;scDeployedOn~)'
              , 'origin'        => 'line 73:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(startRunningServiceComponents |- I[SvcComponent] /\\ (scImplements;scImplements~ /\\ -(scDeployedOn;scDeployedOn~)))
              // <=> { remove |- }
              //     -(-startRunningServiceComponents \\/ (I[SvcComponent] /\\ (scImplements;scImplements~ /\\ -(scDeployedOn;scDeployedOn~))))
              // <=> { De Morgan }
              //     startRunningServiceComponents /\\ -(I[SvcComponent] /\\ (scImplements;scImplements~ /\\ -(scDeployedOn;scDeployedOn~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION startRunningServiceComponents [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -},EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -})),ECpl (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +})))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             startRunningServiceComponents /\\ -(I[SvcComponent] /\\ (scImplements;scImplements~ /\\ -(scDeployedOn;scDeployedOn~))) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `startRunningServiceComponents` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `startRunningServiceComponents` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (EIsc lst\'@(_:_:_))
                                                I[SvcComponent] /\\ (scImplements;scImplements~ /\\ -(scDeployedOn;scDeployedOn~)) ([SvcComponent*SvcComponent]) */
                                             SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TrgSvcComponent`
                                             FROM 
                                                  ( /* case: (ECps es), with two or more elements in es.
                                                       scImplements;scImplements~ */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                                    FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                      FROM `scImplements`
                                                      WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                           FROM `scImplements`
                                                           WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                         ) AS ECps1
                                                    WHERE ECps0.`TrgService`=ECps1.`SrcService`
                                                  ) AS isect0, ( /* I[SvcComponent] */
                                               SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                                             WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                   scDeployedOn;scDeployedOn~ */
                                                                
                                                                SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                                                FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                                  FROM `scDeployedOn`
                                                                  WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                                     
                                                                     ( /* case: EFlp x. */
                                                                       SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                                       FROM `scDeployedOn`
                                                                       WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                                     ) AS ECps1
                                                                WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                              ) AS cp
                                                         WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;startRunningServiceComponents;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'Network status integrity check' =>
        array ( 'name'          => 'Network status integrity check'
              , 'ruleAdl'       => 'routerNW~;routerNW /\\ (nwAllCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied) |- -I[Network]'
              , 'origin'        => 'line 19:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(routerNW~;routerNW /\\ (nwAllCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied) |- -I[Network])
              // <=> { remove |- }
              //     -(-(routerNW~;routerNW /\\ (nwAllCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied)) \\/ -I[Network])
              // <=> { De Morgan }
              //     routerNW~;routerNW /\\ (nwAllCompCommReqsSatisfied /\\ (nwNoCompCommReqsSatisfied /\\ I[Network]))
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EIsc (EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",EIsc (EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",EDcI Network)))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerNW~;routerNW /\\ (nwAllCompCommReqsSatisfied /\\ (nwNoCompCommReqsSatisfied /\\ I[Network])) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0, ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS isect1, ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS isect2, ( /* I[Network] */
                            SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect3
                          WHERE (isect0.`SrcNetwork` = isect1.`SrcNetwork` AND isect0.`TrgNetwork` = isect1.`TrgNetwork`) AND (isect0.`SrcNetwork` = isect2.`SrcNetwork` AND isect0.`TrgNetwork` = isect2.`TrgNetwork`) AND isect0.`SrcNetwork` = isect0.`TrgNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent network properties')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'Network status \'Green\'' =>
        array ( 'name'          => 'Network status \'Green\''
              , 'ruleAdl'       => 'I[Network] /\\ (routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied) |- nwStatus;(\'Green\'[Status];nwStatus~)'
              , 'origin'        => 'line 24:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ (routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied) |- nwStatus;(\'Green\'[Status];nwStatus~))
              // <=> { remove |- }
              //     -(-(I[Network] /\\ (routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied)) \\/ nwStatus;(\'Green\'[Status];nwStatus~))
              // <=> { De Morgan }
              //     I[Network] /\\ (routerNW~;routerNW /\\ (nwAllCompCommReqsSatisfied /\\ -(nwStatus;(\'Green\'[Status];nwStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Network,EIsc (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EIsc (EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Green" Status,EFlp (EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Network] /\\ (routerNW~;routerNW /\\ (nwAllCompCommReqsSatisfied /\\ -(nwStatus;(\'Green\'[Status];nwStatus~)))) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0, ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS isect1, ( /* I[Network] */
                            SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcNetwork` = isect1.`SrcNetwork` AND isect0.`TrgNetwork` = isect1.`TrgNetwork`) AND isect0.`SrcNetwork` = isect0.`TrgNetwork` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                nwStatus;(\'Green\'[Status];nwStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcNetwork`, ECps2.`TrgNetwork`
                                             FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwStatus` AS `TrgStatus`
                                               FROM `Network`
                                               WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Green" AS `SrcStatus`, "Green" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network` AS `TrgNetwork`, `nwStatus` AS `SrcStatus`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Network status \'Yellow\'' =>
        array ( 'name'          => 'Network status \'Yellow\''
              , 'ruleAdl'       => 'I[Network] /\\ (routerNW~;routerNW /\\ (-nwAllCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied)) |- nwStatus;(\'Yellow\'[Status];nwStatus~)'
              , 'origin'        => 'line 29:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ (routerNW~;routerNW /\\ (-nwAllCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied)) |- nwStatus;(\'Yellow\'[Status];nwStatus~))
              // <=> { remove |- }
              //     -(-(I[Network] /\\ (routerNW~;routerNW /\\ (-nwAllCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied))) \\/ nwStatus;(\'Yellow\'[Status];nwStatus~))
              // <=> { De Morgan }
              //     I[Network] /\\ (routerNW~;routerNW /\\ (-nwAllCompCommReqsSatisfied /\\ (-nwNoCompCommReqsSatisfied /\\ -(nwStatus;(\'Yellow\'[Status];nwStatus~)))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Network,EIsc (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EIsc (ECpl (EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" ""),EIsc (ECpl (EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" ""),ECpl (ECps (EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Yellow" Status,EFlp (EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" ""))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Network] /\\ (routerNW~;routerNW /\\ (-nwAllCompCommReqsSatisfied /\\ (-nwNoCompCommReqsSatisfied /\\ -(nwStatus;(\'Yellow\'[Status];nwStatus~))))) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0, ( /* I[Network] */
                            SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcNetwork` = isect0.`TrgNetwork` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                                        FROM `Network`
                                        WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                                        FROM `Network`
                                        WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                nwStatus;(\'Yellow\'[Status];nwStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcNetwork`, ECps2.`TrgNetwork`
                                             FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwStatus` AS `TrgStatus`
                                               FROM `Network`
                                               WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Yellow" AS `SrcStatus`, "Yellow" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network` AS `TrgNetwork`, `nwStatus` AS `SrcStatus`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Network status \'Red\'' =>
        array ( 'name'          => 'Network status \'Red\''
              , 'ruleAdl'       => 'I[Network] /\\ (routerNW~;routerNW /\\ nwNoCompCommReqsSatisfied) |- nwStatus;(\'Red\'[Status];nwStatus~)'
              , 'origin'        => 'line 34:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ (routerNW~;routerNW /\\ nwNoCompCommReqsSatisfied) |- nwStatus;(\'Red\'[Status];nwStatus~))
              // <=> { remove |- }
              //     -(-(I[Network] /\\ (routerNW~;routerNW /\\ nwNoCompCommReqsSatisfied)) \\/ nwStatus;(\'Red\'[Status];nwStatus~))
              // <=> { De Morgan }
              //     I[Network] /\\ (routerNW~;routerNW /\\ (nwNoCompCommReqsSatisfied /\\ -(nwStatus;(\'Red\'[Status];nwStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Network,EIsc (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EIsc (EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Red" Status,EFlp (EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Network] /\\ (routerNW~;routerNW /\\ (nwNoCompCommReqsSatisfied /\\ -(nwStatus;(\'Red\'[Status];nwStatus~)))) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0, ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS isect1, ( /* I[Network] */
                            SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcNetwork` = isect1.`SrcNetwork` AND isect0.`TrgNetwork` = isect1.`TrgNetwork`) AND isect0.`SrcNetwork` = isect0.`TrgNetwork` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                nwStatus;(\'Red\'[Status];nwStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcNetwork`, ECps2.`TrgNetwork`
                                             FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwStatus` AS `TrgStatus`
                                               FROM `Network`
                                               WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Red" AS `SrcStatus`, "Red" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network` AS `TrgNetwork`, `nwStatus` AS `SrcStatus`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Network status \'Blue\'' =>
        array ( 'name'          => 'Network status \'Blue\''
              , 'ruleAdl'       => 'I[Network] /\\ -(routerNW~;routerNW) |- nwStatus;(\'Blue\'[Status];nwStatus~)'
              , 'origin'        => 'line 39:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ -(routerNW~;routerNW) |- nwStatus;(\'Blue\'[Status];nwStatus~))
              // <=> { remove |- }
              //     -(-(I[Network] /\\ -(routerNW~;routerNW)) \\/ nwStatus;(\'Blue\'[Status];nwStatus~))
              // <=> { De Morgan }
              //     I[Network] /\\ (-(routerNW~;routerNW) /\\ -(nwStatus;(\'Blue\'[Status];nwStatus~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Network,EIsc (ECpl (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")),ECpl (ECps (EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Blue" Status,EFlp (EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Network] /\\ (-(routerNW~;routerNW) /\\ -(nwStatus;(\'Blue\'[Status];nwStatus~))) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM ( /* I[Network] */
                            SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerNW~;routerNW */
                                             
                                             SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps0,
                                                  ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps1
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                nwStatus;(\'Blue\'[Status];nwStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcNetwork`, ECps2.`TrgNetwork`
                                             FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwStatus` AS `TrgStatus`
                                               FROM `Network`
                                               WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Blue" AS `SrcStatus`, "Blue" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network` AS `TrgNetwork`, `nwStatus` AS `SrcStatus`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                 SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'Router status integrity check' =>
        array ( 'name'          => 'Router status integrity check'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied /\\ routerNoCommReqsSatisfied |- -I[Router]'
              , 'origin'        => 'line 57:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied /\\ routerNoCommReqsSatisfied |- -I[Router])
              // <=> { remove |- }
              //     -(-(routerAllCommReqsSatisfied /\\ routerNoCommReqsSatisfied) \\/ -I[Router])
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied /\\ (routerNoCommReqsSatisfied /\\ I[Router])
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",EIsc (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",EDcI Router))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerAllCommReqsSatisfied /\\ (routerNoCommReqsSatisfied /\\ I[Router]) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS isect0, ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS isect1, ( /* I[Router] */
                            SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TrgRouter` = isect1.`TrgRouter`) AND isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent router properties')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Router status \'Green\'' =>
        array ( 'name'          => 'Router status \'Green\''
              , 'ruleAdl'       => 'I[Router] /\\ (routerNW;routerNW~ /\\ routerAllCommReqsSatisfied) |- routerStatus;(\'Green\'[Status];routerStatus~)'
              , 'origin'        => 'line 62:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ (routerNW;routerNW~ /\\ routerAllCommReqsSatisfied) |- routerStatus;(\'Green\'[Status];routerStatus~))
              // <=> { remove |- }
              //     -(-(I[Router] /\\ (routerNW;routerNW~ /\\ routerAllCommReqsSatisfied)) \\/ routerStatus;(\'Green\'[Status];routerStatus~))
              // <=> { De Morgan }
              //     I[Router] /\\ (routerNW;routerNW~ /\\ (routerAllCommReqsSatisfied /\\ -(routerStatus;(\'Green\'[Status];routerStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Router,EIsc (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")),EIsc (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Green" Status,EFlp (EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Router] /\\ (routerNW;routerNW~ /\\ (routerAllCommReqsSatisfied /\\ -(routerStatus;(\'Green\'[Status];routerStatus~)))) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW;routerNW~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect0, ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS isect1, ( /* I[Router] */
                            SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TrgRouter` = isect1.`TrgRouter`) AND isect0.`SrcRouter` = isect0.`TrgRouter` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerStatus;(\'Green\'[Status];routerStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps2.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerStatus` AS `TrgStatus`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Green" AS `SrcStatus`, "Green" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerStatus` AS `SrcStatus`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Router status \'Yellow\'' =>
        array ( 'name'          => 'Router status \'Yellow\''
              , 'ruleAdl'       => 'I[Router] /\\ (routerNW;routerNW~ /\\ (-routerAllCommReqsSatisfied /\\ -routerNoCommReqsSatisfied)) |- routerStatus;(\'Yellow\'[Status];routerStatus~)'
              , 'origin'        => 'line 67:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ (routerNW;routerNW~ /\\ (-routerAllCommReqsSatisfied /\\ -routerNoCommReqsSatisfied)) |- routerStatus;(\'Yellow\'[Status];routerStatus~))
              // <=> { remove |- }
              //     -(-(I[Router] /\\ (routerNW;routerNW~ /\\ (-routerAllCommReqsSatisfied /\\ -routerNoCommReqsSatisfied))) \\/ routerStatus;(\'Yellow\'[Status];routerStatus~))
              // <=> { De Morgan }
              //     I[Router] /\\ (routerNW;routerNW~ /\\ (-routerAllCommReqsSatisfied /\\ (-routerNoCommReqsSatisfied /\\ -(routerStatus;(\'Yellow\'[Status];routerStatus~)))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Router,EIsc (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")),EIsc (ECpl (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" ""),EIsc (ECpl (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" ""),ECpl (ECps (EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Yellow" Status,EFlp (EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Router] /\\ (routerNW;routerNW~ /\\ (-routerAllCommReqsSatisfied /\\ (-routerNoCommReqsSatisfied /\\ -(routerStatus;(\'Yellow\'[Status];routerStatus~))))) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW;routerNW~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect0, ( /* I[Router] */
                            SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerStatus;(\'Yellow\'[Status];routerStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps2.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerStatus` AS `TrgStatus`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Yellow" AS `SrcStatus`, "Yellow" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerStatus` AS `SrcStatus`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Router status \'Red\'' =>
        array ( 'name'          => 'Router status \'Red\''
              , 'ruleAdl'       => 'I[Router] /\\ (routerNW;routerNW~ /\\ routerNoCommReqsSatisfied) |- routerStatus;(\'Red\'[Status];routerStatus~)'
              , 'origin'        => 'line 72:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ (routerNW;routerNW~ /\\ routerNoCommReqsSatisfied) |- routerStatus;(\'Red\'[Status];routerStatus~))
              // <=> { remove |- }
              //     -(-(I[Router] /\\ (routerNW;routerNW~ /\\ routerNoCommReqsSatisfied)) \\/ routerStatus;(\'Red\'[Status];routerStatus~))
              // <=> { De Morgan }
              //     I[Router] /\\ (routerNW;routerNW~ /\\ (routerNoCommReqsSatisfied /\\ -(routerStatus;(\'Red\'[Status];routerStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Router,EIsc (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")),EIsc (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Red" Status,EFlp (EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Router] /\\ (routerNW;routerNW~ /\\ (routerNoCommReqsSatisfied /\\ -(routerStatus;(\'Red\'[Status];routerStatus~)))) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW;routerNW~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect0, ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS isect1, ( /* I[Router] */
                            SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TrgRouter` = isect1.`TrgRouter`) AND isect0.`SrcRouter` = isect0.`TrgRouter` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerStatus;(\'Red\'[Status];routerStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps2.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerStatus` AS `TrgStatus`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Red" AS `SrcStatus`, "Red" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerStatus` AS `SrcStatus`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Router status \'Blue\'' =>
        array ( 'name'          => 'Router status \'Blue\''
              , 'ruleAdl'       => 'I[Router] /\\ -(routerNW;routerNW~) |- routerStatus;(\'Blue\'[Status];routerStatus~)'
              , 'origin'        => 'line 77:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ -(routerNW;routerNW~) |- routerStatus;(\'Blue\'[Status];routerStatus~))
              // <=> { remove |- }
              //     -(-(I[Router] /\\ -(routerNW;routerNW~)) \\/ routerStatus;(\'Blue\'[Status];routerStatus~))
              // <=> { De Morgan }
              //     I[Router] /\\ (-(routerNW;routerNW~) /\\ -(routerStatus;(\'Blue\'[Status];routerStatus~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Router,EIsc (ECpl (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""))),ECpl (ECps (EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Blue" Status,EFlp (EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Router] /\\ (-(routerNW;routerNW~) /\\ -(routerStatus;(\'Blue\'[Status];routerStatus~))) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( /* I[Router] */
                            SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerNW;routerNW~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerStatus;(\'Blue\'[Status];routerStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps2.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerStatus` AS `TrgStatus`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Blue" AS `SrcStatus`, "Blue" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerStatus` AS `SrcStatus`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'Computer status integrity check' =>
        array ( 'name'          => 'Computer status integrity check'
              , 'ruleAdl'       => 'compAllReqCommSatisfied /\\ compNoReqCommSatisfied |- -I[Computer]'
              , 'origin'        => 'line 97:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied /\\ compNoReqCommSatisfied |- -I[Computer])
              // <=> { remove |- }
              //     -(-(compAllReqCommSatisfied /\\ compNoReqCommSatisfied) \\/ -I[Computer])
              // <=> { De Morgan }
              //     compAllReqCommSatisfied /\\ (compNoReqCommSatisfied /\\ I[Computer])
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",EIsc (EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compAllReqCommSatisfied /\\ (compNoReqCommSatisfied /\\ I[Computer]) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS isect0, ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS isect1, ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TrgComputer` = isect1.`TrgComputer`) AND isect0.`SrcComputer` = isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent computer properties')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'Computer status \'Green\'' =>
        array ( 'name'          => 'Computer status \'Green\''
              , 'ruleAdl'       => 'I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ compAllReqCommSatisfied)) |- compStatus;(\'Green\'[Status];compStatus~)'
              , 'origin'        => 'line 102:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ compAllReqCommSatisfied)) |- compStatus;(\'Green\'[Status];compStatus~))
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ compAllReqCommSatisfied))) \\/ compStatus;(\'Green\'[Status];compStatus~))
              // <=> { De Morgan }
              //     I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ (compAllReqCommSatisfied /\\ -(compStatus;(\'Green\'[Status];compStatus~)))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" "",EIsc (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")),EIsc (EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) -},ECps (EMp1 "Green" Status,EFlp (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ (compAllReqCommSatisfied /\\ -(compStatus;(\'Green\'[Status];compStatus~))))) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter;compRouter~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                   FROM `compRouter`
                                   WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect1, ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS isect2, ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect3
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TrgComputer` = isect1.`TrgComputer`) AND (isect0.`SrcComputer` = isect2.`SrcComputer` AND isect0.`TrgComputer` = isect2.`TrgComputer`) AND isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compStatus;(\'Green\'[Status];compStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compStatus` AS `TrgStatus`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Green" AS `SrcStatus`, "Green" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `compStatus` AS `SrcStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Computer status \'Yellow\'' =>
        array ( 'name'          => 'Computer status \'Yellow\''
              , 'ruleAdl'       => 'I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ (-compAllReqCommSatisfied /\\ -compNoReqCommSatisfied))) |- compStatus;(\'Yellow\'[Status];compStatus~)'
              , 'origin'        => 'line 107:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ (-compAllReqCommSatisfied /\\ -compNoReqCommSatisfied))) |- compStatus;(\'Yellow\'[Status];compStatus~))
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ (-compAllReqCommSatisfied /\\ -compNoReqCommSatisfied)))) \\/ compStatus;(\'Yellow\'[Status];compStatus~))
              // <=> { De Morgan }
              //     I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ (-compAllReqCommSatisfied /\\ (-compNoReqCommSatisfied /\\ -(compStatus;(\'Yellow\'[Status];compStatus~))))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" "",EIsc (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")),EIsc (ECpl (EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" ""),EIsc (ECpl (EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (ECps (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) -},ECps (EMp1 "Yellow" Status,EFlp (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +})))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ (-compAllReqCommSatisfied /\\ (-compNoReqCommSatisfied /\\ -(compStatus;(\'Yellow\'[Status];compStatus~)))))) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter;compRouter~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                   FROM `compRouter`
                                   WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect1, ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TrgComputer` = isect1.`TrgComputer`) AND isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compStatus;(\'Yellow\'[Status];compStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compStatus` AS `TrgStatus`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Yellow" AS `SrcStatus`, "Yellow" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `compStatus` AS `SrcStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Computer status \'Red\'' =>
        array ( 'name'          => 'Computer status \'Red\''
              , 'ruleAdl'       => 'I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ compNoReqCommSatisfied)) |- compStatus;(\'Red\'[Status];compStatus~)'
              , 'origin'        => 'line 112:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ compNoReqCommSatisfied)) |- compStatus;(\'Red\'[Status];compStatus~))
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ compNoReqCommSatisfied))) \\/ compStatus;(\'Red\'[Status];compStatus~))
              // <=> { De Morgan }
              //     I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ (compNoReqCommSatisfied /\\ -(compStatus;(\'Red\'[Status];compStatus~)))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" "",EIsc (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")),EIsc (EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) -},ECps (EMp1 "Red" Status,EFlp (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (compRequiresComm /\\ (compRouter;compRouter~ /\\ (compNoReqCommSatisfied /\\ -(compStatus;(\'Red\'[Status];compStatus~))))) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter;compRouter~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                   FROM `compRouter`
                                   WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect1, ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS isect2, ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect3
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TrgComputer` = isect1.`TrgComputer`) AND (isect0.`SrcComputer` = isect2.`SrcComputer` AND isect0.`TrgComputer` = isect2.`TrgComputer`) AND isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compStatus;(\'Red\'[Status];compStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compStatus` AS `TrgStatus`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Red" AS `SrcStatus`, "Red" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `compStatus` AS `SrcStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Computer status \'Black\'' =>
        array ( 'name'          => 'Computer status \'Black\''
              , 'ruleAdl'       => 'I[Computer] /\\ (compRequiresComm /\\ -(compRouter;compRouter~)) |- compStatus;(\'Black\'[Status];compStatus~)'
              , 'origin'        => 'line 117:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ (compRequiresComm /\\ -(compRouter;compRouter~)) |- compStatus;(\'Black\'[Status];compStatus~))
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ (compRequiresComm /\\ -(compRouter;compRouter~))) \\/ compStatus;(\'Black\'[Status];compStatus~))
              // <=> { De Morgan }
              //     I[Computer] /\\ (compRequiresComm /\\ (-(compRouter;compRouter~) /\\ -(compStatus;(\'Black\'[Status];compStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" "",EIsc (ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))),ECpl (ECps (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) -},ECps (EMp1 "Black" Status,EFlp (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +})))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (compRequiresComm /\\ (-(compRouter;compRouter~) /\\ -(compStatus;(\'Black\'[Status];compStatus~)))) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS isect0, ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compRouter;compRouter~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                               FROM `compRouter`
                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                    FROM `compRouter`
                                                    WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compStatus;(\'Black\'[Status];compStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compStatus` AS `TrgStatus`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Black" AS `SrcStatus`, "Black" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `compStatus` AS `SrcStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Black')
                    )
              )
    , 'Computer status \'Blue\'' =>
        array ( 'name'          => 'Computer status \'Blue\''
              , 'ruleAdl'       => 'I[Computer] /\\ (-compRequiresComm /\\ compRouter;compRouter~) |- compStatus;(\'Blue\'[Status];compStatus~)'
              , 'origin'        => 'line 122:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ (-compRequiresComm /\\ compRouter;compRouter~) |- compStatus;(\'Blue\'[Status];compStatus~))
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ (-compRequiresComm /\\ compRouter;compRouter~)) \\/ compStatus;(\'Blue\'[Status];compStatus~))
              // <=> { De Morgan }
              //     I[Computer] /\\ (-compRequiresComm /\\ (compRouter;compRouter~ /\\ -(compStatus;(\'Blue\'[Status];compStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (ECpl (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" ""),EIsc (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")),ECpl (ECps (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) -},ECps (EMp1 "Blue" Status,EFlp (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +})))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (-compRequiresComm /\\ (compRouter;compRouter~ /\\ -(compStatus;(\'Blue\'[Status];compStatus~)))) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter;compRouter~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                   FROM `compRouter`
                                   WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0, ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compStatus;(\'Blue\'[Status];compStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compStatus` AS `TrgStatus`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Blue" AS `SrcStatus`, "Blue" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `compStatus` AS `SrcStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'Computer status \'White\'' =>
        array ( 'name'          => 'Computer status \'White\''
              , 'ruleAdl'       => 'I[Computer] /\\ (-compRequiresComm /\\ -(compRouter;compRouter~)) |- compStatus;(\'White\'[Status];compStatus~)'
              , 'origin'        => 'line 127:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ (-compRequiresComm /\\ -(compRouter;compRouter~)) |- compStatus;(\'White\'[Status];compStatus~))
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ (-compRequiresComm /\\ -(compRouter;compRouter~))) \\/ compStatus;(\'White\'[Status];compStatus~))
              // <=> { De Morgan }
              //     I[Computer] /\\ (-compRequiresComm /\\ (-(compRouter;compRouter~) /\\ -(compStatus;(\'White\'[Status];compStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,EIsc (ECpl (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" ""),EIsc (ECpl (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))),ECpl (ECps (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) -},ECps (EMp1 "White" Status,EFlp (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +})))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ (-compRequiresComm /\\ (-(compRouter;compRouter~) /\\ -(compStatus;(\'White\'[Status];compStatus~)))) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compRouter;compRouter~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                               FROM `compRouter`
                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                    FROM `compRouter`
                                                    WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compStatus;(\'White\'[Status];compStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compStatus` AS `TrgStatus`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "White" AS `SrcStatus`, "White" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `compStatus` AS `SrcStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                 SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'SvcComponent status integrity check' =>
        array ( 'name'          => 'SvcComponent status integrity check'
              , 'ruleAdl'       => 'scAllReqCommSatisfied /\\ scNoReqCommSatisfied |- -I[SvcComponent]'
              , 'origin'        => 'line 147:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scAllReqCommSatisfied /\\ scNoReqCommSatisfied |- -I[SvcComponent])
              // <=> { remove |- }
              //     -(-(scAllReqCommSatisfied /\\ scNoReqCommSatisfied) \\/ -I[SvcComponent])
              // <=> { De Morgan }
              //     scAllReqCommSatisfied /\\ (scNoReqCommSatisfied /\\ I[SvcComponent])
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EIsc (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scAllReqCommSatisfied /\\ (scNoReqCommSatisfied /\\ I[SvcComponent]) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS isect0, ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS isect1, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcSvcComponent` = isect1.`SrcSvcComponent` AND isect0.`TrgSvcComponent` = isect1.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent service component properties')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'SvcComponent status \'Green\'' =>
        array ( 'name'          => 'SvcComponent status \'Green\''
              , 'ruleAdl'       => 'I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ scAllReqCommSatisfied)) |- scStatus;(\'Green\'[Status];scStatus~)'
              , 'origin'        => 'line 152:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ scAllReqCommSatisfied)) |- scStatus;(\'Green\'[Status];scStatus~))
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ scAllReqCommSatisfied))) \\/ scStatus;(\'Green\'[Status];scStatus~))
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ (scAllReqCommSatisfied /\\ -(scStatus;(\'Green\'[Status];scStatus~)))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")),EIsc (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -})),EIsc (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) -},ECps (EMp1 "Green" Status,EFlp (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +}))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ (scAllReqCommSatisfied /\\ -(scStatus;(\'Green\'[Status];scStatus~))))) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scReqCommWith;scReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                   FROM `scReqCommWith`
                                   WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scDeployedOn;scDeployedOn~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                   FROM `scDeployedOn`
                                   WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect1, ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS isect2, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect3
                          WHERE (isect0.`SrcSvcComponent` = isect1.`SrcSvcComponent` AND isect0.`TrgSvcComponent` = isect1.`TrgSvcComponent`) AND (isect0.`SrcSvcComponent` = isect2.`SrcSvcComponent` AND isect0.`TrgSvcComponent` = isect2.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scStatus;(\'Green\'[Status];scStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scStatus` AS `TrgStatus`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Green" AS `SrcStatus`, "Green" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scStatus` AS `SrcStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'SvcComponent status \'Yellow\'' =>
        array ( 'name'          => 'SvcComponent status \'Yellow\''
              , 'ruleAdl'       => 'I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ (-scAllReqCommSatisfied /\\ -scNoReqCommSatisfied))) |- scStatus;(\'Yellow\'[Status];scStatus~)'
              , 'origin'        => 'line 157:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ (-scAllReqCommSatisfied /\\ -scNoReqCommSatisfied))) |- scStatus;(\'Yellow\'[Status];scStatus~))
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ (-scAllReqCommSatisfied /\\ -scNoReqCommSatisfied)))) \\/ scStatus;(\'Yellow\'[Status];scStatus~))
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ (-scAllReqCommSatisfied /\\ (-scNoReqCommSatisfied /\\ -(scStatus;(\'Yellow\'[Status];scStatus~))))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")),EIsc (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -})),EIsc (ECpl (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""),EIsc (ECpl (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""),ECpl (ECps (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) -},ECps (EMp1 "Yellow" Status,EFlp (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +})))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ (-scAllReqCommSatisfied /\\ (-scNoReqCommSatisfied /\\ -(scStatus;(\'Yellow\'[Status];scStatus~)))))) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scReqCommWith;scReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                   FROM `scReqCommWith`
                                   WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scDeployedOn;scDeployedOn~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                   FROM `scDeployedOn`
                                   WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect1, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcSvcComponent` = isect1.`SrcSvcComponent` AND isect0.`TrgSvcComponent` = isect1.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scStatus;(\'Yellow\'[Status];scStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scStatus` AS `TrgStatus`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Yellow" AS `SrcStatus`, "Yellow" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scStatus` AS `SrcStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'SvcComponent status \'Red\'' =>
        array ( 'name'          => 'SvcComponent status \'Red\''
              , 'ruleAdl'       => 'I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ scNoReqCommSatisfied)) |- scStatus;(\'Red\'[Status];scStatus~)'
              , 'origin'        => 'line 162:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ scNoReqCommSatisfied)) |- scStatus;(\'Red\'[Status];scStatus~))
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ scNoReqCommSatisfied))) \\/ scStatus;(\'Red\'[Status];scStatus~))
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ (scNoReqCommSatisfied /\\ -(scStatus;(\'Red\'[Status];scStatus~)))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")),EIsc (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -})),EIsc (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) -},ECps (EMp1 "Red" Status,EFlp (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +}))))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (scDeployedOn;scDeployedOn~ /\\ (scNoReqCommSatisfied /\\ -(scStatus;(\'Red\'[Status];scStatus~))))) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scReqCommWith;scReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                   FROM `scReqCommWith`
                                   WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scDeployedOn;scDeployedOn~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                   FROM `scDeployedOn`
                                   WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect1, ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS isect2, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect3
                          WHERE (isect0.`SrcSvcComponent` = isect1.`SrcSvcComponent` AND isect0.`TrgSvcComponent` = isect1.`TrgSvcComponent`) AND (isect0.`SrcSvcComponent` = isect2.`SrcSvcComponent` AND isect0.`TrgSvcComponent` = isect2.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scStatus;(\'Red\'[Status];scStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scStatus` AS `TrgStatus`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Red" AS `SrcStatus`, "Red" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scStatus` AS `SrcStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'SvcComponent status \'Black\'' =>
        array ( 'name'          => 'SvcComponent status \'Black\''
              , 'ruleAdl'       => 'I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scDeployedOn;scDeployedOn~)) |- scStatus;(\'Black\'[Status];scStatus~)'
              , 'origin'        => 'line 167:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scDeployedOn;scDeployedOn~)) |- scStatus;(\'Black\'[Status];scStatus~))
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ -(scDeployedOn;scDeployedOn~))) \\/ scStatus;(\'Black\'[Status];scStatus~))
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (-(scDeployedOn;scDeployedOn~) /\\ -(scStatus;(\'Black\'[Status];scStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")),EIsc (ECpl (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -}))),ECpl (ECps (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) -},ECps (EMp1 "Black" Status,EFlp (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +})))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (scReqCommWith;scReqCommWith~ /\\ (-(scDeployedOn;scDeployedOn~) /\\ -(scStatus;(\'Black\'[Status];scStatus~)))) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scReqCommWith;scReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                   FROM `scReqCommWith`
                                   WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scDeployedOn;scDeployedOn~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                               FROM `scDeployedOn`
                                               WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scStatus;(\'Black\'[Status];scStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scStatus` AS `TrgStatus`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Black" AS `SrcStatus`, "Black" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scStatus` AS `SrcStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Black')
                    )
              )
    , 'SvcComponent status \'Blue\'' =>
        array ( 'name'          => 'SvcComponent status \'Blue\''
              , 'ruleAdl'       => 'I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ scDeployedOn;scDeployedOn~) |- scStatus;(\'Blue\'[Status];scStatus~)'
              , 'origin'        => 'line 172:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ scDeployedOn;scDeployedOn~) |- scStatus;(\'Blue\'[Status];scStatus~))
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ scDeployedOn;scDeployedOn~)) \\/ scStatus;(\'Blue\'[Status];scStatus~))
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ (scDeployedOn;scDeployedOn~ /\\ -(scStatus;(\'Blue\'[Status];scStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECpl (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""))),EIsc (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -})),ECpl (ECps (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) -},ECps (EMp1 "Blue" Status,EFlp (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +})))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ (scDeployedOn;scDeployedOn~ /\\ -(scStatus;(\'Blue\'[Status];scStatus~)))) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scDeployedOn;scDeployedOn~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                   FROM `scDeployedOn`
                                   WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scReqCommWith;scReqCommWith~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                               FROM `scReqCommWith`
                                               WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                                    FROM `scReqCommWith`
                                                    WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scStatus;(\'Blue\'[Status];scStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scStatus` AS `TrgStatus`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Blue" AS `SrcStatus`, "Blue" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scStatus` AS `SrcStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'SvcComponent status \'White\'' =>
        array ( 'name'          => 'SvcComponent status \'White\''
              , 'ruleAdl'       => 'I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ -(scDeployedOn;scDeployedOn~)) |- scStatus;(\'White\'[Status];scStatus~)'
              , 'origin'        => 'line 177:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ -(scDeployedOn;scDeployedOn~)) |- scStatus;(\'White\'[Status];scStatus~))
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ -(scDeployedOn;scDeployedOn~))) \\/ scStatus;(\'White\'[Status];scStatus~))
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ (-(scDeployedOn;scDeployedOn~) /\\ -(scStatus;(\'White\'[Status];scStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECpl (ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""))),EIsc (ECpl (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -},EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer -}))),ECpl (ECps (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) -},ECps (EMp1 "White" Status,EFlp (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +})))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (-(scReqCommWith;scReqCommWith~) /\\ (-(scDeployedOn;scDeployedOn~) /\\ -(scStatus;(\'White\'[Status];scStatus~)))) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scReqCommWith;scReqCommWith~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                               FROM `scReqCommWith`
                                               WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                                    FROM `scReqCommWith`
                                                    WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scDeployedOn;scDeployedOn~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                               FROM `scDeployedOn`
                                               WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scStatus;(\'White\'[Status];scStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps2.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scStatus` AS `TrgStatus`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "White" AS `SrcStatus`, "White" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scStatus` AS `SrcStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'Service status integrity check' =>
        array ( 'name'          => 'Service status integrity check'
              , 'ruleAdl'       => 'svcAllSvcCompReqsSatisfied /\\ svcNoSvcCompReqsSatisfied |- -I[Service]'
              , 'origin'        => 'line 194:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcAllSvcCompReqsSatisfied /\\ svcNoSvcCompReqsSatisfied |- -I[Service])
              // <=> { remove |- }
              //     -(-(svcAllSvcCompReqsSatisfied /\\ svcNoSvcCompReqsSatisfied) \\/ -I[Service])
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied /\\ (svcNoSvcCompReqsSatisfied /\\ I[Service])
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",EIsc (EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",EDcI Service))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcAllSvcCompReqsSatisfied /\\ (svcNoSvcCompReqsSatisfied /\\ I[Service]) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS isect0, ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS isect1, ( /* I[Service] */
                            SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect2
                          WHERE (isect0.`SrcService` = isect1.`SrcService` AND isect0.`TrgService` = isect1.`TrgService`) AND isect0.`SrcService` = isect0.`TrgService` AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent service properties for ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '(')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ')')
                    )
              )
    , 'Service status \'Green\'' =>
        array ( 'name'          => 'Service status \'Green\''
              , 'ruleAdl'       => 'I[Service] /\\ svcAllSvcCompReqsSatisfied |- svcStatus;(\'Green\'[Status];svcStatus~)'
              , 'origin'        => 'line 199:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(I[Service] /\\ svcAllSvcCompReqsSatisfied |- svcStatus;(\'Green\'[Status];svcStatus~))
              // <=> { remove |- }
              //     -(-(I[Service] /\\ svcAllSvcCompReqsSatisfied) \\/ svcStatus;(\'Green\'[Status];svcStatus~))
              // <=> { De Morgan }
              //     I[Service] /\\ (svcAllSvcCompReqsSatisfied /\\ -(svcStatus;(\'Green\'[Status];svcStatus~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Service,EIsc (EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Green" Status,EFlp (EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Service] /\\ (svcAllSvcCompReqsSatisfied /\\ -(svcStatus;(\'Green\'[Status];svcStatus~))) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS isect0, ( /* I[Service] */
                            SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcService` = isect0.`TrgService` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                svcStatus;(\'Green\'[Status];svcStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcService`, ECps2.`TrgService`
                                             FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcStatus` AS `TrgStatus`
                                               FROM `Service`
                                               WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Green" AS `SrcStatus`, "Green" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Service` AS `TrgService`, `svcStatus` AS `SrcStatus`
                                                    FROM `Service`
                                                    WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcStatus;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Service status \'Yellow\'' =>
        array ( 'name'          => 'Service status \'Yellow\''
              , 'ruleAdl'       => 'I[Service] /\\ (-svcAllSvcCompReqsSatisfied /\\ -svcNoSvcCompReqsSatisfied) |- svcStatus;(\'Yellow\'[Status];svcStatus~)'
              , 'origin'        => 'line 204:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(I[Service] /\\ (-svcAllSvcCompReqsSatisfied /\\ -svcNoSvcCompReqsSatisfied) |- svcStatus;(\'Yellow\'[Status];svcStatus~))
              // <=> { remove |- }
              //     -(-(I[Service] /\\ (-svcAllSvcCompReqsSatisfied /\\ -svcNoSvcCompReqsSatisfied)) \\/ svcStatus;(\'Yellow\'[Status];svcStatus~))
              // <=> { De Morgan }
              //     I[Service] /\\ (-svcAllSvcCompReqsSatisfied /\\ (-svcNoSvcCompReqsSatisfied /\\ -(svcStatus;(\'Yellow\'[Status];svcStatus~))))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Service,EIsc (ECpl (EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" ""),EIsc (ECpl (EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" ""),ECpl (ECps (EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Yellow" Status,EFlp (EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" "")))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Service] /\\ (-svcAllSvcCompReqsSatisfied /\\ (-svcNoSvcCompReqsSatisfied /\\ -(svcStatus;(\'Yellow\'[Status];svcStatus~)))) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM ( /* I[Service] */
                            SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                                        FROM `Service`
                                        WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                                        FROM `Service`
                                        WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                svcStatus;(\'Yellow\'[Status];svcStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcService`, ECps2.`TrgService`
                                             FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcStatus` AS `TrgStatus`
                                               FROM `Service`
                                               WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Yellow" AS `SrcStatus`, "Yellow" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Service` AS `TrgService`, `svcStatus` AS `SrcStatus`
                                                    FROM `Service`
                                                    WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcStatus;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Service status \'Red\'' =>
        array ( 'name'          => 'Service status \'Red\''
              , 'ruleAdl'       => 'I[Service] /\\ svcNoSvcCompReqsSatisfied |- svcStatus;(\'Red\'[Status];svcStatus~)'
              , 'origin'        => 'line 209:1, file ".\\\\..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(I[Service] /\\ svcNoSvcCompReqsSatisfied |- svcStatus;(\'Red\'[Status];svcStatus~))
              // <=> { remove |- }
              //     -(-(I[Service] /\\ svcNoSvcCompReqsSatisfied) \\/ svcStatus;(\'Red\'[Status];svcStatus~))
              // <=> { De Morgan }
              //     I[Service] /\\ (svcNoSvcCompReqsSatisfied /\\ -(svcStatus;(\'Red\'[Status];svcStatus~)))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Service,EIsc (EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",ECpl (ECps (EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" "",ECps (EMp1 "Red" Status,EFlp (EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" ""))))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Service] /\\ (svcNoSvcCompReqsSatisfied /\\ -(svcStatus;(\'Red\'[Status];svcStatus~))) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS isect0, ( /* I[Service] */
                            SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcService` = isect0.`TrgService` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                svcStatus;(\'Red\'[Status];svcStatus~) */
                                             
                                             SELECT DISTINCT ECps0.`SrcService`, ECps2.`TrgService`
                                             FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcStatus` AS `TrgStatus`
                                               FROM `Service`
                                               WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EMp1 atom. */
                                                    SELECT "Red" AS `SrcStatus`, "Red" AS `TrgStatus`
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Service` AS `TrgService`, `svcStatus` AS `SrcStatus`
                                                    FROM `Service`
                                                    WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`TrgStatus`=ECps1.`SrcStatus`
                                               AND ECps1.`TrgStatus`=ECps2.`SrcStatus`
                                           ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcStatus;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                 SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Yes/No answer integrity' =>
        array ( 'name'          => 'Yes/No answer integrity'
              , 'ruleAdl'       => 'I[Yes/No answer] |- \'Yes\'[Yes/No answer] \\/ \'No\'[Yes/No answer]'
              , 'origin'        => 'line 31:1, file "CSA_Op.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Yes/No answer'
              , 'tgtConcept'    => 'Yes/No answer'
              // Normalization steps:
              //     -(I[Yes/No answer] |- \'Yes\'[Yes/No answer] \\/ \'No\'[Yes/No answer])
              // <=> { remove |- }
              //     -(-I[Yes/No answer] \\/ (\'Yes\'[Yes/No answer] \\/ \'No\'[Yes/No answer]))
              // <=> { De Morgan }
              //     I[Yes/No answer] /\\ (-\'Yes\'[Yes/No answer] /\\ -\'No\'[Yes/No answer])
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Yes/No answer,EIsc (ECpl (EMp1 "Yes" Yes/No answer),ECpl (EMp1 "No" Yes/No answer)))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Yes/No answer] /\\ (-\'Yes\'[Yes/No answer] /\\ -\'No\'[Yes/No answer]) ([Yes/No answer*Yes/No answer]) */
                          SELECT DISTINCT isect0.`SrcYes/No answer` AS src, isect0.`TrgYes/No answer` AS tgt
                          FROM ( /* I[Yes/No answer] */
                            SELECT DISTINCT `Yes/No answer` AS `SrcYes/No answer`, `Yes/No answer` AS `TrgYes/No answer`
                            FROM `Yes/No answer`
                            WHERE `Yes/No answer` IS NOT NULL AND `Yes/No answer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: EMp1 atom. */
                                             SELECT "Yes" AS `SrcYes/No answer`, "Yes" AS `TrgYes/No answer`
                                           ) AS cp
                                      WHERE isect0.`SrcYes/No answer`=cp.`SrcYes/No answer` AND isect0.`TrgYes/No answer`=cp.`TrgYes/No answer`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: EMp1 atom. */
                                             SELECT "No" AS `SrcYes/No answer`, "No" AS `TrgYes/No answer`
                                           ) AS cp
                                      WHERE isect0.`SrcYes/No answer`=cp.`SrcYes/No answer` AND isect0.`TrgYes/No answer`=cp.`TrgYes/No answer`) AND isect0.`SrcYes/No answer` IS NOT NULL AND isect0.`TrgYes/No answer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Activity executor must exist' =>
        array ( 'name'          => 'Activity executor must exist'
              , 'ruleAdl'       => 'I[Activity] |- actExecutingOU;actExecutingOU~'
              , 'origin'        => 'line 41:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] |- actExecutingOU;actExecutingOU~)
              // <=> { remove |- }
              //     -(-I[Activity] \\/ actExecutingOU;actExecutingOU~)
              // <=> { De Morgan }
              //     I[Activity] /\\ -(actExecutingOU;actExecutingOU~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Activity,ECpl (ECps (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -},EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Activity] /\\ -(actExecutingOU;actExecutingOU~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgActivity` AS tgt
                          FROM ( /* I[Activity] */
                            SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                            FROM `Activity`
                            WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actExecutingOU;actExecutingOU~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actExecutingOU` AS `TrgOrgUnit`
                                               FROM `Activity`
                                               WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Activity plan must exist' =>
        array ( 'name'          => 'Activity plan must exist'
              , 'ruleAdl'       => 'I[Activity] |- actPlan;actPlan~'
              , 'origin'        => 'line 46:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] |- actPlan;actPlan~)
              // <=> { remove |- }
              //     -(-I[Activity] \\/ actPlan;actPlan~)
              // <=> { De Morgan }
              //     I[Activity] /\\ -(actPlan;actPlan~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Activity,ECpl (ECps (EDcD RELATION actPlan [Activity*Plan] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is according to the plan -},EFlp (EDcD RELATION actPlan [Activity*Plan] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is according to the plan +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Activity] /\\ -(actPlan;actPlan~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgActivity` AS tgt
                          FROM ( /* I[Activity] */
                            SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                            FROM `Activity`
                            WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actPlan;actPlan~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actPlan` AS `TrgPlan`
                                               FROM `Activity`
                                               WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlan` AS `SrcPlan`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgPlan`=ECps1.`SrcPlan`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Router naming integrity' =>
        array ( 'name'          => 'Router naming integrity'
              , 'ruleAdl'       => 'routerName~;routerName |- I[RouterName]'
              , 'origin'        => 'line 36:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'RouterName'
              , 'tgtConcept'    => 'RouterName'
              // Normalization steps:
              //     -(routerName~;routerName |- I[RouterName])
              // <=> { remove |- }
              //     -(-(routerName~;routerName) \\/ I[RouterName])
              // <=> { De Morgan }
              //     routerName~;routerName /\\ -I[RouterName]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION routerName [Router*RouterName] Nothing PRAGMA "" "" ""),EDcD RELATION routerName [Router*RouterName] Nothing PRAGMA "" "" ""),ECpl (EDcI RouterName))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerName~;routerName /\\ -I[RouterName] ([RouterName*RouterName]) */
                          SELECT DISTINCT isect0.`SrcRouterName` AS src, isect0.`TrgRouterName` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerName~;routerName */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouterName`, ECps1.`TrgRouterName`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerName` AS `SrcRouterName`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerName` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerName` AS `TrgRouterName`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerName` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE isect0.`SrcRouterName` <> isect0.`TrgRouterName` AND isect0.`SrcRouterName` IS NOT NULL AND isect0.`TrgRouterName` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'There is already an router called \'')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'RouterName'
                            , 'expSQL' =>
                                '/* I[RouterName] */
                                 SELECT DISTINCT `RouterName` AS src, `RouterName` AS tgt
                                 FROM `RouterName`
                                 WHERE `RouterName` IS NOT NULL AND `RouterName` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '\'; please choose another name.')
                    )
              )
    , 'Router network integrity' =>
        array ( 'name'          => 'Router network integrity'
              , 'ruleAdl'       => 'I[Router] /\\ rrtDirect;rrtDirect~ |- routerNW;routerNW~'
              , 'origin'        => 'line 40:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ rrtDirect;rrtDirect~ |- routerNW;routerNW~)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ rrtDirect;rrtDirect~) \\/ routerNW;routerNW~)
              // <=> { De Morgan }
              //     I[Router] /\\ (rrtDirect;rrtDirect~ /\\ -(routerNW;routerNW~))
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Router,EIsc (ECps (EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" "")),ECpl (ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Router] /\\ (rrtDirect;rrtDirect~ /\\ -(routerNW;routerNW~)) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    rrtDirect;rrtDirect~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                   FROM `rrtDirect`
                                   WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sRouter` AS `TrgRouter`, `tRouter` AS `SrcRouter`
                                        FROM `rrtDirect`
                                        WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0, ( /* I[Router] */
                            SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerNW;routerNW~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Router ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                 SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is not part of a network, and hence may not have routes.')
                    )
              )
    , 'Computer naming integrity' =>
        array ( 'name'          => 'Computer naming integrity'
              , 'ruleAdl'       => 'compName~;compName |- I[ComputerName]'
              , 'origin'        => 'line 59:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ComputerName'
              , 'tgtConcept'    => 'ComputerName'
              // Normalization steps:
              //     -(compName~;compName |- I[ComputerName])
              // <=> { remove |- }
              //     -(-(compName~;compName) \\/ I[ComputerName])
              // <=> { De Morgan }
              //     compName~;compName /\\ -I[ComputerName]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION compName [Computer*ComputerName] Nothing PRAGMA "" "" ""),EDcD RELATION compName [Computer*ComputerName] Nothing PRAGMA "" "" ""),ECpl (EDcI ComputerName))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compName~;compName /\\ -I[ComputerName] ([ComputerName*ComputerName]) */
                          SELECT DISTINCT isect0.`SrcComputerName` AS src, isect0.`TrgComputerName` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compName~;compName */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputerName`, ECps1.`TrgComputerName`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `compName` AS `SrcComputerName`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compName` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compName` AS `TrgComputerName`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compName` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputerName` <> isect0.`TrgComputerName` AND isect0.`SrcComputerName` IS NOT NULL AND isect0.`TrgComputerName` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'There is already an computer called \'')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ComputerName'
                            , 'expSQL' =>
                                '/* I[ComputerName] */
                                 SELECT DISTINCT `ComputerName` AS src, `ComputerName` AS tgt
                                 FROM `ComputerName`
                                 WHERE `ComputerName` IS NOT NULL AND `ComputerName` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '\'; please choose another name.')
                    )
              )
    , 'Service - component integrity' =>
        array ( 'name'          => 'Service - component integrity'
              , 'ruleAdl'       => 'I[SvcComponent] /\\ -(scImplements;scImplements~) |- -(scReqCommWith;scReqCommWith~)'
              , 'origin'        => 'line 86:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] /\\ -(scImplements;scImplements~) |- -(scReqCommWith;scReqCommWith~))
              // <=> { remove |- }
              //     -(-(I[SvcComponent] /\\ -(scImplements;scImplements~)) \\/ -(scReqCommWith;scReqCommWith~))
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ (-(scImplements;scImplements~) /\\ scReqCommWith;scReqCommWith~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,EIsc (ECpl (ECps (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -},EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +}))),ECps (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ (-(scImplements;scImplements~) /\\ scReqCommWith;scReqCommWith~) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scReqCommWith;scReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `sSvcComponent` AS `SrcSvcComponent`, `tSvcComponent` AS `TrgSvcComponent`
                                   FROM `scReqCommWith`
                                   WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent` AS `TrgSvcComponent`, `tSvcComponent` AS `SrcSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0, ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                          WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scImplements;scImplements~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                               FROM `scImplements`
                                               WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                    FROM `scImplements`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgService`=ECps1.`SrcService`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'SvcComponent ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                 SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is not part of a service, and hence may not send messages.')
                    )
              )
    , 'SvcComponent naming integrity' =>
        array ( 'name'          => 'SvcComponent naming integrity'
              , 'ruleAdl'       => 'scName~;scName |- I[SvcComponentName]'
              , 'origin'        => 'line 90:1, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponentName'
              , 'tgtConcept'    => 'SvcComponentName'
              // Normalization steps:
              //     -(scName~;scName |- I[SvcComponentName])
              // <=> { remove |- }
              //     -(-(scName~;scName) \\/ I[SvcComponentName])
              // <=> { De Morgan }
              //     scName~;scName /\\ -I[SvcComponentName]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION scName [SvcComponent*SvcComponentName] Nothing PRAGMA "" "" ""),EDcD RELATION scName [SvcComponent*SvcComponentName] Nothing PRAGMA "" "" ""),ECpl (EDcI SvcComponentName))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scName~;scName /\\ -I[SvcComponentName] ([SvcComponentName*SvcComponentName]) */
                          SELECT DISTINCT isect0.`SrcSvcComponentName` AS src, isect0.`TrgSvcComponentName` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scName~;scName */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponentName`, ECps1.`TrgSvcComponentName`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scName` AS `SrcSvcComponentName`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scName` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scName` AS `TrgSvcComponentName`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scName` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcSvcComponentName` <> isect0.`TrgSvcComponentName` AND isect0.`SrcSvcComponentName` IS NOT NULL AND isect0.`TrgSvcComponentName` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'There is already a service component called \'')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponentName'
                            , 'expSQL' =>
                                '/* I[SvcComponentName] */
                                 SELECT DISTINCT `SvcComponentName` AS src, `SvcComponentName` AS tgt
                                 FROM `SvcComponentName`
                                 WHERE `SvcComponentName` IS NOT NULL AND `SvcComponentName` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '\'; please choose another name.')
                    )
              )
    , 'UNI planCmpStat::Plan*Status' =>
        array ( 'name'          => 'UNI planCmpStat::Plan*Status'
              , 'ruleAdl'       => 'planCmpStat~;planCmpStat |- I[Status]'
              , 'origin'        => 'line 25:13, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'planCmpStat[Plan\\*Status] is univalent'
              , 'message'       => 'planCmpStat[Plan\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(planCmpStat~;planCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(planCmpStat~;planCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     planCmpStat~;planCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION planCmpStat [Plan*Status] Nothing PRAGMA "" "" ""),EDcD RELATION planCmpStat [Plan*Status] Nothing PRAGMA "" "" ""),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             planCmpStat~;planCmpStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    planCmpStat~;planCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan` AS `TrgPlan`, `planCmpStat` AS `SrcStatus`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planCmpStat` AS `TrgStatus`
                                   FROM `Plan`
                                   WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgPlan`=ECps1.`SrcPlan`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM atStatusIsGreen::ActivityType*ActivityType' =>
        array ( 'name'          => 'SYM atStatusIsGreen::ActivityType*ActivityType'
              , 'ruleAdl'       => 'atStatusIsGreen = atStatusIsGreen~'
              , 'origin'        => 'line 43:17, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'atStatusIsGreen[ActivityType] is symmetrisch.'
              , 'message'       => 'atStatusIsGreen[ActivityType] is niet symmetrisch.'
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(atStatusIsGreen = atStatusIsGreen~)
              // <=> { remove = }
              //     -((atStatusIsGreen |- atStatusIsGreen~) /\\ (atStatusIsGreen~ |- atStatusIsGreen))
              // <=> { remove |- and remove |- }
              //     -((-atStatusIsGreen \\/ atStatusIsGreen~) /\\ (-atStatusIsGreen~ \\/ atStatusIsGreen))
              // <=> { atStatusIsGreen is symmetric and atStatusIsGreen is symmetric }
              //     -((-atStatusIsGreen \\/ atStatusIsGreen) /\\ (-atStatusIsGreen \\/ atStatusIsGreen))
              // <=> { -atStatusIsGreen \\/ atStatusIsGreen /\\ -atStatusIsGreen \\/ atStatusIsGreen = -atStatusIsGreen \\/ atStatusIsGreen }
              //     -(-atStatusIsGreen \\/ atStatusIsGreen)
              // <=> { De Morgan }
              //     atStatusIsGreen /\\ -atStatusIsGreen
              // <=> { atStatusIsGreen /\\ -atStatusIsGreen = V- }
              //     -V[ActivityType*ActivityType]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [ActivityType*ActivityType])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [ActivityType*ActivityType] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY atStatusIsGreen::ActivityType*ActivityType' =>
        array ( 'name'          => 'ASY atStatusIsGreen::ActivityType*ActivityType'
              , 'ruleAdl'       => 'atStatusIsGreen~ /\\ atStatusIsGreen |- I[ActivityType]'
              , 'origin'        => 'line 43:17, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'atStatusIsGreen[ActivityType] is antisymmetrisch.'
              , 'message'       => 'atStatusIsGreen[ActivityType] is niet antisymmetrisch.'
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(atStatusIsGreen~ /\\ atStatusIsGreen |- I[ActivityType])
              // <=> { remove |- }
              //     -(-(atStatusIsGreen~ /\\ atStatusIsGreen) \\/ I[ActivityType])
              // <=> { De Morgan }
              //     atStatusIsGreen~ /\\ (atStatusIsGreen /\\ -I[ActivityType])
              // <=> { atStatusIsGreen is symmetric }
              //     atStatusIsGreen /\\ (atStatusIsGreen /\\ -I[ActivityType])
              // <=> { atStatusIsGreen /\\ atStatusIsGreen = atStatusIsGreen }
              //     atStatusIsGreen /\\ -I[ActivityType]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" "",ECpl (EDcI ActivityType))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             atStatusIsGreen /\\ -I[ActivityType] ([ActivityType*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcActivityType` AS src, isect0.`TrgActivityType` AS tgt
                          FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                            FROM `ActivityType`
                            WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcActivityType` <> isect0.`TrgActivityType` AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI atStatusIsGreen::ActivityType*ActivityType' =>
        array ( 'name'          => 'UNI atStatusIsGreen::ActivityType*ActivityType'
              , 'ruleAdl'       => 'atStatusIsGreen~;atStatusIsGreen |- I[ActivityType]'
              , 'origin'        => 'line 43:17, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'atStatusIsGreen[ActivityType\\*ActivityType] is univalent'
              , 'message'       => 'atStatusIsGreen[ActivityType\\*ActivityType] is niet univalent'
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(atStatusIsGreen~;atStatusIsGreen |- I[ActivityType])
              // <=> { remove |- }
              //     -(-(atStatusIsGreen~;atStatusIsGreen) \\/ I[ActivityType])
              // <=> { De Morgan }
              //     atStatusIsGreen~;atStatusIsGreen /\\ -I[ActivityType]
              // <=> { atStatusIsGreen is symmetric }
              //     atStatusIsGreen;atStatusIsGreen /\\ -I[ActivityType]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" "",EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" ""),ECpl (EDcI ActivityType))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             atStatusIsGreen;atStatusIsGreen /\\ -I[ActivityType] ([ActivityType*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcActivityType` AS src, isect0.`TrgActivityType` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    atStatusIsGreen;atStatusIsGreen */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                 FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                   FROM `ActivityType`
                                   WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                   FROM `ActivityType`
                                   WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                               ) AS isect0
                          WHERE isect0.`SrcActivityType` <> isect0.`TrgActivityType` AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ atStatusIsGreen::ActivityType*ActivityType' =>
        array ( 'name'          => 'INJ atStatusIsGreen::ActivityType*ActivityType'
              , 'ruleAdl'       => 'atStatusIsGreen;atStatusIsGreen~ |- I[ActivityType]'
              , 'origin'        => 'line 43:17, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'atStatusIsGreen[ActivityType\\*ActivityType] is injectief'
              , 'message'       => 'atStatusIsGreen[ActivityType\\*ActivityType] is niet injectief'
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(atStatusIsGreen;atStatusIsGreen~ |- I[ActivityType])
              // <=> { remove |- }
              //     -(-(atStatusIsGreen;atStatusIsGreen~) \\/ I[ActivityType])
              // <=> { De Morgan }
              //     atStatusIsGreen;atStatusIsGreen~ /\\ -I[ActivityType]
              // <=> { atStatusIsGreen is symmetric }
              //     atStatusIsGreen;atStatusIsGreen /\\ -I[ActivityType]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" "",EDcD RELATION atStatusIsGreen [ActivityType*ActivityType] Nothing PRAGMA "" "" ""),ECpl (EDcI ActivityType))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             atStatusIsGreen;atStatusIsGreen /\\ -I[ActivityType] ([ActivityType*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcActivityType` AS src, isect0.`TrgActivityType` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    atStatusIsGreen;atStatusIsGreen */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                 FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                   FROM `ActivityType`
                                   WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatusIsGreen` AS `TrgActivityType`
                                   FROM `ActivityType`
                                   WHERE `ActivityType` IS NOT NULL AND `atStatusIsGreen` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                               ) AS isect0
                          WHERE isect0.`SrcActivityType` <> isect0.`TrgActivityType` AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actCmpStat::Activity*Status' =>
        array ( 'name'          => 'UNI actCmpStat::Activity*Status'
              , 'ruleAdl'       => 'actCmpStat~;actCmpStat |- I[Status]'
              , 'origin'        => 'line 97:12, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'actCmpStat[Activity\\*Status] is univalent'
              , 'message'       => 'actCmpStat[Activity\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(actCmpStat~;actCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(actCmpStat~;actCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     actCmpStat~;actCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actCmpStat [Activity*Status] Nothing PRAGMA "" "" ""),EDcD RELATION actCmpStat [Activity*Status] Nothing PRAGMA "" "" ""),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actCmpStat~;actCmpStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actCmpStat~;actCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actCmpStat` AS `SrcStatus`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actCmpStat` AS `TrgStatus`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI ouCmpStat::OrgUnit*Status' =>
        array ( 'name'          => 'UNI ouCmpStat::OrgUnit*Status'
              , 'ruleAdl'       => 'ouCmpStat~;ouCmpStat |- I[Status]'
              , 'origin'        => 'line 106:11, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'ouCmpStat[OrgUnit\\*Status] is univalent'
              , 'message'       => 'ouCmpStat[OrgUnit\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(ouCmpStat~;ouCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(ouCmpStat~;ouCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     ouCmpStat~;ouCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION ouCmpStat [OrgUnit*Status] Nothing PRAGMA "" "" ""),EDcD RELATION ouCmpStat [OrgUnit*Status] Nothing PRAGMA "" "" ""),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             ouCmpStat~;ouCmpStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ouCmpStat~;ouCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `ouCmpStat` AS `SrcStatus`
                                        FROM `OrgUnit`
                                        WHERE `OrgUnit` IS NOT NULL AND `ouCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ouCmpStat` AS `TrgStatus`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL AND `ouCmpStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scCmpStat::SvcComponent*Status' =>
        array ( 'name'          => 'UNI scCmpStat::SvcComponent*Status'
              , 'ruleAdl'       => 'scCmpStat~;scCmpStat |- I[Status]'
              , 'origin'        => 'line 115:11, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'scCmpStat[SvcComponent\\*Status] is univalent'
              , 'message'       => 'scCmpStat[SvcComponent\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(scCmpStat~;scCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(scCmpStat~;scCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     scCmpStat~;scCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION scCmpStat [SvcComponent*Status] Nothing PRAGMA "" "" ""),EDcD RELATION scCmpStat [SvcComponent*Status] Nothing PRAGMA "" "" ""),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scCmpStat~;scCmpStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scCmpStat~;scCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scCmpStat` AS `SrcStatus`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scCmpStat` AS `TrgStatus`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scCmpStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compCmpStat::Computer*Status' =>
        array ( 'name'          => 'UNI compCmpStat::Computer*Status'
              , 'ruleAdl'       => 'compCmpStat~;compCmpStat |- I[Status]'
              , 'origin'        => 'line 124:13, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'compCmpStat[Computer\\*Status] is univalent'
              , 'message'       => 'compCmpStat[Computer\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(compCmpStat~;compCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(compCmpStat~;compCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     compCmpStat~;compCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION compCmpStat [Computer*Status] Nothing PRAGMA "" "" ""),EDcD RELATION compCmpStat [Computer*Status] Nothing PRAGMA "" "" ""),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compCmpStat~;compCmpStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compCmpStat~;compCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `compCmpStat` AS `SrcStatus`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compCmpStat` AS `TrgStatus`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compCmpStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM nwAllCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'SYM nwAllCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied = nwAllCompCommReqsSatisfied~'
              , 'origin'        => 'line 27:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'nwAllCompCommReqsSatisfied[Network] is symmetrisch.'
              , 'message'       => 'nwAllCompCommReqsSatisfied[Network] is niet symmetrisch.'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied = nwAllCompCommReqsSatisfied~)
              // <=> { remove = }
              //     -((nwAllCompCommReqsSatisfied |- nwAllCompCommReqsSatisfied~) /\\ (nwAllCompCommReqsSatisfied~ |- nwAllCompCommReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied~) /\\ (-nwAllCompCommReqsSatisfied~ \\/ nwAllCompCommReqsSatisfied))
              // <=> { nwAllCompCommReqsSatisfied is symmetric and nwAllCompCommReqsSatisfied is symmetric }
              //     -((-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied) /\\ (-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied))
              // <=> { -nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied /\\ -nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied = -nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied }
              //     -(-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied /\\ -nwAllCompCommReqsSatisfied
              // <=> { nwAllCompCommReqsSatisfied /\\ -nwAllCompCommReqsSatisfied = V- }
              //     -V[Network*Network]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Network*Network])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Network*Network] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY nwAllCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'ASY nwAllCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied~ /\\ nwAllCompCommReqsSatisfied |- I[Network]'
              , 'origin'        => 'line 27:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'nwAllCompCommReqsSatisfied[Network] is antisymmetrisch.'
              , 'message'       => 'nwAllCompCommReqsSatisfied[Network] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied~ /\\ nwAllCompCommReqsSatisfied |- I[Network])
              // <=> { remove |- }
              //     -(-(nwAllCompCommReqsSatisfied~ /\\ nwAllCompCommReqsSatisfied) \\/ I[Network])
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied~ /\\ (nwAllCompCommReqsSatisfied /\\ -I[Network])
              // <=> { nwAllCompCommReqsSatisfied is symmetric }
              //     nwAllCompCommReqsSatisfied /\\ (nwAllCompCommReqsSatisfied /\\ -I[Network])
              // <=> { nwAllCompCommReqsSatisfied /\\ nwAllCompCommReqsSatisfied = nwAllCompCommReqsSatisfied }
              //     nwAllCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",ECpl (EDcI Network))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwAllCompCommReqsSatisfied /\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TrgNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI nwAllCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'UNI nwAllCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied~;nwAllCompCommReqsSatisfied |- I[Network]'
              , 'origin'        => 'line 27:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'nwAllCompCommReqsSatisfied[Network\\*Network] is univalent'
              , 'message'       => 'nwAllCompCommReqsSatisfied[Network\\*Network] is niet univalent'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied~;nwAllCompCommReqsSatisfied |- I[Network])
              // <=> { remove |- }
              //     -(-(nwAllCompCommReqsSatisfied~;nwAllCompCommReqsSatisfied) \\/ I[Network])
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied~;nwAllCompCommReqsSatisfied /\\ -I[Network]
              // <=> { nwAllCompCommReqsSatisfied is symmetric }
              //     nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" ""),ECpl (EDcI Network))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied /\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                 FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TrgNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ nwAllCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'INJ nwAllCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied~ |- I[Network]'
              , 'origin'        => 'line 27:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'nwAllCompCommReqsSatisfied[Network\\*Network] is injectief'
              , 'message'       => 'nwAllCompCommReqsSatisfied[Network\\*Network] is niet injectief'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied~ |- I[Network])
              // <=> { remove |- }
              //     -(-(nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied~) \\/ I[Network])
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied~ /\\ -I[Network]
              // <=> { nwAllCompCommReqsSatisfied is symmetric }
              //     nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",EDcD RELATION nwAllCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" ""),ECpl (EDcI Network))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied /\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                 FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwAllCompCommReqsSatisfied` AS `TrgNetwork`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwAllCompCommReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TrgNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM nwNoCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'SYM nwNoCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied = nwNoCompCommReqsSatisfied~'
              , 'origin'        => 'line 35:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'nwNoCompCommReqsSatisfied[Network] is symmetrisch.'
              , 'message'       => 'nwNoCompCommReqsSatisfied[Network] is niet symmetrisch.'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied = nwNoCompCommReqsSatisfied~)
              // <=> { remove = }
              //     -((nwNoCompCommReqsSatisfied |- nwNoCompCommReqsSatisfied~) /\\ (nwNoCompCommReqsSatisfied~ |- nwNoCompCommReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied~) /\\ (-nwNoCompCommReqsSatisfied~ \\/ nwNoCompCommReqsSatisfied))
              // <=> { nwNoCompCommReqsSatisfied is symmetric and nwNoCompCommReqsSatisfied is symmetric }
              //     -((-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied) /\\ (-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied))
              // <=> { -nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied = -nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied }
              //     -(-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied
              // <=> { nwNoCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied = V- }
              //     -V[Network*Network]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Network*Network])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Network*Network] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY nwNoCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'ASY nwNoCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied~ /\\ nwNoCompCommReqsSatisfied |- I[Network]'
              , 'origin'        => 'line 35:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'nwNoCompCommReqsSatisfied[Network] is antisymmetrisch.'
              , 'message'       => 'nwNoCompCommReqsSatisfied[Network] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied~ /\\ nwNoCompCommReqsSatisfied |- I[Network])
              // <=> { remove |- }
              //     -(-(nwNoCompCommReqsSatisfied~ /\\ nwNoCompCommReqsSatisfied) \\/ I[Network])
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied~ /\\ (nwNoCompCommReqsSatisfied /\\ -I[Network])
              // <=> { nwNoCompCommReqsSatisfied is symmetric }
              //     nwNoCompCommReqsSatisfied /\\ (nwNoCompCommReqsSatisfied /\\ -I[Network])
              // <=> { nwNoCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied = nwNoCompCommReqsSatisfied }
              //     nwNoCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",ECpl (EDcI Network))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwNoCompCommReqsSatisfied /\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TrgNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI nwNoCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'UNI nwNoCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied~;nwNoCompCommReqsSatisfied |- I[Network]'
              , 'origin'        => 'line 35:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'nwNoCompCommReqsSatisfied[Network\\*Network] is univalent'
              , 'message'       => 'nwNoCompCommReqsSatisfied[Network\\*Network] is niet univalent'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied~;nwNoCompCommReqsSatisfied |- I[Network])
              // <=> { remove |- }
              //     -(-(nwNoCompCommReqsSatisfied~;nwNoCompCommReqsSatisfied) \\/ I[Network])
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied~;nwNoCompCommReqsSatisfied /\\ -I[Network]
              // <=> { nwNoCompCommReqsSatisfied is symmetric }
              //     nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" ""),ECpl (EDcI Network))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied /\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                 FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TrgNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ nwNoCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'INJ nwNoCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied~ |- I[Network]'
              , 'origin'        => 'line 35:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'nwNoCompCommReqsSatisfied[Network\\*Network] is injectief'
              , 'message'       => 'nwNoCompCommReqsSatisfied[Network\\*Network] is niet injectief'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied~ |- I[Network])
              // <=> { remove |- }
              //     -(-(nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied~) \\/ I[Network])
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied~ /\\ -I[Network]
              // <=> { nwNoCompCommReqsSatisfied is symmetric }
              //     nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" "",EDcD RELATION nwNoCompCommReqsSatisfied [Network*Network] Nothing PRAGMA "" "" ""),ECpl (EDcI Network))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied /\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                 FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwNoCompCommReqsSatisfied` AS `TrgNetwork`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwNoCompCommReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TrgNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM routerAllCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'SYM routerAllCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied = routerAllCommReqsSatisfied~'
              , 'origin'        => 'line 68:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'routerAllCommReqsSatisfied[Router] is symmetrisch.'
              , 'message'       => 'routerAllCommReqsSatisfied[Router] is niet symmetrisch.'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied = routerAllCommReqsSatisfied~)
              // <=> { remove = }
              //     -((routerAllCommReqsSatisfied |- routerAllCommReqsSatisfied~) /\\ (routerAllCommReqsSatisfied~ |- routerAllCommReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied~) /\\ (-routerAllCommReqsSatisfied~ \\/ routerAllCommReqsSatisfied))
              // <=> { routerAllCommReqsSatisfied is symmetric and routerAllCommReqsSatisfied is symmetric }
              //     -((-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied) /\\ (-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied))
              // <=> { -routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied /\\ -routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied = -routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied }
              //     -(-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied)
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied /\\ -routerAllCommReqsSatisfied
              // <=> { routerAllCommReqsSatisfied /\\ -routerAllCommReqsSatisfied = V- }
              //     -V[Router*Router]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Router*Router])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Router*Router] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY routerAllCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'ASY routerAllCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied~ /\\ routerAllCommReqsSatisfied |- I[Router]'
              , 'origin'        => 'line 68:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'routerAllCommReqsSatisfied[Router] is antisymmetrisch.'
              , 'message'       => 'routerAllCommReqsSatisfied[Router] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied~ /\\ routerAllCommReqsSatisfied |- I[Router])
              // <=> { remove |- }
              //     -(-(routerAllCommReqsSatisfied~ /\\ routerAllCommReqsSatisfied) \\/ I[Router])
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied~ /\\ (routerAllCommReqsSatisfied /\\ -I[Router])
              // <=> { routerAllCommReqsSatisfied is symmetric }
              //     routerAllCommReqsSatisfied /\\ (routerAllCommReqsSatisfied /\\ -I[Router])
              // <=> { routerAllCommReqsSatisfied /\\ routerAllCommReqsSatisfied = routerAllCommReqsSatisfied }
              //     routerAllCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",ECpl (EDcI Router))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerAllCommReqsSatisfied /\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerAllCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'UNI routerAllCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied~;routerAllCommReqsSatisfied |- I[Router]'
              , 'origin'        => 'line 68:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'routerAllCommReqsSatisfied[Router\\*Router] is univalent'
              , 'message'       => 'routerAllCommReqsSatisfied[Router\\*Router] is niet univalent'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied~;routerAllCommReqsSatisfied |- I[Router])
              // <=> { remove |- }
              //     -(-(routerAllCommReqsSatisfied~;routerAllCommReqsSatisfied) \\/ I[Router])
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied~;routerAllCommReqsSatisfied /\\ -I[Router]
              // <=> { routerAllCommReqsSatisfied is symmetric }
              //     routerAllCommReqsSatisfied;routerAllCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" ""),ECpl (EDcI Router))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerAllCommReqsSatisfied;routerAllCommReqsSatisfied /\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerAllCommReqsSatisfied;routerAllCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ routerAllCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'INJ routerAllCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied;routerAllCommReqsSatisfied~ |- I[Router]'
              , 'origin'        => 'line 68:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'routerAllCommReqsSatisfied[Router\\*Router] is injectief'
              , 'message'       => 'routerAllCommReqsSatisfied[Router\\*Router] is niet injectief'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied;routerAllCommReqsSatisfied~ |- I[Router])
              // <=> { remove |- }
              //     -(-(routerAllCommReqsSatisfied;routerAllCommReqsSatisfied~) \\/ I[Router])
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied;routerAllCommReqsSatisfied~ /\\ -I[Router]
              // <=> { routerAllCommReqsSatisfied is symmetric }
              //     routerAllCommReqsSatisfied;routerAllCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",EDcD RELATION routerAllCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" ""),ECpl (EDcI Router))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerAllCommReqsSatisfied;routerAllCommReqsSatisfied /\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerAllCommReqsSatisfied;routerAllCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerAllCommReqsSatisfied` AS `TrgRouter`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerAllCommReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM routerNoCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'SYM routerNoCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied = routerNoCommReqsSatisfied~'
              , 'origin'        => 'line 76:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'routerNoCommReqsSatisfied[Router] is symmetrisch.'
              , 'message'       => 'routerNoCommReqsSatisfied[Router] is niet symmetrisch.'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied = routerNoCommReqsSatisfied~)
              // <=> { remove = }
              //     -((routerNoCommReqsSatisfied |- routerNoCommReqsSatisfied~) /\\ (routerNoCommReqsSatisfied~ |- routerNoCommReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied~) /\\ (-routerNoCommReqsSatisfied~ \\/ routerNoCommReqsSatisfied))
              // <=> { routerNoCommReqsSatisfied is symmetric and routerNoCommReqsSatisfied is symmetric }
              //     -((-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied) /\\ (-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied))
              // <=> { -routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied /\\ -routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied = -routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied }
              //     -(-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied)
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied /\\ -routerNoCommReqsSatisfied
              // <=> { routerNoCommReqsSatisfied /\\ -routerNoCommReqsSatisfied = V- }
              //     -V[Router*Router]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Router*Router])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Router*Router] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY routerNoCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'ASY routerNoCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied~ /\\ routerNoCommReqsSatisfied |- I[Router]'
              , 'origin'        => 'line 76:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'routerNoCommReqsSatisfied[Router] is antisymmetrisch.'
              , 'message'       => 'routerNoCommReqsSatisfied[Router] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied~ /\\ routerNoCommReqsSatisfied |- I[Router])
              // <=> { remove |- }
              //     -(-(routerNoCommReqsSatisfied~ /\\ routerNoCommReqsSatisfied) \\/ I[Router])
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied~ /\\ (routerNoCommReqsSatisfied /\\ -I[Router])
              // <=> { routerNoCommReqsSatisfied is symmetric }
              //     routerNoCommReqsSatisfied /\\ (routerNoCommReqsSatisfied /\\ -I[Router])
              // <=> { routerNoCommReqsSatisfied /\\ routerNoCommReqsSatisfied = routerNoCommReqsSatisfied }
              //     routerNoCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",ECpl (EDcI Router))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerNoCommReqsSatisfied /\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerNoCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'UNI routerNoCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied~;routerNoCommReqsSatisfied |- I[Router]'
              , 'origin'        => 'line 76:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'routerNoCommReqsSatisfied[Router\\*Router] is univalent'
              , 'message'       => 'routerNoCommReqsSatisfied[Router\\*Router] is niet univalent'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied~;routerNoCommReqsSatisfied |- I[Router])
              // <=> { remove |- }
              //     -(-(routerNoCommReqsSatisfied~;routerNoCommReqsSatisfied) \\/ I[Router])
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied~;routerNoCommReqsSatisfied /\\ -I[Router]
              // <=> { routerNoCommReqsSatisfied is symmetric }
              //     routerNoCommReqsSatisfied;routerNoCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" ""),ECpl (EDcI Router))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerNoCommReqsSatisfied;routerNoCommReqsSatisfied /\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNoCommReqsSatisfied;routerNoCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ routerNoCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'INJ routerNoCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied;routerNoCommReqsSatisfied~ |- I[Router]'
              , 'origin'        => 'line 76:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'routerNoCommReqsSatisfied[Router\\*Router] is injectief'
              , 'message'       => 'routerNoCommReqsSatisfied[Router\\*Router] is niet injectief'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied;routerNoCommReqsSatisfied~ |- I[Router])
              // <=> { remove |- }
              //     -(-(routerNoCommReqsSatisfied;routerNoCommReqsSatisfied~) \\/ I[Router])
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied;routerNoCommReqsSatisfied~ /\\ -I[Router]
              // <=> { routerNoCommReqsSatisfied is symmetric }
              //     routerNoCommReqsSatisfied;routerNoCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" "",EDcD RELATION routerNoCommReqsSatisfied [Router*Router] Nothing PRAGMA "" "" ""),ECpl (EDcI Router))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerNoCommReqsSatisfied;routerNoCommReqsSatisfied /\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNoCommReqsSatisfied;routerNoCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                 FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNoCommReqsSatisfied` AS `TrgRouter`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNoCommReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM compRequiresComm::Computer*Computer' =>
        array ( 'name'          => 'SYM compRequiresComm::Computer*Computer'
              , 'ruleAdl'       => 'compRequiresComm = compRequiresComm~'
              , 'origin'        => 'line 102:18, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compRequiresComm[Computer] is symmetrisch.'
              , 'message'       => 'compRequiresComm[Computer] is niet symmetrisch.'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm = compRequiresComm~)
              // <=> { remove = }
              //     -((compRequiresComm |- compRequiresComm~) /\\ (compRequiresComm~ |- compRequiresComm))
              // <=> { remove |- and remove |- }
              //     -((-compRequiresComm \\/ compRequiresComm~) /\\ (-compRequiresComm~ \\/ compRequiresComm))
              // <=> { compRequiresComm is symmetric and compRequiresComm is symmetric }
              //     -((-compRequiresComm \\/ compRequiresComm) /\\ (-compRequiresComm \\/ compRequiresComm))
              // <=> { -compRequiresComm \\/ compRequiresComm /\\ -compRequiresComm \\/ compRequiresComm = -compRequiresComm \\/ compRequiresComm }
              //     -(-compRequiresComm \\/ compRequiresComm)
              // <=> { De Morgan }
              //     compRequiresComm /\\ -compRequiresComm
              // <=> { compRequiresComm /\\ -compRequiresComm = V- }
              //     -V[Computer*Computer]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Computer*Computer])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Computer*Computer] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY compRequiresComm::Computer*Computer' =>
        array ( 'name'          => 'ASY compRequiresComm::Computer*Computer'
              , 'ruleAdl'       => 'compRequiresComm~ /\\ compRequiresComm |- I[Computer]'
              , 'origin'        => 'line 102:18, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compRequiresComm[Computer] is antisymmetrisch.'
              , 'message'       => 'compRequiresComm[Computer] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm~ /\\ compRequiresComm |- I[Computer])
              // <=> { remove |- }
              //     -(-(compRequiresComm~ /\\ compRequiresComm) \\/ I[Computer])
              // <=> { De Morgan }
              //     compRequiresComm~ /\\ (compRequiresComm /\\ -I[Computer])
              // <=> { compRequiresComm is symmetric }
              //     compRequiresComm /\\ (compRequiresComm /\\ -I[Computer])
              // <=> { compRequiresComm /\\ compRequiresComm = compRequiresComm }
              //     compRequiresComm /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compRequiresComm /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compRequiresComm::Computer*Computer' =>
        array ( 'name'          => 'UNI compRequiresComm::Computer*Computer'
              , 'ruleAdl'       => 'compRequiresComm~;compRequiresComm |- I[Computer]'
              , 'origin'        => 'line 102:18, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compRequiresComm[Computer\\*Computer] is univalent'
              , 'message'       => 'compRequiresComm[Computer\\*Computer] is niet univalent'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm~;compRequiresComm |- I[Computer])
              // <=> { remove |- }
              //     -(-(compRequiresComm~;compRequiresComm) \\/ I[Computer])
              // <=> { De Morgan }
              //     compRequiresComm~;compRequiresComm /\\ -I[Computer]
              // <=> { compRequiresComm is symmetric }
              //     compRequiresComm;compRequiresComm /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" "",EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compRequiresComm;compRequiresComm /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRequiresComm;compRequiresComm */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ compRequiresComm::Computer*Computer' =>
        array ( 'name'          => 'INJ compRequiresComm::Computer*Computer'
              , 'ruleAdl'       => 'compRequiresComm;compRequiresComm~ |- I[Computer]'
              , 'origin'        => 'line 102:18, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compRequiresComm[Computer\\*Computer] is injectief'
              , 'message'       => 'compRequiresComm[Computer\\*Computer] is niet injectief'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm;compRequiresComm~ |- I[Computer])
              // <=> { remove |- }
              //     -(-(compRequiresComm;compRequiresComm~) \\/ I[Computer])
              // <=> { De Morgan }
              //     compRequiresComm;compRequiresComm~ /\\ -I[Computer]
              // <=> { compRequiresComm is symmetric }
              //     compRequiresComm;compRequiresComm /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" "",EDcD RELATION compRequiresComm [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compRequiresComm;compRequiresComm /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRequiresComm;compRequiresComm */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compRequiresComm` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compRequiresComm` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM compAllReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'SYM compAllReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compAllReqCommSatisfied = compAllReqCommSatisfied~'
              , 'origin'        => 'line 110:25, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compAllReqCommSatisfied[Computer] is symmetrisch.'
              , 'message'       => 'compAllReqCommSatisfied[Computer] is niet symmetrisch.'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied = compAllReqCommSatisfied~)
              // <=> { remove = }
              //     -((compAllReqCommSatisfied |- compAllReqCommSatisfied~) /\\ (compAllReqCommSatisfied~ |- compAllReqCommSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-compAllReqCommSatisfied \\/ compAllReqCommSatisfied~) /\\ (-compAllReqCommSatisfied~ \\/ compAllReqCommSatisfied))
              // <=> { compAllReqCommSatisfied is symmetric and compAllReqCommSatisfied is symmetric }
              //     -((-compAllReqCommSatisfied \\/ compAllReqCommSatisfied) /\\ (-compAllReqCommSatisfied \\/ compAllReqCommSatisfied))
              // <=> { -compAllReqCommSatisfied \\/ compAllReqCommSatisfied /\\ -compAllReqCommSatisfied \\/ compAllReqCommSatisfied = -compAllReqCommSatisfied \\/ compAllReqCommSatisfied }
              //     -(-compAllReqCommSatisfied \\/ compAllReqCommSatisfied)
              // <=> { De Morgan }
              //     compAllReqCommSatisfied /\\ -compAllReqCommSatisfied
              // <=> { compAllReqCommSatisfied /\\ -compAllReqCommSatisfied = V- }
              //     -V[Computer*Computer]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Computer*Computer])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Computer*Computer] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY compAllReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'ASY compAllReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compAllReqCommSatisfied~ /\\ compAllReqCommSatisfied |- I[Computer]'
              , 'origin'        => 'line 110:25, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compAllReqCommSatisfied[Computer] is antisymmetrisch.'
              , 'message'       => 'compAllReqCommSatisfied[Computer] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied~ /\\ compAllReqCommSatisfied |- I[Computer])
              // <=> { remove |- }
              //     -(-(compAllReqCommSatisfied~ /\\ compAllReqCommSatisfied) \\/ I[Computer])
              // <=> { De Morgan }
              //     compAllReqCommSatisfied~ /\\ (compAllReqCommSatisfied /\\ -I[Computer])
              // <=> { compAllReqCommSatisfied is symmetric }
              //     compAllReqCommSatisfied /\\ (compAllReqCommSatisfied /\\ -I[Computer])
              // <=> { compAllReqCommSatisfied /\\ compAllReqCommSatisfied = compAllReqCommSatisfied }
              //     compAllReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compAllReqCommSatisfied /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compAllReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'UNI compAllReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compAllReqCommSatisfied~;compAllReqCommSatisfied |- I[Computer]'
              , 'origin'        => 'line 110:25, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compAllReqCommSatisfied[Computer\\*Computer] is univalent'
              , 'message'       => 'compAllReqCommSatisfied[Computer\\*Computer] is niet univalent'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied~;compAllReqCommSatisfied |- I[Computer])
              // <=> { remove |- }
              //     -(-(compAllReqCommSatisfied~;compAllReqCommSatisfied) \\/ I[Computer])
              // <=> { De Morgan }
              //     compAllReqCommSatisfied~;compAllReqCommSatisfied /\\ -I[Computer]
              // <=> { compAllReqCommSatisfied is symmetric }
              //     compAllReqCommSatisfied;compAllReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compAllReqCommSatisfied;compAllReqCommSatisfied /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compAllReqCommSatisfied;compAllReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ compAllReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'INJ compAllReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compAllReqCommSatisfied;compAllReqCommSatisfied~ |- I[Computer]'
              , 'origin'        => 'line 110:25, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compAllReqCommSatisfied[Computer\\*Computer] is injectief'
              , 'message'       => 'compAllReqCommSatisfied[Computer\\*Computer] is niet injectief'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied;compAllReqCommSatisfied~ |- I[Computer])
              // <=> { remove |- }
              //     -(-(compAllReqCommSatisfied;compAllReqCommSatisfied~) \\/ I[Computer])
              // <=> { De Morgan }
              //     compAllReqCommSatisfied;compAllReqCommSatisfied~ /\\ -I[Computer]
              // <=> { compAllReqCommSatisfied is symmetric }
              //     compAllReqCommSatisfied;compAllReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",EDcD RELATION compAllReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compAllReqCommSatisfied;compAllReqCommSatisfied /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compAllReqCommSatisfied;compAllReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compAllReqCommSatisfied` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compAllReqCommSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM compNoReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'SYM compNoReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compNoReqCommSatisfied = compNoReqCommSatisfied~'
              , 'origin'        => 'line 118:24, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compNoReqCommSatisfied[Computer] is symmetrisch.'
              , 'message'       => 'compNoReqCommSatisfied[Computer] is niet symmetrisch.'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied = compNoReqCommSatisfied~)
              // <=> { remove = }
              //     -((compNoReqCommSatisfied |- compNoReqCommSatisfied~) /\\ (compNoReqCommSatisfied~ |- compNoReqCommSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-compNoReqCommSatisfied \\/ compNoReqCommSatisfied~) /\\ (-compNoReqCommSatisfied~ \\/ compNoReqCommSatisfied))
              // <=> { compNoReqCommSatisfied is symmetric and compNoReqCommSatisfied is symmetric }
              //     -((-compNoReqCommSatisfied \\/ compNoReqCommSatisfied) /\\ (-compNoReqCommSatisfied \\/ compNoReqCommSatisfied))
              // <=> { -compNoReqCommSatisfied \\/ compNoReqCommSatisfied /\\ -compNoReqCommSatisfied \\/ compNoReqCommSatisfied = -compNoReqCommSatisfied \\/ compNoReqCommSatisfied }
              //     -(-compNoReqCommSatisfied \\/ compNoReqCommSatisfied)
              // <=> { De Morgan }
              //     compNoReqCommSatisfied /\\ -compNoReqCommSatisfied
              // <=> { compNoReqCommSatisfied /\\ -compNoReqCommSatisfied = V- }
              //     -V[Computer*Computer]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Computer*Computer])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Computer*Computer] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY compNoReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'ASY compNoReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compNoReqCommSatisfied~ /\\ compNoReqCommSatisfied |- I[Computer]'
              , 'origin'        => 'line 118:24, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compNoReqCommSatisfied[Computer] is antisymmetrisch.'
              , 'message'       => 'compNoReqCommSatisfied[Computer] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied~ /\\ compNoReqCommSatisfied |- I[Computer])
              // <=> { remove |- }
              //     -(-(compNoReqCommSatisfied~ /\\ compNoReqCommSatisfied) \\/ I[Computer])
              // <=> { De Morgan }
              //     compNoReqCommSatisfied~ /\\ (compNoReqCommSatisfied /\\ -I[Computer])
              // <=> { compNoReqCommSatisfied is symmetric }
              //     compNoReqCommSatisfied /\\ (compNoReqCommSatisfied /\\ -I[Computer])
              // <=> { compNoReqCommSatisfied /\\ compNoReqCommSatisfied = compNoReqCommSatisfied }
              //     compNoReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compNoReqCommSatisfied /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compNoReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'UNI compNoReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compNoReqCommSatisfied~;compNoReqCommSatisfied |- I[Computer]'
              , 'origin'        => 'line 118:24, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compNoReqCommSatisfied[Computer\\*Computer] is univalent'
              , 'message'       => 'compNoReqCommSatisfied[Computer\\*Computer] is niet univalent'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied~;compNoReqCommSatisfied |- I[Computer])
              // <=> { remove |- }
              //     -(-(compNoReqCommSatisfied~;compNoReqCommSatisfied) \\/ I[Computer])
              // <=> { De Morgan }
              //     compNoReqCommSatisfied~;compNoReqCommSatisfied /\\ -I[Computer]
              // <=> { compNoReqCommSatisfied is symmetric }
              //     compNoReqCommSatisfied;compNoReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compNoReqCommSatisfied;compNoReqCommSatisfied /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compNoReqCommSatisfied;compNoReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ compNoReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'INJ compNoReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compNoReqCommSatisfied;compNoReqCommSatisfied~ |- I[Computer]'
              , 'origin'        => 'line 118:24, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'compNoReqCommSatisfied[Computer\\*Computer] is injectief'
              , 'message'       => 'compNoReqCommSatisfied[Computer\\*Computer] is niet injectief'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied;compNoReqCommSatisfied~ |- I[Computer])
              // <=> { remove |- }
              //     -(-(compNoReqCommSatisfied;compNoReqCommSatisfied~) \\/ I[Computer])
              // <=> { De Morgan }
              //     compNoReqCommSatisfied;compNoReqCommSatisfied~ /\\ -I[Computer]
              // <=> { compNoReqCommSatisfied is symmetric }
              //     compNoReqCommSatisfied;compNoReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" "",EDcD RELATION compNoReqCommSatisfied [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compNoReqCommSatisfied;compNoReqCommSatisfied /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compNoReqCommSatisfied;compNoReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compNoReqCommSatisfied` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compNoReqCommSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM scAllReqCommSatisfied::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'SYM scAllReqCommSatisfied::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'scAllReqCommSatisfied = scAllReqCommSatisfied~'
              , 'origin'        => 'line 137:23, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'scAllReqCommSatisfied[SvcComponent] is symmetrisch.'
              , 'message'       => 'scAllReqCommSatisfied[SvcComponent] is niet symmetrisch.'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scAllReqCommSatisfied = scAllReqCommSatisfied~)
              // <=> { remove = }
              //     -((scAllReqCommSatisfied |- scAllReqCommSatisfied~) /\\ (scAllReqCommSatisfied~ |- scAllReqCommSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-scAllReqCommSatisfied \\/ scAllReqCommSatisfied~) /\\ (-scAllReqCommSatisfied~ \\/ scAllReqCommSatisfied))
              // <=> { scAllReqCommSatisfied is symmetric and scAllReqCommSatisfied is symmetric }
              //     -((-scAllReqCommSatisfied \\/ scAllReqCommSatisfied) /\\ (-scAllReqCommSatisfied \\/ scAllReqCommSatisfied))
              // <=> { -scAllReqCommSatisfied \\/ scAllReqCommSatisfied /\\ -scAllReqCommSatisfied \\/ scAllReqCommSatisfied = -scAllReqCommSatisfied \\/ scAllReqCommSatisfied }
              //     -(-scAllReqCommSatisfied \\/ scAllReqCommSatisfied)
              // <=> { De Morgan }
              //     scAllReqCommSatisfied /\\ -scAllReqCommSatisfied
              // <=> { scAllReqCommSatisfied /\\ -scAllReqCommSatisfied = V- }
              //     -V[SvcComponent*SvcComponent]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [SvcComponent*SvcComponent])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [SvcComponent*SvcComponent] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY scAllReqCommSatisfied::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'ASY scAllReqCommSatisfied::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'scAllReqCommSatisfied~ /\\ scAllReqCommSatisfied |- I[SvcComponent]'
              , 'origin'        => 'line 137:23, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'scAllReqCommSatisfied[SvcComponent] is antisymmetrisch.'
              , 'message'       => 'scAllReqCommSatisfied[SvcComponent] is niet antisymmetrisch.'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scAllReqCommSatisfied~ /\\ scAllReqCommSatisfied |- I[SvcComponent])
              // <=> { remove |- }
              //     -(-(scAllReqCommSatisfied~ /\\ scAllReqCommSatisfied) \\/ I[SvcComponent])
              // <=> { De Morgan }
              //     scAllReqCommSatisfied~ /\\ (scAllReqCommSatisfied /\\ -I[SvcComponent])
              // <=> { scAllReqCommSatisfied is symmetric }
              //     scAllReqCommSatisfied /\\ (scAllReqCommSatisfied /\\ -I[SvcComponent])
              // <=> { scAllReqCommSatisfied /\\ scAllReqCommSatisfied = scAllReqCommSatisfied }
              //     scAllReqCommSatisfied /\\ -I[SvcComponent]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scAllReqCommSatisfied /\\ -I[SvcComponent] ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcSvcComponent` <> isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scAllReqCommSatisfied::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'UNI scAllReqCommSatisfied::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'scAllReqCommSatisfied~;scAllReqCommSatisfied |- I[SvcComponent]'
              , 'origin'        => 'line 137:23, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'scAllReqCommSatisfied[SvcComponent\\*SvcComponent] is univalent'
              , 'message'       => 'scAllReqCommSatisfied[SvcComponent\\*SvcComponent] is niet univalent'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scAllReqCommSatisfied~;scAllReqCommSatisfied |- I[SvcComponent])
              // <=> { remove |- }
              //     -(-(scAllReqCommSatisfied~;scAllReqCommSatisfied) \\/ I[SvcComponent])
              // <=> { De Morgan }
              //     scAllReqCommSatisfied~;scAllReqCommSatisfied /\\ -I[SvcComponent]
              // <=> { scAllReqCommSatisfied is symmetric }
              //     scAllReqCommSatisfied;scAllReqCommSatisfied /\\ -I[SvcComponent]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""),ECpl (EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scAllReqCommSatisfied;scAllReqCommSatisfied /\\ -I[SvcComponent] ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scAllReqCommSatisfied;scAllReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcSvcComponent` <> isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ scAllReqCommSatisfied::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'INJ scAllReqCommSatisfied::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'scAllReqCommSatisfied;scAllReqCommSatisfied~ |- I[SvcComponent]'
              , 'origin'        => 'line 137:23, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'scAllReqCommSatisfied[SvcComponent\\*SvcComponent] is injectief'
              , 'message'       => 'scAllReqCommSatisfied[SvcComponent\\*SvcComponent] is niet injectief'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scAllReqCommSatisfied;scAllReqCommSatisfied~ |- I[SvcComponent])
              // <=> { remove |- }
              //     -(-(scAllReqCommSatisfied;scAllReqCommSatisfied~) \\/ I[SvcComponent])
              // <=> { De Morgan }
              //     scAllReqCommSatisfied;scAllReqCommSatisfied~ /\\ -I[SvcComponent]
              // <=> { scAllReqCommSatisfied is symmetric }
              //     scAllReqCommSatisfied;scAllReqCommSatisfied /\\ -I[SvcComponent]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scAllReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""),ECpl (EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scAllReqCommSatisfied;scAllReqCommSatisfied /\\ -I[SvcComponent] ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scAllReqCommSatisfied;scAllReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scAllReqCommSatisfied` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scAllReqCommSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcSvcComponent` <> isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM scNoReqCommSatisfied::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'SYM scNoReqCommSatisfied::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'scNoReqCommSatisfied = scNoReqCommSatisfied~'
              , 'origin'        => 'line 145:22, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'scNoReqCommSatisfied[SvcComponent] is symmetrisch.'
              , 'message'       => 'scNoReqCommSatisfied[SvcComponent] is niet symmetrisch.'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scNoReqCommSatisfied = scNoReqCommSatisfied~)
              // <=> { remove = }
              //     -((scNoReqCommSatisfied |- scNoReqCommSatisfied~) /\\ (scNoReqCommSatisfied~ |- scNoReqCommSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-scNoReqCommSatisfied \\/ scNoReqCommSatisfied~) /\\ (-scNoReqCommSatisfied~ \\/ scNoReqCommSatisfied))
              // <=> { scNoReqCommSatisfied is symmetric and scNoReqCommSatisfied is symmetric }
              //     -((-scNoReqCommSatisfied \\/ scNoReqCommSatisfied) /\\ (-scNoReqCommSatisfied \\/ scNoReqCommSatisfied))
              // <=> { -scNoReqCommSatisfied \\/ scNoReqCommSatisfied /\\ -scNoReqCommSatisfied \\/ scNoReqCommSatisfied = -scNoReqCommSatisfied \\/ scNoReqCommSatisfied }
              //     -(-scNoReqCommSatisfied \\/ scNoReqCommSatisfied)
              // <=> { De Morgan }
              //     scNoReqCommSatisfied /\\ -scNoReqCommSatisfied
              // <=> { scNoReqCommSatisfied /\\ -scNoReqCommSatisfied = V- }
              //     -V[SvcComponent*SvcComponent]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [SvcComponent*SvcComponent])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [SvcComponent*SvcComponent] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY scNoReqCommSatisfied::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'ASY scNoReqCommSatisfied::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'scNoReqCommSatisfied~ /\\ scNoReqCommSatisfied |- I[SvcComponent]'
              , 'origin'        => 'line 145:22, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'scNoReqCommSatisfied[SvcComponent] is antisymmetrisch.'
              , 'message'       => 'scNoReqCommSatisfied[SvcComponent] is niet antisymmetrisch.'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scNoReqCommSatisfied~ /\\ scNoReqCommSatisfied |- I[SvcComponent])
              // <=> { remove |- }
              //     -(-(scNoReqCommSatisfied~ /\\ scNoReqCommSatisfied) \\/ I[SvcComponent])
              // <=> { De Morgan }
              //     scNoReqCommSatisfied~ /\\ (scNoReqCommSatisfied /\\ -I[SvcComponent])
              // <=> { scNoReqCommSatisfied is symmetric }
              //     scNoReqCommSatisfied /\\ (scNoReqCommSatisfied /\\ -I[SvcComponent])
              // <=> { scNoReqCommSatisfied /\\ scNoReqCommSatisfied = scNoReqCommSatisfied }
              //     scNoReqCommSatisfied /\\ -I[SvcComponent]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scNoReqCommSatisfied /\\ -I[SvcComponent] ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcSvcComponent` <> isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scNoReqCommSatisfied::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'UNI scNoReqCommSatisfied::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'scNoReqCommSatisfied~;scNoReqCommSatisfied |- I[SvcComponent]'
              , 'origin'        => 'line 145:22, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'scNoReqCommSatisfied[SvcComponent\\*SvcComponent] is univalent'
              , 'message'       => 'scNoReqCommSatisfied[SvcComponent\\*SvcComponent] is niet univalent'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scNoReqCommSatisfied~;scNoReqCommSatisfied |- I[SvcComponent])
              // <=> { remove |- }
              //     -(-(scNoReqCommSatisfied~;scNoReqCommSatisfied) \\/ I[SvcComponent])
              // <=> { De Morgan }
              //     scNoReqCommSatisfied~;scNoReqCommSatisfied /\\ -I[SvcComponent]
              // <=> { scNoReqCommSatisfied is symmetric }
              //     scNoReqCommSatisfied;scNoReqCommSatisfied /\\ -I[SvcComponent]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""),ECpl (EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scNoReqCommSatisfied;scNoReqCommSatisfied /\\ -I[SvcComponent] ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scNoReqCommSatisfied;scNoReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcSvcComponent` <> isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ scNoReqCommSatisfied::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'INJ scNoReqCommSatisfied::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'scNoReqCommSatisfied;scNoReqCommSatisfied~ |- I[SvcComponent]'
              , 'origin'        => 'line 145:22, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'scNoReqCommSatisfied[SvcComponent\\*SvcComponent] is injectief'
              , 'message'       => 'scNoReqCommSatisfied[SvcComponent\\*SvcComponent] is niet injectief'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(scNoReqCommSatisfied;scNoReqCommSatisfied~ |- I[SvcComponent])
              // <=> { remove |- }
              //     -(-(scNoReqCommSatisfied;scNoReqCommSatisfied~) \\/ I[SvcComponent])
              // <=> { De Morgan }
              //     scNoReqCommSatisfied;scNoReqCommSatisfied~ /\\ -I[SvcComponent]
              // <=> { scNoReqCommSatisfied is symmetric }
              //     scNoReqCommSatisfied;scNoReqCommSatisfied /\\ -I[SvcComponent]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION scNoReqCommSatisfied [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""),ECpl (EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scNoReqCommSatisfied;scNoReqCommSatisfied /\\ -I[SvcComponent] ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scNoReqCommSatisfied;scNoReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scNoReqCommSatisfied` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scNoReqCommSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcSvcComponent` <> isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM svcAllSvcCompReqsSatisfied::Service*Service' =>
        array ( 'name'          => 'SYM svcAllSvcCompReqsSatisfied::Service*Service'
              , 'ruleAdl'       => 'svcAllSvcCompReqsSatisfied = svcAllSvcCompReqsSatisfied~'
              , 'origin'        => 'line 155:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'svcAllSvcCompReqsSatisfied[Service] is symmetrisch.'
              , 'message'       => 'svcAllSvcCompReqsSatisfied[Service] is niet symmetrisch.'
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcAllSvcCompReqsSatisfied = svcAllSvcCompReqsSatisfied~)
              // <=> { remove = }
              //     -((svcAllSvcCompReqsSatisfied |- svcAllSvcCompReqsSatisfied~) /\\ (svcAllSvcCompReqsSatisfied~ |- svcAllSvcCompReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied~) /\\ (-svcAllSvcCompReqsSatisfied~ \\/ svcAllSvcCompReqsSatisfied))
              // <=> { svcAllSvcCompReqsSatisfied is symmetric and svcAllSvcCompReqsSatisfied is symmetric }
              //     -((-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied) /\\ (-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied))
              // <=> { -svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied /\\ -svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied = -svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied }
              //     -(-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied)
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied /\\ -svcAllSvcCompReqsSatisfied
              // <=> { svcAllSvcCompReqsSatisfied /\\ -svcAllSvcCompReqsSatisfied = V- }
              //     -V[Service*Service]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Service*Service])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Service*Service] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY svcAllSvcCompReqsSatisfied::Service*Service' =>
        array ( 'name'          => 'ASY svcAllSvcCompReqsSatisfied::Service*Service'
              , 'ruleAdl'       => 'svcAllSvcCompReqsSatisfied~ /\\ svcAllSvcCompReqsSatisfied |- I[Service]'
              , 'origin'        => 'line 155:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'svcAllSvcCompReqsSatisfied[Service] is antisymmetrisch.'
              , 'message'       => 'svcAllSvcCompReqsSatisfied[Service] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcAllSvcCompReqsSatisfied~ /\\ svcAllSvcCompReqsSatisfied |- I[Service])
              // <=> { remove |- }
              //     -(-(svcAllSvcCompReqsSatisfied~ /\\ svcAllSvcCompReqsSatisfied) \\/ I[Service])
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied~ /\\ (svcAllSvcCompReqsSatisfied /\\ -I[Service])
              // <=> { svcAllSvcCompReqsSatisfied is symmetric }
              //     svcAllSvcCompReqsSatisfied /\\ (svcAllSvcCompReqsSatisfied /\\ -I[Service])
              // <=> { svcAllSvcCompReqsSatisfied /\\ svcAllSvcCompReqsSatisfied = svcAllSvcCompReqsSatisfied }
              //     svcAllSvcCompReqsSatisfied /\\ -I[Service]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",ECpl (EDcI Service))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcAllSvcCompReqsSatisfied /\\ -I[Service] ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcService` <> isect0.`TrgService` AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI svcAllSvcCompReqsSatisfied::Service*Service' =>
        array ( 'name'          => 'UNI svcAllSvcCompReqsSatisfied::Service*Service'
              , 'ruleAdl'       => 'svcAllSvcCompReqsSatisfied~;svcAllSvcCompReqsSatisfied |- I[Service]'
              , 'origin'        => 'line 155:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'svcAllSvcCompReqsSatisfied[Service\\*Service] is univalent'
              , 'message'       => 'svcAllSvcCompReqsSatisfied[Service\\*Service] is niet univalent'
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcAllSvcCompReqsSatisfied~;svcAllSvcCompReqsSatisfied |- I[Service])
              // <=> { remove |- }
              //     -(-(svcAllSvcCompReqsSatisfied~;svcAllSvcCompReqsSatisfied) \\/ I[Service])
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied~;svcAllSvcCompReqsSatisfied /\\ -I[Service]
              // <=> { svcAllSvcCompReqsSatisfied is symmetric }
              //     svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied /\\ -I[Service]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" ""),ECpl (EDcI Service))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied /\\ -I[Service] ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                 FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgService`=ECps1.`SrcService`
                               ) AS isect0
                          WHERE isect0.`SrcService` <> isect0.`TrgService` AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ svcAllSvcCompReqsSatisfied::Service*Service' =>
        array ( 'name'          => 'INJ svcAllSvcCompReqsSatisfied::Service*Service'
              , 'ruleAdl'       => 'svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied~ |- I[Service]'
              , 'origin'        => 'line 155:28, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'svcAllSvcCompReqsSatisfied[Service\\*Service] is injectief'
              , 'message'       => 'svcAllSvcCompReqsSatisfied[Service\\*Service] is niet injectief'
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied~ |- I[Service])
              // <=> { remove |- }
              //     -(-(svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied~) \\/ I[Service])
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied~ /\\ -I[Service]
              // <=> { svcAllSvcCompReqsSatisfied is symmetric }
              //     svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied /\\ -I[Service]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",EDcD RELATION svcAllSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" ""),ECpl (EDcI Service))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied /\\ -I[Service] ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                 FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Service` AS `SrcService`, `svcAllSvcCompReqsSatisfied` AS `TrgService`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcAllSvcCompReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgService`=ECps1.`SrcService`
                               ) AS isect0
                          WHERE isect0.`SrcService` <> isect0.`TrgService` AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM svcNoSvcCompReqsSatisfied::Service*Service' =>
        array ( 'name'          => 'SYM svcNoSvcCompReqsSatisfied::Service*Service'
              , 'ruleAdl'       => 'svcNoSvcCompReqsSatisfied = svcNoSvcCompReqsSatisfied~'
              , 'origin'        => 'line 165:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'svcNoSvcCompReqsSatisfied[Service] is symmetrisch.'
              , 'message'       => 'svcNoSvcCompReqsSatisfied[Service] is niet symmetrisch.'
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcNoSvcCompReqsSatisfied = svcNoSvcCompReqsSatisfied~)
              // <=> { remove = }
              //     -((svcNoSvcCompReqsSatisfied |- svcNoSvcCompReqsSatisfied~) /\\ (svcNoSvcCompReqsSatisfied~ |- svcNoSvcCompReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied~) /\\ (-svcNoSvcCompReqsSatisfied~ \\/ svcNoSvcCompReqsSatisfied))
              // <=> { svcNoSvcCompReqsSatisfied is symmetric and svcNoSvcCompReqsSatisfied is symmetric }
              //     -((-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied) /\\ (-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied))
              // <=> { -svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied /\\ -svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied = -svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied }
              //     -(-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied)
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied /\\ -svcNoSvcCompReqsSatisfied
              // <=> { svcNoSvcCompReqsSatisfied /\\ -svcNoSvcCompReqsSatisfied = V- }
              //     -V[Service*Service]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Service*Service])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Service*Service] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY svcNoSvcCompReqsSatisfied::Service*Service' =>
        array ( 'name'          => 'ASY svcNoSvcCompReqsSatisfied::Service*Service'
              , 'ruleAdl'       => 'svcNoSvcCompReqsSatisfied~ /\\ svcNoSvcCompReqsSatisfied |- I[Service]'
              , 'origin'        => 'line 165:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'svcNoSvcCompReqsSatisfied[Service] is antisymmetrisch.'
              , 'message'       => 'svcNoSvcCompReqsSatisfied[Service] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcNoSvcCompReqsSatisfied~ /\\ svcNoSvcCompReqsSatisfied |- I[Service])
              // <=> { remove |- }
              //     -(-(svcNoSvcCompReqsSatisfied~ /\\ svcNoSvcCompReqsSatisfied) \\/ I[Service])
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied~ /\\ (svcNoSvcCompReqsSatisfied /\\ -I[Service])
              // <=> { svcNoSvcCompReqsSatisfied is symmetric }
              //     svcNoSvcCompReqsSatisfied /\\ (svcNoSvcCompReqsSatisfied /\\ -I[Service])
              // <=> { svcNoSvcCompReqsSatisfied /\\ svcNoSvcCompReqsSatisfied = svcNoSvcCompReqsSatisfied }
              //     svcNoSvcCompReqsSatisfied /\\ -I[Service]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",ECpl (EDcI Service))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcNoSvcCompReqsSatisfied /\\ -I[Service] ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcService` <> isect0.`TrgService` AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI svcNoSvcCompReqsSatisfied::Service*Service' =>
        array ( 'name'          => 'UNI svcNoSvcCompReqsSatisfied::Service*Service'
              , 'ruleAdl'       => 'svcNoSvcCompReqsSatisfied~;svcNoSvcCompReqsSatisfied |- I[Service]'
              , 'origin'        => 'line 165:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'svcNoSvcCompReqsSatisfied[Service\\*Service] is univalent'
              , 'message'       => 'svcNoSvcCompReqsSatisfied[Service\\*Service] is niet univalent'
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcNoSvcCompReqsSatisfied~;svcNoSvcCompReqsSatisfied |- I[Service])
              // <=> { remove |- }
              //     -(-(svcNoSvcCompReqsSatisfied~;svcNoSvcCompReqsSatisfied) \\/ I[Service])
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied~;svcNoSvcCompReqsSatisfied /\\ -I[Service]
              // <=> { svcNoSvcCompReqsSatisfied is symmetric }
              //     svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied /\\ -I[Service]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" ""),ECpl (EDcI Service))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied /\\ -I[Service] ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                 FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgService`=ECps1.`SrcService`
                               ) AS isect0
                          WHERE isect0.`SrcService` <> isect0.`TrgService` AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ svcNoSvcCompReqsSatisfied::Service*Service' =>
        array ( 'name'          => 'INJ svcNoSvcCompReqsSatisfied::Service*Service'
              , 'ruleAdl'       => 'svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied~ |- I[Service]'
              , 'origin'        => 'line 165:27, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning'       => 'svcNoSvcCompReqsSatisfied[Service\\*Service] is injectief'
              , 'message'       => 'svcNoSvcCompReqsSatisfied[Service\\*Service] is niet injectief'
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied~ |- I[Service])
              // <=> { remove |- }
              //     -(-(svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied~) \\/ I[Service])
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied~ /\\ -I[Service]
              // <=> { svcNoSvcCompReqsSatisfied is symmetric }
              //     svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied /\\ -I[Service]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" "",EDcD RELATION svcNoSvcCompReqsSatisfied [Service*Service] Nothing PRAGMA "" "" ""),ECpl (EDcI Service))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied /\\ -I[Service] ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                 FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Service` AS `SrcService`, `svcNoSvcCompReqsSatisfied` AS `TrgService`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcNoSvcCompReqsSatisfied` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgService`=ECps1.`SrcService`
                               ) AS isect0
                          WHERE isect0.`SrcService` <> isect0.`TrgService` AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM connectComputerToNetworkRouter::Computer*Computer' =>
        array ( 'name'          => 'SYM connectComputerToNetworkRouter::Computer*Computer'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter = connectComputerToNetworkRouter~'
              , 'origin'        => 'line 15:32, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => 'connectComputerToNetworkRouter[Computer] is symmetrisch.'
              , 'message'       => 'connectComputerToNetworkRouter[Computer] is niet symmetrisch.'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter = connectComputerToNetworkRouter~)
              // <=> { remove = }
              //     -((connectComputerToNetworkRouter |- connectComputerToNetworkRouter~) /\\ (connectComputerToNetworkRouter~ |- connectComputerToNetworkRouter))
              // <=> { remove |- and remove |- }
              //     -((-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter~) /\\ (-connectComputerToNetworkRouter~ \\/ connectComputerToNetworkRouter))
              // <=> { connectComputerToNetworkRouter is symmetric and connectComputerToNetworkRouter is symmetric }
              //     -((-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter) /\\ (-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter))
              // <=> { -connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter /\\ -connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter = -connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter }
              //     -(-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter)
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter /\\ -connectComputerToNetworkRouter
              // <=> { connectComputerToNetworkRouter /\\ -connectComputerToNetworkRouter = V- }
              //     -V[Computer*Computer]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [Computer*Computer])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Computer*Computer] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY connectComputerToNetworkRouter::Computer*Computer' =>
        array ( 'name'          => 'ASY connectComputerToNetworkRouter::Computer*Computer'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter~ /\\ connectComputerToNetworkRouter |- I[Computer]'
              , 'origin'        => 'line 15:32, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => 'connectComputerToNetworkRouter[Computer] is antisymmetrisch.'
              , 'message'       => 'connectComputerToNetworkRouter[Computer] is niet antisymmetrisch.'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter~ /\\ connectComputerToNetworkRouter |- I[Computer])
              // <=> { remove |- }
              //     -(-(connectComputerToNetworkRouter~ /\\ connectComputerToNetworkRouter) \\/ I[Computer])
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter~ /\\ (connectComputerToNetworkRouter /\\ -I[Computer])
              // <=> { connectComputerToNetworkRouter is symmetric }
              //     connectComputerToNetworkRouter /\\ (connectComputerToNetworkRouter /\\ -I[Computer])
              // <=> { connectComputerToNetworkRouter /\\ connectComputerToNetworkRouter = connectComputerToNetworkRouter }
              //     connectComputerToNetworkRouter /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION connectComputerToNetworkRouter [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             connectComputerToNetworkRouter /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `connectComputerToNetworkRouter` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `connectComputerToNetworkRouter` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI connectComputerToNetworkRouter::Computer*Computer' =>
        array ( 'name'          => 'UNI connectComputerToNetworkRouter::Computer*Computer'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter~;connectComputerToNetworkRouter |- I[Computer]'
              , 'origin'        => 'line 15:32, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => 'connectComputerToNetworkRouter[Computer\\*Computer] is univalent'
              , 'message'       => 'connectComputerToNetworkRouter[Computer\\*Computer] is niet univalent'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter~;connectComputerToNetworkRouter |- I[Computer])
              // <=> { remove |- }
              //     -(-(connectComputerToNetworkRouter~;connectComputerToNetworkRouter) \\/ I[Computer])
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter~;connectComputerToNetworkRouter /\\ -I[Computer]
              // <=> { connectComputerToNetworkRouter is symmetric }
              //     connectComputerToNetworkRouter;connectComputerToNetworkRouter /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION connectComputerToNetworkRouter [Computer*Computer] Nothing PRAGMA "" "" "",EDcD RELATION connectComputerToNetworkRouter [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             connectComputerToNetworkRouter;connectComputerToNetworkRouter /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    connectComputerToNetworkRouter;connectComputerToNetworkRouter */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `connectComputerToNetworkRouter` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `connectComputerToNetworkRouter` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `connectComputerToNetworkRouter` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `connectComputerToNetworkRouter` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ connectComputerToNetworkRouter::Computer*Computer' =>
        array ( 'name'          => 'INJ connectComputerToNetworkRouter::Computer*Computer'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter;connectComputerToNetworkRouter~ |- I[Computer]'
              , 'origin'        => 'line 15:32, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => 'connectComputerToNetworkRouter[Computer\\*Computer] is injectief'
              , 'message'       => 'connectComputerToNetworkRouter[Computer\\*Computer] is niet injectief'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter;connectComputerToNetworkRouter~ |- I[Computer])
              // <=> { remove |- }
              //     -(-(connectComputerToNetworkRouter;connectComputerToNetworkRouter~) \\/ I[Computer])
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter;connectComputerToNetworkRouter~ /\\ -I[Computer]
              // <=> { connectComputerToNetworkRouter is symmetric }
              //     connectComputerToNetworkRouter;connectComputerToNetworkRouter /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION connectComputerToNetworkRouter [Computer*Computer] Nothing PRAGMA "" "" "",EDcD RELATION connectComputerToNetworkRouter [Computer*Computer] Nothing PRAGMA "" "" ""),ECpl (EDcI Computer))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             connectComputerToNetworkRouter;connectComputerToNetworkRouter /\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    connectComputerToNetworkRouter;connectComputerToNetworkRouter */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `connectComputerToNetworkRouter` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `connectComputerToNetworkRouter` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `connectComputerToNetworkRouter` AS `TrgComputer`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `connectComputerToNetworkRouter` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM startRunningServiceComponents::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'SYM startRunningServiceComponents::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'startRunningServiceComponents = startRunningServiceComponents~'
              , 'origin'        => 'line 68:31, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => 'startRunningServiceComponents[SvcComponent] is symmetrisch.'
              , 'message'       => 'startRunningServiceComponents[SvcComponent] is niet symmetrisch.'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(startRunningServiceComponents = startRunningServiceComponents~)
              // <=> { remove = }
              //     -((startRunningServiceComponents |- startRunningServiceComponents~) /\\ (startRunningServiceComponents~ |- startRunningServiceComponents))
              // <=> { remove |- and remove |- }
              //     -((-startRunningServiceComponents \\/ startRunningServiceComponents~) /\\ (-startRunningServiceComponents~ \\/ startRunningServiceComponents))
              // <=> { startRunningServiceComponents is symmetric and startRunningServiceComponents is symmetric }
              //     -((-startRunningServiceComponents \\/ startRunningServiceComponents) /\\ (-startRunningServiceComponents \\/ startRunningServiceComponents))
              // <=> { -startRunningServiceComponents \\/ startRunningServiceComponents /\\ -startRunningServiceComponents \\/ startRunningServiceComponents = -startRunningServiceComponents \\/ startRunningServiceComponents }
              //     -(-startRunningServiceComponents \\/ startRunningServiceComponents)
              // <=> { De Morgan }
              //     startRunningServiceComponents /\\ -startRunningServiceComponents
              // <=> { startRunningServiceComponents /\\ -startRunningServiceComponents = V- }
              //     -V[SvcComponent*SvcComponent]
              // 
              // Normalized complement (== violationsSQL): ECpl (EDcV [SvcComponent*SvcComponent])
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [SvcComponent*SvcComponent] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY startRunningServiceComponents::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'ASY startRunningServiceComponents::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'startRunningServiceComponents~ /\\ startRunningServiceComponents |- I[SvcComponent]'
              , 'origin'        => 'line 68:31, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => 'startRunningServiceComponents[SvcComponent] is antisymmetrisch.'
              , 'message'       => 'startRunningServiceComponents[SvcComponent] is niet antisymmetrisch.'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(startRunningServiceComponents~ /\\ startRunningServiceComponents |- I[SvcComponent])
              // <=> { remove |- }
              //     -(-(startRunningServiceComponents~ /\\ startRunningServiceComponents) \\/ I[SvcComponent])
              // <=> { De Morgan }
              //     startRunningServiceComponents~ /\\ (startRunningServiceComponents /\\ -I[SvcComponent])
              // <=> { startRunningServiceComponents is symmetric }
              //     startRunningServiceComponents /\\ (startRunningServiceComponents /\\ -I[SvcComponent])
              // <=> { startRunningServiceComponents /\\ startRunningServiceComponents = startRunningServiceComponents }
              //     startRunningServiceComponents /\\ -I[SvcComponent]
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcD RELATION startRunningServiceComponents [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",ECpl (EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             startRunningServiceComponents /\\ -I[SvcComponent] ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `startRunningServiceComponents` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `startRunningServiceComponents` IS NOT NULL ) AS isect0
                          WHERE isect0.`SrcSvcComponent` <> isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI startRunningServiceComponents::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'UNI startRunningServiceComponents::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'startRunningServiceComponents~;startRunningServiceComponents |- I[SvcComponent]'
              , 'origin'        => 'line 68:31, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => 'startRunningServiceComponents[SvcComponent\\*SvcComponent] is univalent'
              , 'message'       => 'startRunningServiceComponents[SvcComponent\\*SvcComponent] is niet\nunivalent'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(startRunningServiceComponents~;startRunningServiceComponents |- I[SvcComponent])
              // <=> { remove |- }
              //     -(-(startRunningServiceComponents~;startRunningServiceComponents) \\/ I[SvcComponent])
              // <=> { De Morgan }
              //     startRunningServiceComponents~;startRunningServiceComponents /\\ -I[SvcComponent]
              // <=> { startRunningServiceComponents is symmetric }
              //     startRunningServiceComponents;startRunningServiceComponents /\\ -I[SvcComponent]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION startRunningServiceComponents [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION startRunningServiceComponents [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""),ECpl (EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             startRunningServiceComponents;startRunningServiceComponents /\\ -I[SvcComponent] ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    startRunningServiceComponents;startRunningServiceComponents */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `startRunningServiceComponents` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `startRunningServiceComponents` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `startRunningServiceComponents` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `startRunningServiceComponents` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcSvcComponent` <> isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ startRunningServiceComponents::SvcComponent*SvcComponent' =>
        array ( 'name'          => 'INJ startRunningServiceComponents::SvcComponent*SvcComponent'
              , 'ruleAdl'       => 'startRunningServiceComponents;startRunningServiceComponents~ |- I[SvcComponent]'
              , 'origin'        => 'line 68:31, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning'       => 'startRunningServiceComponents[SvcComponent\\*SvcComponent] is injectief'
              , 'message'       => 'startRunningServiceComponents[SvcComponent\\*SvcComponent] is niet\ninjectief'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(startRunningServiceComponents;startRunningServiceComponents~ |- I[SvcComponent])
              // <=> { remove |- }
              //     -(-(startRunningServiceComponents;startRunningServiceComponents~) \\/ I[SvcComponent])
              // <=> { De Morgan }
              //     startRunningServiceComponents;startRunningServiceComponents~ /\\ -I[SvcComponent]
              // <=> { startRunningServiceComponents is symmetric }
              //     startRunningServiceComponents;startRunningServiceComponents /\\ -I[SvcComponent]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EDcD RELATION startRunningServiceComponents [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION startRunningServiceComponents [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""),ECpl (EDcI SvcComponent))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             startRunningServiceComponents;startRunningServiceComponents /\\ -I[SvcComponent] ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    startRunningServiceComponents;startRunningServiceComponents */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `startRunningServiceComponents` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `startRunningServiceComponents` IS NOT NULL ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `startRunningServiceComponents` AS `TrgSvcComponent`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `startRunningServiceComponents` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcSvcComponent` <> isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI planID::Plan*PlanID' =>
        array ( 'name'          => 'UNI planID::Plan*PlanID'
              , 'ruleAdl'       => 'planID~;planID |- I[PlanID]'
              , 'origin'        => 'line 5:8, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'planID[Plan\\*PlanID] is univalent'
              , 'message'       => 'planID[Plan\\*PlanID] is niet univalent'
              , 'srcConcept'    => 'PlanID'
              , 'tgtConcept'    => 'PlanID'
              // Normalization steps:
              //     -(planID~;planID |- I[PlanID])
              // <=> { remove |- }
              //     -(-(planID~;planID) \\/ I[PlanID])
              // <=> { De Morgan }
              //     planID~;planID /\\ -I[PlanID]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION planID [Plan*PlanID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ A Plan is identified by its PlanID -}),EDcD RELATION planID [Plan*PlanID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ A Plan is identified by its PlanID +}),ECpl (EDcI PlanID))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             planID~;planID /\\ -I[PlanID] ([PlanID*PlanID]) */
                          SELECT DISTINCT isect0.`SrcPlanID` AS src, isect0.`TrgPlanID` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    planID~;planID */
                                 
                                 SELECT DISTINCT ECps0.`SrcPlanID`, ECps1.`TrgPlanID`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan` AS `TrgPlan`, `planID` AS `SrcPlanID`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planID` AS `TrgPlanID`
                                   FROM `Plan`
                                   WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgPlan`=ECps1.`SrcPlan`
                               ) AS isect0
                          WHERE isect0.`SrcPlanID` <> isect0.`TrgPlanID` AND isect0.`SrcPlanID` IS NOT NULL AND isect0.`TrgPlanID` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT planID::Plan*PlanID' =>
        array ( 'name'          => 'TOT planID::Plan*PlanID'
              , 'ruleAdl'       => 'I[Plan] |- planID;planID~'
              , 'origin'        => 'line 5:8, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'planID[Plan\\*PlanID] is totaal'
              , 'message'       => 'planID[Plan\\*PlanID] is niet totaal'
              , 'srcConcept'    => 'Plan'
              , 'tgtConcept'    => 'Plan'
              // Normalization steps:
              //     -(I[Plan] |- planID;planID~)
              // <=> { remove |- }
              //     -(-I[Plan] \\/ planID;planID~)
              // <=> { De Morgan }
              //     I[Plan] /\\ -(planID;planID~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Plan,ECpl (ECps (EDcD RELATION planID [Plan*PlanID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ A Plan is identified by its PlanID -},EFlp (EDcD RELATION planID [Plan*PlanID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ A Plan is identified by its PlanID +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Plan] /\\ -(planID;planID~) ([Plan*Plan]) */
                          SELECT DISTINCT isect0.`SrcPlan` AS src, isect0.`TrgPlan` AS tgt
                          FROM ( /* I[Plan] */
                            SELECT DISTINCT `Plan` AS `SrcPlan`, `Plan` AS `TrgPlan`
                            FROM `Plan`
                            WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                planID;planID~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcPlan`, ECps1.`TrgPlan`
                                             FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planID` AS `TrgPlanID`
                                               FROM `Plan`
                                               WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan` AS `TrgPlan`, `planID` AS `SrcPlanID`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgPlanID`=ECps1.`SrcPlanID`
                                           ) AS cp
                                      WHERE isect0.`SrcPlan`=cp.`SrcPlan` AND isect0.`TrgPlan`=cp.`TrgPlan`) AND isect0.`SrcPlan` IS NOT NULL AND isect0.`TrgPlan` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI planStatus::Plan*Status' =>
        array ( 'name'          => 'UNI planStatus::Plan*Status'
              , 'ruleAdl'       => 'planStatus~;planStatus |- I[Status]'
              , 'origin'        => 'line 7:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'planStatus[Plan\\*Status] is univalent'
              , 'message'       => 'planStatus[Plan\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(planStatus~;planStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(planStatus~;planStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     planStatus~;planStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION planStatus [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can have a status (colour) -}),EDcD RELATION planStatus [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can have a status (colour) +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             planStatus~;planStatus /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    planStatus~;planStatus */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan` AS `TrgPlan`, `planStatus` AS `SrcStatus`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planStatus` AS `TrgStatus`
                                   FROM `Plan`
                                   WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgPlan`=ECps1.`SrcPlan`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI planMnlStat::Plan*Status' =>
        array ( 'name'          => 'UNI planMnlStat::Plan*Status'
              , 'ruleAdl'       => 'planMnlStat~;planMnlStat |- I[Status]'
              , 'origin'        => 'line 9:13, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'planMnlStat[Plan\\*Status] is univalent'
              , 'message'       => 'planMnlStat[Plan\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(planMnlStat~;planMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(planMnlStat~;planMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     planMnlStat~;planMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION planMnlStat [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can be assigned a new status -}),EDcD RELATION planMnlStat [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can be assigned a new status +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             planMnlStat~;planMnlStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    planMnlStat~;planMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan` AS `TrgPlan`, `planMnlStat` AS `SrcStatus`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Plan` AS `SrcPlan`, `planMnlStat` AS `TrgStatus`
                                   FROM `Plan`
                                   WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgPlan`=ECps1.`SrcPlan`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI atStatus::ActivityType*Status' =>
        array ( 'name'          => 'UNI atStatus::ActivityType*Status'
              , 'ruleAdl'       => 'atStatus~;atStatus |- I[Status]'
              , 'origin'        => 'line 16:10, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'atStatus[ActivityType\\*Status] is univalent'
              , 'message'       => 'atStatus[ActivityType\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(atStatus~;atStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(atStatus~;atStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     atStatus~;atStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION atStatus [ActivityType*Status] Nothing PRAGMA "" "" ""),EDcD RELATION atStatus [ActivityType*Status] Nothing PRAGMA "" "" ""),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             atStatus~;atStatus /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    atStatus~;atStatus */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ActivityType` AS `TrgActivityType`, `atStatus` AS `SrcStatus`
                                        FROM `ActivityType`
                                        WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `atStatus` AS `TrgStatus`
                                   FROM `ActivityType`
                                   WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI svcID::Service*ServiceID' =>
        array ( 'name'          => 'UNI svcID::Service*ServiceID'
              , 'ruleAdl'       => 'svcID~;svcID |- I[ServiceID]'
              , 'origin'        => 'line 25:7, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'svcID[Service\\*ServiceID] is univalent'
              , 'message'       => 'svcID[Service\\*ServiceID] is niet univalent'
              , 'srcConcept'    => 'ServiceID'
              , 'tgtConcept'    => 'ServiceID'
              // Normalization steps:
              //     -(svcID~;svcID |- I[ServiceID])
              // <=> { remove |- }
              //     -(-(svcID~;svcID) \\/ I[ServiceID])
              // <=> { De Morgan }
              //     svcID~;svcID /\\ -I[ServiceID]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION svcID [Service*ServiceID] Nothing PRAGMA "" "" ""),EDcD RELATION svcID [Service*ServiceID] Nothing PRAGMA "" "" ""),ECpl (EDcI ServiceID))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcID~;svcID /\\ -I[ServiceID] ([ServiceID*ServiceID]) */
                          SELECT DISTINCT isect0.`SrcServiceID` AS src, isect0.`TrgServiceID` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    svcID~;svcID */
                                 
                                 SELECT DISTINCT ECps0.`SrcServiceID`, ECps1.`TrgServiceID`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Service` AS `TrgService`, `svcID` AS `SrcServiceID`
                                        FROM `Service`
                                        WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Service` AS `SrcService`, `svcID` AS `TrgServiceID`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgService`=ECps1.`SrcService`
                               ) AS isect0
                          WHERE isect0.`SrcServiceID` <> isect0.`TrgServiceID` AND isect0.`SrcServiceID` IS NOT NULL AND isect0.`TrgServiceID` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT svcID::Service*ServiceID' =>
        array ( 'name'          => 'TOT svcID::Service*ServiceID'
              , 'ruleAdl'       => 'I[Service] |- svcID;svcID~'
              , 'origin'        => 'line 25:7, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'svcID[Service\\*ServiceID] is totaal'
              , 'message'       => 'svcID[Service\\*ServiceID] is niet totaal'
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(I[Service] |- svcID;svcID~)
              // <=> { remove |- }
              //     -(-I[Service] \\/ svcID;svcID~)
              // <=> { De Morgan }
              //     I[Service] /\\ -(svcID;svcID~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Service,ECpl (ECps (EDcD RELATION svcID [Service*ServiceID] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION svcID [Service*ServiceID] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Service] /\\ -(svcID;svcID~) ([Service*Service]) */
                          SELECT DISTINCT isect0.`SrcService` AS src, isect0.`TrgService` AS tgt
                          FROM ( /* I[Service] */
                            SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                            FROM `Service`
                            WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                svcID;svcID~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                             FROM ( SELECT DISTINCT `Service` AS `SrcService`, `svcID` AS `TrgServiceID`
                                               FROM `Service`
                                               WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Service` AS `TrgService`, `svcID` AS `SrcServiceID`
                                                    FROM `Service`
                                                    WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgServiceID`=ECps1.`SrcServiceID`
                                           ) AS cp
                                      WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI svcStatus::Service*Status' =>
        array ( 'name'          => 'UNI svcStatus::Service*Status'
              , 'ruleAdl'       => 'svcStatus~;svcStatus |- I[Status]'
              , 'origin'        => 'line 26:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'svcStatus[Service\\*Status] is univalent'
              , 'message'       => 'svcStatus[Service\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(svcStatus~;svcStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(svcStatus~;svcStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     svcStatus~;svcStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" ""),EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" ""),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             svcStatus~;svcStatus /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    svcStatus~;svcStatus */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Service` AS `TrgService`, `svcStatus` AS `SrcStatus`
                                        FROM `Service`
                                        WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Service` AS `SrcService`, `svcStatus` AS `TrgStatus`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgService`=ECps1.`SrcService`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actType::Activity*ActivityType' =>
        array ( 'name'          => 'UNI actType::Activity*ActivityType'
              , 'ruleAdl'       => 'actType~;actType |- I[ActivityType]'
              , 'origin'        => 'line 30:9, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actType[Activity\\*ActivityType] is univalent'
              , 'message'       => 'actType[Activity\\*ActivityType] is niet univalent'
              , 'srcConcept'    => 'ActivityType'
              , 'tgtConcept'    => 'ActivityType'
              // Normalization steps:
              //     -(actType~;actType |- I[ActivityType])
              // <=> { remove |- }
              //     -(-(actType~;actType) \\/ I[ActivityType])
              // <=> { De Morgan }
              //     actType~;actType /\\ -I[ActivityType]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -}),EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType +}),ECpl (EDcI ActivityType))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actType~;actType /\\ -I[ActivityType] ([ActivityType*ActivityType]) */
                          SELECT DISTINCT isect0.`SrcActivityType` AS src, isect0.`TrgActivityType` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actType~;actType */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actType` AS `SrcActivityType`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcActivityType` <> isect0.`TrgActivityType` AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT actType::Activity*ActivityType' =>
        array ( 'name'          => 'TOT actType::Activity*ActivityType'
              , 'ruleAdl'       => 'I[Activity] |- actType;actType~'
              , 'origin'        => 'line 30:9, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actType[Activity\\*ActivityType] is totaal'
              , 'message'       => 'actType[Activity\\*ActivityType] is niet totaal'
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] |- actType;actType~)
              // <=> { remove |- }
              //     -(-I[Activity] \\/ actType;actType~)
              // <=> { De Morgan }
              //     I[Activity] /\\ -(actType;actType~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Activity,ECpl (ECps (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -},EFlp (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Activity] /\\ -(actType;actType~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgActivity` AS tgt
                          FROM ( /* I[Activity] */
                            SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                            FROM `Activity`
                            WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actType;actType~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                               FROM `Activity`
                                               WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity` AS `TrgActivity`, `actType` AS `SrcActivityType`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actID::Activity*ActivityID' =>
        array ( 'name'          => 'UNI actID::Activity*ActivityID'
              , 'ruleAdl'       => 'actID~;actID |- I[ActivityID]'
              , 'origin'        => 'line 32:7, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actID[Activity\\*ActivityID] is univalent'
              , 'message'       => 'actID[Activity\\*ActivityID] is niet univalent'
              , 'srcConcept'    => 'ActivityID'
              , 'tgtConcept'    => 'ActivityID'
              // Normalization steps:
              //     -(actID~;actID |- I[ActivityID])
              // <=> { remove |- }
              //     -(-(actID~;actID) \\/ I[ActivityID])
              // <=> { De Morgan }
              //     actID~;actID /\\ -I[ActivityID]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actID [Activity*ActivityID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is identified by its ActivityID -}),EDcD RELATION actID [Activity*ActivityID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is identified by its ActivityID +}),ECpl (EDcI ActivityID))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actID~;actID /\\ -I[ActivityID] ([ActivityID*ActivityID]) */
                          SELECT DISTINCT isect0.`SrcActivityID` AS src, isect0.`TrgActivityID` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actID~;actID */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivityID`, ECps1.`TrgActivityID`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actID` AS `SrcActivityID`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actID` AS `TrgActivityID`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcActivityID` <> isect0.`TrgActivityID` AND isect0.`SrcActivityID` IS NOT NULL AND isect0.`TrgActivityID` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT actID::Activity*ActivityID' =>
        array ( 'name'          => 'TOT actID::Activity*ActivityID'
              , 'ruleAdl'       => 'I[Activity] |- actID;actID~'
              , 'origin'        => 'line 32:7, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actID[Activity\\*ActivityID] is totaal'
              , 'message'       => 'actID[Activity\\*ActivityID] is niet totaal'
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] |- actID;actID~)
              // <=> { remove |- }
              //     -(-I[Activity] \\/ actID;actID~)
              // <=> { De Morgan }
              //     I[Activity] /\\ -(actID;actID~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Activity,ECpl (ECps (EDcD RELATION actID [Activity*ActivityID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is identified by its ActivityID -},EFlp (EDcD RELATION actID [Activity*ActivityID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is identified by its ActivityID +}))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Activity] /\\ -(actID;actID~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgActivity` AS tgt
                          FROM ( /* I[Activity] */
                            SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                            FROM `Activity`
                            WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                actID;actID~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                             FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actID` AS `TrgActivityID`
                                               FROM `Activity`
                                               WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity` AS `TrgActivity`, `actID` AS `SrcActivityID`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgActivityID`=ECps1.`SrcActivityID`
                                           ) AS cp
                                      WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actStatus::Activity*Status' =>
        array ( 'name'          => 'UNI actStatus::Activity*Status'
              , 'ruleAdl'       => 'actStatus~;actStatus |- I[Status]'
              , 'origin'        => 'line 34:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actStatus[Activity\\*Status] is univalent'
              , 'message'       => 'actStatus[Activity\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(actStatus~;actStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(actStatus~;actStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     actStatus~;actStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actStatus [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can have a status (colour) -}),EDcD RELATION actStatus [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can have a status (colour) +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actStatus~;actStatus /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actStatus~;actStatus */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actStatus` AS `SrcStatus`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actStatus` AS `TrgStatus`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actMnlStat::Activity*Status' =>
        array ( 'name'          => 'UNI actMnlStat::Activity*Status'
              , 'ruleAdl'       => 'actMnlStat~;actMnlStat |- I[Status]'
              , 'origin'        => 'line 36:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actMnlStat[Activity\\*Status] is univalent'
              , 'message'       => 'actMnlStat[Activity\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(actMnlStat~;actMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(actMnlStat~;actMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     actMnlStat~;actMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actMnlStat [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can be assigned a new status -}),EDcD RELATION actMnlStat [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can be assigned a new status +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actMnlStat~;actMnlStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actMnlStat~;actMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actMnlStat` AS `SrcStatus`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actMnlStat` AS `TrgStatus`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actExecutingOU::Activity*OrgUnit' =>
        array ( 'name'          => 'UNI actExecutingOU::Activity*OrgUnit'
              , 'ruleAdl'       => 'actExecutingOU~;actExecutingOU |- I[OrgUnit]'
              , 'origin'        => 'line 39:16, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actExecutingOU[Activity\\*OrgUnit] is univalent'
              , 'message'       => 'actExecutingOU[Activity\\*OrgUnit] is niet univalent'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(actExecutingOU~;actExecutingOU |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(actExecutingOU~;actExecutingOU) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     actExecutingOU~;actExecutingOU /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -}),EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit +}),ECpl (EDcI OrgUnit))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actExecutingOU~;actExecutingOU /\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS src, isect0.`TrgOrgUnit` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU~;actExecutingOU */
                                 
                                 SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgOrgUnit`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actExecutingOU` AS `TrgOrgUnit`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcOrgUnit` <> isect0.`TrgOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actPlan::Activity*Plan' =>
        array ( 'name'          => 'UNI actPlan::Activity*Plan'
              , 'ruleAdl'       => 'actPlan~;actPlan |- I[Plan]'
              , 'origin'        => 'line 44:9, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actPlan[Activity\\*Plan] is univalent'
              , 'message'       => 'actPlan[Activity\\*Plan] is niet univalent'
              , 'srcConcept'    => 'Plan'
              , 'tgtConcept'    => 'Plan'
              // Normalization steps:
              //     -(actPlan~;actPlan |- I[Plan])
              // <=> { remove |- }
              //     -(-(actPlan~;actPlan) \\/ I[Plan])
              // <=> { De Morgan }
              //     actPlan~;actPlan /\\ -I[Plan]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actPlan [Activity*Plan] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is according to the plan -}),EDcD RELATION actPlan [Activity*Plan] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is according to the plan +}),ECpl (EDcI Plan))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actPlan~;actPlan /\\ -I[Plan] ([Plan*Plan]) */
                          SELECT DISTINCT isect0.`SrcPlan` AS src, isect0.`TrgPlan` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actPlan~;actPlan */
                                 
                                 SELECT DISTINCT ECps0.`SrcPlan`, ECps1.`TrgPlan`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlan` AS `SrcPlan`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actPlan` AS `TrgPlan`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcPlan` <> isect0.`TrgPlan` AND isect0.`SrcPlan` IS NOT NULL AND isect0.`TrgPlan` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actPlanStart::Activity*Timestamp' =>
        array ( 'name'          => 'UNI actPlanStart::Activity*Timestamp'
              , 'ruleAdl'       => 'actPlanStart~;actPlanStart |- I[Timestamp]'
              , 'origin'        => 'line 49:14, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actPlanStart[Activity\\*Timestamp] is univalent'
              , 'message'       => 'actPlanStart[Activity\\*Timestamp] is niet univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(actPlanStart~;actPlanStart |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(actPlanStart~;actPlanStart) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     actPlanStart~;actPlanStart /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. -}),EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. +}),ECpl (EDcI Timestamp))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actPlanStart~;actPlanStart /\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS src, isect0.`TrgTimestamp` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actPlanStart~;actPlanStart */
                                 
                                 SELECT DISTINCT ECps0.`SrcTimestamp`, ECps1.`TrgTimestamp`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlanStart` AS `SrcTimestamp`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actPlanStart` AS `TrgTimestamp`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TrgTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TrgTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actPlanEnd::Activity*Timestamp' =>
        array ( 'name'          => 'UNI actPlanEnd::Activity*Timestamp'
              , 'ruleAdl'       => 'actPlanEnd~;actPlanEnd |- I[Timestamp]'
              , 'origin'        => 'line 51:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actPlanEnd[Activity\\*Timestamp] is univalent'
              , 'message'       => 'actPlanEnd[Activity\\*Timestamp] is niet univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(actPlanEnd~;actPlanEnd |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(actPlanEnd~;actPlanEnd) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     actPlanEnd~;actPlanEnd /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actPlanEnd [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to end at the specified time. -}),EDcD RELATION actPlanEnd [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to end at the specified time. +}),ECpl (EDcI Timestamp))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actPlanEnd~;actPlanEnd /\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS src, isect0.`TrgTimestamp` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actPlanEnd~;actPlanEnd */
                                 
                                 SELECT DISTINCT ECps0.`SrcTimestamp`, ECps1.`TrgTimestamp`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlanEnd` AS `SrcTimestamp`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlanEnd` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actPlanEnd` AS `TrgTimestamp`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actPlanEnd` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TrgTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TrgTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actStartTime::Activity*Timestamp' =>
        array ( 'name'          => 'UNI actStartTime::Activity*Timestamp'
              , 'ruleAdl'       => 'actStartTime~;actStartTime |- I[Timestamp]'
              , 'origin'        => 'line 53:14, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actStartTime[Activity\\*Timestamp] is univalent'
              , 'message'       => 'actStartTime[Activity\\*Timestamp] is niet univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(actStartTime~;actStartTime |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(actStartTime~;actStartTime) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     actStartTime~;actStartTime /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actStartTime [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is actually started at the specified time. -}),EDcD RELATION actStartTime [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is actually started at the specified time. +}),ECpl (EDcI Timestamp))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actStartTime~;actStartTime /\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS src, isect0.`TrgTimestamp` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actStartTime~;actStartTime */
                                 
                                 SELECT DISTINCT ECps0.`SrcTimestamp`, ECps1.`TrgTimestamp`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actStartTime` AS `SrcTimestamp`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actStartTime` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actStartTime` AS `TrgTimestamp`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actStartTime` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TrgTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TrgTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actEndTime::Activity*Timestamp' =>
        array ( 'name'          => 'UNI actEndTime::Activity*Timestamp'
              , 'ruleAdl'       => 'actEndTime~;actEndTime |- I[Timestamp]'
              , 'origin'        => 'line 55:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actEndTime[Activity\\*Timestamp] is univalent'
              , 'message'       => 'actEndTime[Activity\\*Timestamp] is niet univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(actEndTime~;actEndTime |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(actEndTime~;actEndTime) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     actEndTime~;actEndTime /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION actEndTime [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is actually ended at the specified time. -}),EDcD RELATION actEndTime [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is actually ended at the specified time. +}),ECpl (EDcI Timestamp))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             actEndTime~;actEndTime /\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS src, isect0.`TrgTimestamp` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actEndTime~;actEndTime */
                                 
                                 SELECT DISTINCT ECps0.`SrcTimestamp`, ECps1.`TrgTimestamp`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity` AS `TrgActivity`, `actEndTime` AS `SrcTimestamp`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actEndTime` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actEndTime` AS `TrgTimestamp`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL AND `actEndTime` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TrgTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TrgTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI ouStatus::OrgUnit*Status' =>
        array ( 'name'          => 'UNI ouStatus::OrgUnit*Status'
              , 'ruleAdl'       => 'ouStatus~;ouStatus |- I[Status]'
              , 'origin'        => 'line 62:10, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'ouStatus[OrgUnit\\*Status] is univalent'
              , 'message'       => 'ouStatus[OrgUnit\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(ouStatus~;ouStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(ouStatus~;ouStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     ouStatus~;ouStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION ouStatus [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can have a status (colour) -}),EDcD RELATION ouStatus [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can have a status (colour) +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             ouStatus~;ouStatus /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ouStatus~;ouStatus */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `ouStatus` AS `SrcStatus`
                                        FROM `OrgUnit`
                                        WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ouStatus` AS `TrgStatus`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI ouMnlStat::OrgUnit*Status' =>
        array ( 'name'          => 'UNI ouMnlStat::OrgUnit*Status'
              , 'ruleAdl'       => 'ouMnlStat~;ouMnlStat |- I[Status]'
              , 'origin'        => 'line 64:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'ouMnlStat[OrgUnit\\*Status] is univalent'
              , 'message'       => 'ouMnlStat[OrgUnit\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(ouMnlStat~;ouMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(ouMnlStat~;ouMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     ouMnlStat~;ouMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION ouMnlStat [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can be assigned a new status -}),EDcD RELATION ouMnlStat [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can be assigned a new status +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             ouMnlStat~;ouMnlStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ouMnlStat~;ouMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `ouMnlStat` AS `SrcStatus`
                                        FROM `OrgUnit`
                                        WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ouMnlStat` AS `TrgStatus`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scStatus::SvcComponent*Status' =>
        array ( 'name'          => 'UNI scStatus::SvcComponent*Status'
              , 'ruleAdl'       => 'scStatus~;scStatus |- I[Status]'
              , 'origin'        => 'line 73:10, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'scStatus[SvcComponent\\*Status] is univalent'
              , 'message'       => 'scStatus[SvcComponent\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(scStatus~;scStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(scStatus~;scStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     scStatus~;scStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) -}),EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scStatus~;scStatus /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scStatus~;scStatus */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scStatus` AS `SrcStatus`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scStatus` AS `TrgStatus`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scMnlStat::SvcComponent*Status' =>
        array ( 'name'          => 'UNI scMnlStat::SvcComponent*Status'
              , 'ruleAdl'       => 'scMnlStat~;scMnlStat |- I[Status]'
              , 'origin'        => 'line 75:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'scMnlStat[SvcComponent\\*Status] is univalent'
              , 'message'       => 'scMnlStat[SvcComponent\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(scMnlStat~;scMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(scMnlStat~;scMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     scMnlStat~;scMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION scMnlStat [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can be assigned a new status -}),EDcD RELATION scMnlStat [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can be assigned a new status +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scMnlStat~;scMnlStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scMnlStat~;scMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scMnlStat` AS `SrcStatus`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scMnlStat` AS `TrgStatus`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compID::Computer*ComputerID' =>
        array ( 'name'          => 'UNI compID::Computer*ComputerID'
              , 'ruleAdl'       => 'compID~;compID |- I[ComputerID]'
              , 'origin'        => 'line 85:8, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'compID[Computer\\*ComputerID] is univalent'
              , 'message'       => 'compID[Computer\\*ComputerID] is niet univalent'
              , 'srcConcept'    => 'ComputerID'
              , 'tgtConcept'    => 'ComputerID'
              // Normalization steps:
              //     -(compID~;compID |- I[ComputerID])
              // <=> { remove |- }
              //     -(-(compID~;compID) \\/ I[ComputerID])
              // <=> { De Morgan }
              //     compID~;compID /\\ -I[ComputerID]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION compID [Computer*ComputerID] Nothing PRAGMA "" "" ""),EDcD RELATION compID [Computer*ComputerID] Nothing PRAGMA "" "" ""),ECpl (EDcI ComputerID))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compID~;compID /\\ -I[ComputerID] ([ComputerID*ComputerID]) */
                          SELECT DISTINCT isect0.`SrcComputerID` AS src, isect0.`TrgComputerID` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compID~;compID */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputerID`, ECps1.`TrgComputerID`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `compID` AS `SrcComputerID`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compID` AS `TrgComputerID`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputerID` <> isect0.`TrgComputerID` AND isect0.`SrcComputerID` IS NOT NULL AND isect0.`TrgComputerID` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT compID::Computer*ComputerID' =>
        array ( 'name'          => 'TOT compID::Computer*ComputerID'
              , 'ruleAdl'       => 'I[Computer] |- compID;compID~'
              , 'origin'        => 'line 85:8, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'compID[Computer\\*ComputerID] is totaal'
              , 'message'       => 'compID[Computer\\*ComputerID] is niet totaal'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] |- compID;compID~)
              // <=> { remove |- }
              //     -(-I[Computer] \\/ compID;compID~)
              // <=> { De Morgan }
              //     I[Computer] /\\ -(compID;compID~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Computer,ECpl (ECps (EDcD RELATION compID [Computer*ComputerID] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION compID [Computer*ComputerID] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Computer] /\\ -(compID;compID~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                          FROM ( /* I[Computer] */
                            SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                            FROM `Computer`
                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                compID;compID~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                             FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compID` AS `TrgComputerID`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer` AS `TrgComputer`, `compID` AS `SrcComputerID`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgComputerID`=ECps1.`SrcComputerID`
                                           ) AS cp
                                      WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compName::Computer*ComputerName' =>
        array ( 'name'          => 'UNI compName::Computer*ComputerName'
              , 'ruleAdl'       => 'compName~;compName |- I[ComputerName]'
              , 'origin'        => 'line 86:10, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'compName[Computer\\*ComputerName] is univalent'
              , 'message'       => 'compName[Computer\\*ComputerName] is niet univalent'
              , 'srcConcept'    => 'ComputerName'
              , 'tgtConcept'    => 'ComputerName'
              // Normalization steps:
              //     -(compName~;compName |- I[ComputerName])
              // <=> { remove |- }
              //     -(-(compName~;compName) \\/ I[ComputerName])
              // <=> { De Morgan }
              //     compName~;compName /\\ -I[ComputerName]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION compName [Computer*ComputerName] Nothing PRAGMA "" "" ""),EDcD RELATION compName [Computer*ComputerName] Nothing PRAGMA "" "" ""),ECpl (EDcI ComputerName))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compName~;compName /\\ -I[ComputerName] ([ComputerName*ComputerName]) */
                          SELECT DISTINCT isect0.`SrcComputerName` AS src, isect0.`TrgComputerName` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compName~;compName */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputerName`, ECps1.`TrgComputerName`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `compName` AS `SrcComputerName`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compName` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compName` AS `TrgComputerName`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compName` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcComputerName` <> isect0.`TrgComputerName` AND isect0.`SrcComputerName` IS NOT NULL AND isect0.`TrgComputerName` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compStatus::Computer*Status' =>
        array ( 'name'          => 'UNI compStatus::Computer*Status'
              , 'ruleAdl'       => 'compStatus~;compStatus |- I[Status]'
              , 'origin'        => 'line 87:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'compStatus[Computer\\*Status] is univalent'
              , 'message'       => 'compStatus[Computer\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(compStatus~;compStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(compStatus~;compStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     compStatus~;compStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) -}),EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compStatus~;compStatus /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compStatus~;compStatus */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `compStatus` AS `SrcStatus`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compStatus` AS `TrgStatus`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compMnlStat::Computer*Status' =>
        array ( 'name'          => 'UNI compMnlStat::Computer*Status'
              , 'ruleAdl'       => 'compMnlStat~;compMnlStat |- I[Status]'
              , 'origin'        => 'line 89:13, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'compMnlStat[Computer\\*Status] is univalent'
              , 'message'       => 'compMnlStat[Computer\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(compMnlStat~;compMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(compMnlStat~;compMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     compMnlStat~;compMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION compMnlStat [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can be assigned a new status -}),EDcD RELATION compMnlStat [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can be assigned a new status +}),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compMnlStat~;compMnlStat /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compMnlStat~;compMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `compMnlStat` AS `SrcStatus`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compMnlStat` AS `TrgStatus`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compOwner::Computer*OrgUnit' =>
        array ( 'name'          => 'UNI compOwner::Computer*OrgUnit'
              , 'ruleAdl'       => 'compOwner~;compOwner |- I[OrgUnit]'
              , 'origin'        => 'line 92:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'compOwner[Computer\\*OrgUnit] is univalent'
              , 'message'       => 'compOwner[Computer\\*OrgUnit] is niet univalent'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(compOwner~;compOwner |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(compOwner~;compOwner) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     compOwner~;compOwner /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" ""),EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" ""),ECpl (EDcI OrgUnit))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             compOwner~;compOwner /\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS src, isect0.`TrgOrgUnit` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compOwner~;compOwner */
                                 
                                 SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgOrgUnit`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `compOwner` AS `SrcOrgUnit`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compOwner` AS `TrgOrgUnit`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                               ) AS isect0
                          WHERE isect0.`SrcOrgUnit` <> isect0.`TrgOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI nwID::Network*NetworkID' =>
        array ( 'name'          => 'UNI nwID::Network*NetworkID'
              , 'ruleAdl'       => 'nwID~;nwID |- I[NetworkID]'
              , 'origin'        => 'line 25:6, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'nwID[Network\\*NetworkID] is univalent'
              , 'message'       => 'nwID[Network\\*NetworkID] is niet univalent'
              , 'srcConcept'    => 'NetworkID'
              , 'tgtConcept'    => 'NetworkID'
              // Normalization steps:
              //     -(nwID~;nwID |- I[NetworkID])
              // <=> { remove |- }
              //     -(-(nwID~;nwID) \\/ I[NetworkID])
              // <=> { De Morgan }
              //     nwID~;nwID /\\ -I[NetworkID]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION nwID [Network*NetworkID] Nothing PRAGMA "" "" ""),EDcD RELATION nwID [Network*NetworkID] Nothing PRAGMA "" "" ""),ECpl (EDcI NetworkID))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwID~;nwID /\\ -I[NetworkID] ([NetworkID*NetworkID]) */
                          SELECT DISTINCT isect0.`SrcNetworkID` AS src, isect0.`TrgNetworkID` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwID~;nwID */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetworkID`, ECps1.`TrgNetworkID`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Network` AS `TrgNetwork`, `nwID` AS `SrcNetworkID`
                                        FROM `Network`
                                        WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwID` AS `TrgNetworkID`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect0
                          WHERE isect0.`SrcNetworkID` <> isect0.`TrgNetworkID` AND isect0.`SrcNetworkID` IS NOT NULL AND isect0.`TrgNetworkID` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT nwID::Network*NetworkID' =>
        array ( 'name'          => 'TOT nwID::Network*NetworkID'
              , 'ruleAdl'       => 'I[Network] |- nwID;nwID~'
              , 'origin'        => 'line 25:6, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'nwID[Network\\*NetworkID] is totaal'
              , 'message'       => 'nwID[Network\\*NetworkID] is niet totaal'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] |- nwID;nwID~)
              // <=> { remove |- }
              //     -(-I[Network] \\/ nwID;nwID~)
              // <=> { De Morgan }
              //     I[Network] /\\ -(nwID;nwID~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Network,ECpl (ECps (EDcD RELATION nwID [Network*NetworkID] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION nwID [Network*NetworkID] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Network] /\\ -(nwID;nwID~) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM ( /* I[Network] */
                            SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                            FROM `Network`
                            WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                nwID;nwID~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                             FROM ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwID` AS `TrgNetworkID`
                                               FROM `Network`
                                               WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network` AS `TrgNetwork`, `nwID` AS `SrcNetworkID`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgNetworkID`=ECps1.`SrcNetworkID`
                                           ) AS cp
                                      WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TrgNetwork`=cp.`TrgNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI nwStatus::Network*Status' =>
        array ( 'name'          => 'UNI nwStatus::Network*Status'
              , 'ruleAdl'       => 'nwStatus~;nwStatus |- I[Status]'
              , 'origin'        => 'line 26:10, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'nwStatus[Network\\*Status] is univalent'
              , 'message'       => 'nwStatus[Network\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(nwStatus~;nwStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(nwStatus~;nwStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     nwStatus~;nwStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" ""),EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" ""),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             nwStatus~;nwStatus /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwStatus~;nwStatus */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Network` AS `TrgNetwork`, `nwStatus` AS `SrcStatus`
                                        FROM `Network`
                                        WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Network` AS `SrcNetwork`, `nwStatus` AS `TrgStatus`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerID::Router*RouterID' =>
        array ( 'name'          => 'UNI routerID::Router*RouterID'
              , 'ruleAdl'       => 'routerID~;routerID |- I[RouterID]'
              , 'origin'        => 'line 45:10, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'routerID[Router\\*RouterID] is univalent'
              , 'message'       => 'routerID[Router\\*RouterID] is niet univalent'
              , 'srcConcept'    => 'RouterID'
              , 'tgtConcept'    => 'RouterID'
              // Normalization steps:
              //     -(routerID~;routerID |- I[RouterID])
              // <=> { remove |- }
              //     -(-(routerID~;routerID) \\/ I[RouterID])
              // <=> { De Morgan }
              //     routerID~;routerID /\\ -I[RouterID]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION routerID [Router*RouterID] Nothing PRAGMA "" "" ""),EDcD RELATION routerID [Router*RouterID] Nothing PRAGMA "" "" ""),ECpl (EDcI RouterID))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerID~;routerID /\\ -I[RouterID] ([RouterID*RouterID]) */
                          SELECT DISTINCT isect0.`SrcRouterID` AS src, isect0.`TrgRouterID` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerID~;routerID */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouterID`, ECps1.`TrgRouterID`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerID` AS `SrcRouterID`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerID` AS `TrgRouterID`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE isect0.`SrcRouterID` <> isect0.`TrgRouterID` AND isect0.`SrcRouterID` IS NOT NULL AND isect0.`TrgRouterID` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT routerID::Router*RouterID' =>
        array ( 'name'          => 'TOT routerID::Router*RouterID'
              , 'ruleAdl'       => 'I[Router] |- routerID;routerID~'
              , 'origin'        => 'line 45:10, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'routerID[Router\\*RouterID] is totaal'
              , 'message'       => 'routerID[Router\\*RouterID] is niet totaal'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] |- routerID;routerID~)
              // <=> { remove |- }
              //     -(-I[Router] \\/ routerID;routerID~)
              // <=> { De Morgan }
              //     I[Router] /\\ -(routerID;routerID~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI Router,ECpl (ECps (EDcD RELATION routerID [Router*RouterID] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerID [Router*RouterID] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[Router] /\\ -(routerID;routerID~) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgRouter` AS tgt
                          FROM ( /* I[Router] */
                            SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                            FROM `Router`
                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                routerID;routerID~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                             FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerID` AS `TrgRouterID`
                                               FROM `Router`
                                               WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router` AS `TrgRouter`, `routerID` AS `SrcRouterID`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgRouterID`=ECps1.`SrcRouterID`
                                           ) AS cp
                                      WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerName::Router*RouterName' =>
        array ( 'name'          => 'UNI routerName::Router*RouterName'
              , 'ruleAdl'       => 'routerName~;routerName |- I[RouterName]'
              , 'origin'        => 'line 46:12, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'routerName[Router\\*RouterName] is univalent'
              , 'message'       => 'routerName[Router\\*RouterName] is niet univalent'
              , 'srcConcept'    => 'RouterName'
              , 'tgtConcept'    => 'RouterName'
              // Normalization steps:
              //     -(routerName~;routerName |- I[RouterName])
              // <=> { remove |- }
              //     -(-(routerName~;routerName) \\/ I[RouterName])
              // <=> { De Morgan }
              //     routerName~;routerName /\\ -I[RouterName]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION routerName [Router*RouterName] Nothing PRAGMA "" "" ""),EDcD RELATION routerName [Router*RouterName] Nothing PRAGMA "" "" ""),ECpl (EDcI RouterName))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerName~;routerName /\\ -I[RouterName] ([RouterName*RouterName]) */
                          SELECT DISTINCT isect0.`SrcRouterName` AS src, isect0.`TrgRouterName` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerName~;routerName */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouterName`, ECps1.`TrgRouterName`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerName` AS `SrcRouterName`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerName` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerName` AS `TrgRouterName`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerName` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE isect0.`SrcRouterName` <> isect0.`TrgRouterName` AND isect0.`SrcRouterName` IS NOT NULL AND isect0.`TrgRouterName` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerStatus::Router*Status' =>
        array ( 'name'          => 'UNI routerStatus::Router*Status'
              , 'ruleAdl'       => 'routerStatus~;routerStatus |- I[Status]'
              , 'origin'        => 'line 47:14, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'routerStatus[Router\\*Status] is univalent'
              , 'message'       => 'routerStatus[Router\\*Status] is niet univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(routerStatus~;routerStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(routerStatus~;routerStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     routerStatus~;routerStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""),EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""),ECpl (EDcI Status))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerStatus~;routerStatus /\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS src, isect0.`TrgStatus` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerStatus~;routerStatus */
                                 
                                 SELECT DISTINCT ECps0.`SrcStatus`, ECps1.`TrgStatus`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerStatus` AS `SrcStatus`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerStatus` AS `TrgStatus`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TrgStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TrgStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerNW::Router*Network' =>
        array ( 'name'          => 'UNI routerNW::Router*Network'
              , 'ruleAdl'       => 'routerNW~;routerNW |- I[Network]'
              , 'origin'        => 'line 51:10, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'routerNW[Router\\*Network] is univalent'
              , 'message'       => 'routerNW[Router\\*Network] is niet univalent'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(routerNW~;routerNW |- I[Network])
              // <=> { remove |- }
              //     -(-(routerNW~;routerNW) \\/ I[Network])
              // <=> { De Morgan }
              //     routerNW~;routerNW /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),ECpl (EDcI Network))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             routerNW~;routerNW /\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`SrcNetwork`, ECps1.`TrgNetwork`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TrgNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scID::SvcComponent*SvcComponentID' =>
        array ( 'name'          => 'UNI scID::SvcComponent*SvcComponentID'
              , 'ruleAdl'       => 'scID~;scID |- I[SvcComponentID]'
              , 'origin'        => 'line 95:6, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'scID[SvcComponent\\*SvcComponentID] is univalent'
              , 'message'       => 'scID[SvcComponent\\*SvcComponentID] is niet univalent'
              , 'srcConcept'    => 'SvcComponentID'
              , 'tgtConcept'    => 'SvcComponentID'
              // Normalization steps:
              //     -(scID~;scID |- I[SvcComponentID])
              // <=> { remove |- }
              //     -(-(scID~;scID) \\/ I[SvcComponentID])
              // <=> { De Morgan }
              //     scID~;scID /\\ -I[SvcComponentID]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION scID [SvcComponent*SvcComponentID] Nothing PRAGMA "" "" ""),EDcD RELATION scID [SvcComponent*SvcComponentID] Nothing PRAGMA "" "" ""),ECpl (EDcI SvcComponentID))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scID~;scID /\\ -I[SvcComponentID] ([SvcComponentID*SvcComponentID]) */
                          SELECT DISTINCT isect0.`SrcSvcComponentID` AS src, isect0.`TrgSvcComponentID` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scID~;scID */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponentID`, ECps1.`TrgSvcComponentID`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scID` AS `SrcSvcComponentID`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scID` AS `TrgSvcComponentID`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcSvcComponentID` <> isect0.`TrgSvcComponentID` AND isect0.`SrcSvcComponentID` IS NOT NULL AND isect0.`TrgSvcComponentID` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT scID::SvcComponent*SvcComponentID' =>
        array ( 'name'          => 'TOT scID::SvcComponent*SvcComponentID'
              , 'ruleAdl'       => 'I[SvcComponent] |- scID;scID~'
              , 'origin'        => 'line 95:6, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'scID[SvcComponent\\*SvcComponentID] is totaal'
              , 'message'       => 'scID[SvcComponent\\*SvcComponentID] is niet totaal'
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] |- scID;scID~)
              // <=> { remove |- }
              //     -(-I[SvcComponent] \\/ scID;scID~)
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ -(scID;scID~)
              // 
              // Normalized complement (== violationsSQL): EIsc (EDcI SvcComponent,ECpl (ECps (EDcD RELATION scID [SvcComponent*SvcComponentID] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION scID [SvcComponent*SvcComponentID] Nothing PRAGMA "" "" ""))))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             I[SvcComponent] /\\ -(scID;scID~) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgSvcComponent` AS tgt
                          FROM ( /* I[SvcComponent] */
                            SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                            FROM `SvcComponent`
                            WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                scID;scID~ */
                                             
                                             SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                             FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scID` AS `TrgSvcComponentID`
                                               FROM `SvcComponent`
                                               WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scID` AS `SrcSvcComponentID`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`TrgSvcComponentID`=ECps1.`SrcSvcComponentID`
                                           ) AS cp
                                      WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scName::SvcComponent*SvcComponentName' =>
        array ( 'name'          => 'UNI scName::SvcComponent*SvcComponentName'
              , 'ruleAdl'       => 'scName~;scName |- I[SvcComponentName]'
              , 'origin'        => 'line 96:8, file ".\\\\..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning'       => 'scName[SvcComponent\\*SvcComponentName] is univalent'
              , 'message'       => 'scName[SvcComponent\\*SvcComponentName] is niet univalent'
              , 'srcConcept'    => 'SvcComponentName'
              , 'tgtConcept'    => 'SvcComponentName'
              // Normalization steps:
              //     -(scName~;scName |- I[SvcComponentName])
              // <=> { remove |- }
              //     -(-(scName~;scName) \\/ I[SvcComponentName])
              // <=> { De Morgan }
              //     scName~;scName /\\ -I[SvcComponentName]
              // 
              // Normalized complement (== violationsSQL): EIsc (ECps (EFlp (EDcD RELATION scName [SvcComponent*SvcComponentName] Nothing PRAGMA "" "" ""),EDcD RELATION scName [SvcComponent*SvcComponentName] Nothing PRAGMA "" "" ""),ECpl (EDcI SvcComponentName))
              , 'violationsSQL' => '/* case: (EIsc lst\'@(_:_:_))
                             scName~;scName /\\ -I[SvcComponentName] ([SvcComponentName*SvcComponentName]) */
                          SELECT DISTINCT isect0.`SrcSvcComponentName` AS src, isect0.`TrgSvcComponentName` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scName~;scName */
                                 
                                 SELECT DISTINCT ECps0.`SrcSvcComponentName`, ECps1.`TrgSvcComponentName`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `scName` AS `SrcSvcComponentName`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scName` IS NOT NULL
                                      ) AS ECps0,
                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `scName` AS `TrgSvcComponentName`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL AND `scName` IS NOT NULL ) AS ECps1
                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcSvcComponentName` <> isect0.`TrgSvcComponentName` AND isect0.`SrcSvcComponentName` IS NOT NULL AND isect0.`TrgSvcComponentName` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    );

$invariantRuleNames = array ('UNI planCmpStat::Plan*Status', 'SYM atStatusIsGreen::ActivityType*ActivityType', 'ASY atStatusIsGreen::ActivityType*ActivityType', 'UNI atStatusIsGreen::ActivityType*ActivityType', 'INJ atStatusIsGreen::ActivityType*ActivityType', 'UNI actCmpStat::Activity*Status', 'UNI ouCmpStat::OrgUnit*Status', 'UNI scCmpStat::SvcComponent*Status', 'UNI compCmpStat::Computer*Status', 'SYM nwAllCompCommReqsSatisfied::Network*Network', 'ASY nwAllCompCommReqsSatisfied::Network*Network', 'UNI nwAllCompCommReqsSatisfied::Network*Network', 'INJ nwAllCompCommReqsSatisfied::Network*Network', 'SYM nwNoCompCommReqsSatisfied::Network*Network', 'ASY nwNoCompCommReqsSatisfied::Network*Network', 'UNI nwNoCompCommReqsSatisfied::Network*Network', 'INJ nwNoCompCommReqsSatisfied::Network*Network', 'SYM routerAllCommReqsSatisfied::Router*Router', 'ASY routerAllCommReqsSatisfied::Router*Router', 'UNI routerAllCommReqsSatisfied::Router*Router', 'INJ routerAllCommReqsSatisfied::Router*Router', 'SYM routerNoCommReqsSatisfied::Router*Router', 'ASY routerNoCommReqsSatisfied::Router*Router', 'UNI routerNoCommReqsSatisfied::Router*Router', 'INJ routerNoCommReqsSatisfied::Router*Router', 'SYM compRequiresComm::Computer*Computer', 'ASY compRequiresComm::Computer*Computer', 'UNI compRequiresComm::Computer*Computer', 'INJ compRequiresComm::Computer*Computer', 'SYM compAllReqCommSatisfied::Computer*Computer', 'ASY compAllReqCommSatisfied::Computer*Computer', 'UNI compAllReqCommSatisfied::Computer*Computer', 'INJ compAllReqCommSatisfied::Computer*Computer', 'SYM compNoReqCommSatisfied::Computer*Computer', 'ASY compNoReqCommSatisfied::Computer*Computer', 'UNI compNoReqCommSatisfied::Computer*Computer', 'INJ compNoReqCommSatisfied::Computer*Computer', 'SYM scAllReqCommSatisfied::SvcComponent*SvcComponent', 'ASY scAllReqCommSatisfied::SvcComponent*SvcComponent', 'UNI scAllReqCommSatisfied::SvcComponent*SvcComponent', 'INJ scAllReqCommSatisfied::SvcComponent*SvcComponent', 'SYM scNoReqCommSatisfied::SvcComponent*SvcComponent', 'ASY scNoReqCommSatisfied::SvcComponent*SvcComponent', 'UNI scNoReqCommSatisfied::SvcComponent*SvcComponent', 'INJ scNoReqCommSatisfied::SvcComponent*SvcComponent', 'SYM svcAllSvcCompReqsSatisfied::Service*Service', 'ASY svcAllSvcCompReqsSatisfied::Service*Service', 'UNI svcAllSvcCompReqsSatisfied::Service*Service', 'INJ svcAllSvcCompReqsSatisfied::Service*Service', 'SYM svcNoSvcCompReqsSatisfied::Service*Service', 'ASY svcNoSvcCompReqsSatisfied::Service*Service', 'UNI svcNoSvcCompReqsSatisfied::Service*Service', 'INJ svcNoSvcCompReqsSatisfied::Service*Service', 'SYM connectComputerToNetworkRouter::Computer*Computer', 'ASY connectComputerToNetworkRouter::Computer*Computer', 'UNI connectComputerToNetworkRouter::Computer*Computer', 'INJ connectComputerToNetworkRouter::Computer*Computer', 'SYM startRunningServiceComponents::SvcComponent*SvcComponent', 'ASY startRunningServiceComponents::SvcComponent*SvcComponent', 'UNI startRunningServiceComponents::SvcComponent*SvcComponent', 'INJ startRunningServiceComponents::SvcComponent*SvcComponent', 'UNI planID::Plan*PlanID', 'TOT planID::Plan*PlanID', 'UNI planStatus::Plan*Status', 'UNI planMnlStat::Plan*Status', 'UNI atStatus::ActivityType*Status', 'UNI svcID::Service*ServiceID', 'TOT svcID::Service*ServiceID', 'UNI svcStatus::Service*Status', 'UNI actType::Activity*ActivityType', 'TOT actType::Activity*ActivityType', 'UNI actID::Activity*ActivityID', 'TOT actID::Activity*ActivityID', 'UNI actStatus::Activity*Status', 'UNI actMnlStat::Activity*Status', 'UNI actExecutingOU::Activity*OrgUnit', 'UNI actPlan::Activity*Plan', 'UNI actPlanStart::Activity*Timestamp', 'UNI actPlanEnd::Activity*Timestamp', 'UNI actStartTime::Activity*Timestamp', 'UNI actEndTime::Activity*Timestamp', 'UNI ouStatus::OrgUnit*Status', 'UNI ouMnlStat::OrgUnit*Status', 'UNI scStatus::SvcComponent*Status', 'UNI scMnlStat::SvcComponent*Status', 'UNI compID::Computer*ComputerID', 'TOT compID::Computer*ComputerID', 'UNI compName::Computer*ComputerName', 'UNI compStatus::Computer*Status', 'UNI compMnlStat::Computer*Status', 'UNI compOwner::Computer*OrgUnit', 'UNI nwID::Network*NetworkID', 'TOT nwID::Network*NetworkID', 'UNI nwStatus::Network*Status', 'UNI routerID::Router*RouterID', 'TOT routerID::Router*RouterID', 'UNI routerName::Router*RouterName', 'UNI routerStatus::Router*Status', 'UNI routerNW::Router*Network', 'UNI scID::SvcComponent*SvcComponentID', 'TOT scID::SvcComponent*SvcComponentID', 'UNI scName::SvcComponent*SvcComponentName', 'rrtStar Transitive closure integrity', 'Yes/No answer integrity', 'Activity executor must exist', 'Activity plan must exist', 'Router naming integrity', 'Router network integrity', 'Computer naming integrity', 'Service - component integrity', 'SvcComponent naming integrity');

$allRoles =
  array
    ( array ( 'name' => 'Developer'
            , 'ruleNames' => array ('ActivityType OrgUnits', 'Service implementation', 'Capability relevance', 'SvcComponent assignment', 'Activity Integrity', 'Connect computer to network router', 'Create router paths', 'Routes to be discarded', 'Computers to be disconnected', 'Set up computer-computer communications', 'Start running service components', 'Network status integrity check', 'Router status integrity check', 'Computer status integrity check', 'SvcComponent status integrity check', 'Service status integrity check')
            )
    , array ( 'name' => 'ExecEngine'
            , 'ruleNames' => array ('insouMayExecuteAT', 'delouMayExecuteAT', 'planCmpStatIsRed', 'planCmpStatIsYellow', 'planCmpStatIsGreen', 'InsPlanStatus', 'defaultPlanStatus', 'insatStatusIsGreen', 'delatStatusIsGreen', 'atStatusIsYellow', 'atStatusIsRed', 'actCmpStatIsRed', 'actCmpStatIsYellow', 'actCmpStatIsGreen', 'InsActivityStatus', 'defaultActivityStatus', 'InsOrgUnitStatus', 'defaultOrgUnitStatus', 'InsSvcComponentStatus', 'defaultSvcComponentStatus', 'InsComputerStatus', 'defaultComputerStatus', 'Create path within network', 'Remove routes from non-network routers', 'Remove computers from non-network routers', 'InsnwAllCompCommReqsSatisfied', 'DelnwAllCompCommReqsSatisfied', 'InsnwNoCompCommReqsSatisfied', 'DelnwNoCompCommReqsSatisfied', 'rrtCompTransitiveClosure', 'InsrouterNeedsPathTo', 'DelrouterNeedsPathTo', 'InsrouterAllCommReqsSatisfied', 'DelrouterAllCommReqsSatisfied', 'InsrouterNoCommReqsSatisfied', 'DelrouterNoCommReqsSatisfied', 'InscompReqCommWith', 'DelcompReqCommWith', 'InscompHasCommWith', 'DelcompHasCommWith', 'InscompRequiresComm', 'DelcompRequiresComm', 'InscompAllReqCommSatisfied', 'DelCompAllReqCommSatisfied', 'InscompNoReqCommSatisfied', 'DelCompNoReqCommSatisfied', 'InsscHasCommWith', 'DelscHasCommWith', 'InsscAllReqCommSatisfied', 'DelscAllReqCommSatisfied', 'InsscNoReqCommSatisfied', 'DelscNoReqCommSatisfied', 'InssvcAllSvcCompReqsSatisfied', 'DelsvcAllSvcCompReqsSatisfied', 'InssvcNoSvcCompReqsSatisfied', 'DelsvcNoSvcCompReqsSatisfied', 'insconnectComputerToNetworkRouter', 'delconnectComputerToNetworkRouter', 'insroutesToBeDiscarded', 'delroutesToBeDiscarded', 'inscomputerToBeDisconnected', 'delcomputerToBeDisconnected', 'inssetupComputerComputerCommunications', 'delsetupComputerComputerCommunications', 'insstartRunningServiceComponents', 'delstartRunningServiceComponents', 'Network status \'Green\'', 'Network status \'Yellow\'', 'Network status \'Red\'', 'Network status \'Blue\'', 'Router status \'Green\'', 'Router status \'Yellow\'', 'Router status \'Red\'', 'Router status \'Blue\'', 'Computer status \'Green\'', 'Computer status \'Yellow\'', 'Computer status \'Red\'', 'Computer status \'Black\'', 'Computer status \'Blue\'', 'Computer status \'White\'', 'SvcComponent status \'Green\'', 'SvcComponent status \'Yellow\'', 'SvcComponent status \'Red\'', 'SvcComponent status \'Black\'', 'SvcComponent status \'Blue\'', 'SvcComponent status \'White\'', 'Service status \'Green\'', 'Service status \'Yellow\'', 'Service status \'Red\'')
            )
    );

//$allViews is sorted from spec to gen such that the first match for a concept will be the most specific (e.g. see DatabaseUtils.getView()).
$allViews =
  array
    (   array ( 'label' => 'Plans'
              , 'concept' => 'Plan'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // view exp: EDcD RELATION planID [Plan*PlanID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ A Plan is identified by its PlanID +}
                            , 'expSQL' =>
                                'SELECT DISTINCT `Plan` AS src, `planID` AS tgt
                                 FROM `Plan`
                                 WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL'
                            )
                    )
              )
    ,   array ( 'label' => 'Services'
              , 'concept' => 'Service'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // view exp: EDcD RELATION svcID [Service*ServiceID] Nothing PRAGMA "" "" ""
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `svcID` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL'
                            )
                    )
              )
    ,   array ( 'label' => 'Activities'
              , 'concept' => 'Activity'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // view exp: EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType +}
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `actType` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ':')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // view exp: EDcD RELATION actID [Activity*ActivityID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is identified by its ActivityID +}
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `actID` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL'
                            )
                    )
              )
    ,   array ( 'label' => 'SvcComponents'
              , 'concept' => 'SvcComponent'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // view exp: EDcD RELATION scID [SvcComponent*SvcComponentID] Nothing PRAGMA "" "" ""
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `scID` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL'
                            )
                    )
              )
    ,   array ( 'label' => 'Computers'
              , 'concept' => 'Computer'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // view exp: EDcD RELATION compID [Computer*ComputerID] Nothing PRAGMA "" "" ""
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `compID` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL'
                            )
                    )
              )
    ,   array ( 'label' => 'Routers'
              , 'concept' => 'Router'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // view exp: EDcD RELATION routerID [Router*RouterID] Nothing PRAGMA "" "" ""
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `routerID` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL'
                            )
                    )
              )
    ,   array ( 'label' => 'Networks'
              , 'concept' => 'Network'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // view exp: EDcD RELATION nwID [Network*NetworkID] Nothing PRAGMA "" "" ""
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `nwID` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL'
                            )
                    )
              )
    );

$allInterfaceObjects =
  array
    ( // Top-level interface OVERVIEW for all roles:
      'OVERVIEW' => 
      array ( 'name' => 'OVERVIEW'
            // Normalized interface expression (== expressionSQL): EDcI ONE
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* I[ONE] */
                                  SELECT 1 AS src, 1 AS tgt'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Plans'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*Plan]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Plan'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*Plan]\" ] */
                                                SELECT DISTINCT 1 AS src, `Plan`.`Plan` AS tgt
                                                FROM `Plan` AS `Plan`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Plan'
                                        // Normalized interface expression (== expressionSQL): EDcI Plan
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'Plan'
                                        , 'expressionSQL' => '/* I[Plan] */
                                                              SELECT DISTINCT `Plan` AS src, `Plan` AS tgt
                                                              FROM `Plan`
                                                              WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION planStatus [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `planStatus` AS tgt
                                                              FROM `Plan`
                                                              WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Activity Types'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*ActivityType]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*ActivityType]\" ] */
                                                SELECT DISTINCT 1 AS src, `ActivityType`.`ActivityType` AS tgt
                                                FROM `ActivityType` AS `ActivityType`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ActivityType'
                                        // Normalized interface expression (== expressionSQL): EDcI ActivityType
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => '/* I[ActivityType] */
                                                              SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                                              FROM `ActivityType`
                                                              WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION atStatus [ActivityType*Status] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `atStatus` AS tgt
                                                              FROM `ActivityType`
                                                              WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Activities'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*Activity]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*Activity]\" ] */
                                                SELECT DISTINCT 1 AS src, `Activity`.`Activity` AS tgt
                                                FROM `Activity` AS `Activity`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Activity'
                                        // Normalized interface expression (== expressionSQL): EDcI Activity
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Activity'
                                        , 'expressionSQL' => '/* I[Activity] */
                                                              SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION actStatus [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actStatus` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'OrgUnits'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*OrgUnit]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*OrgUnit]\" ] */
                                                SELECT DISTINCT 1 AS src, `OrgUnit`.`OrgUnit` AS tgt
                                                FROM `OrgUnit` AS `OrgUnit`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Org.Unit'
                                        // Normalized interface expression (== expressionSQL): EDcI OrgUnit
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => '/* I[OrgUnit] */
                                                              SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION ouStatus [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `ouStatus` AS tgt
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'SvcComponents'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*SvcComponent]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*SvcComponent]\" ] */
                                                SELECT DISTINCT 1 AS src, `SvcComponent`.`SvcComponent` AS tgt
                                                FROM `SvcComponent` AS `SvcComponent`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'SvcComponent'
                                        // Normalized interface expression (== expressionSQL): EDcI SvcComponent
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* I[SvcComponent] */
                                                              SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scStatus` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Computers'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*Computer]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*Computer]\" ] */
                                                SELECT DISTINCT 1 AS src, `Computer`.`Computer` AS tgt
                                                FROM `Computer` AS `Computer`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer'
                                        // Normalized interface expression (== expressionSQL): EDcI Computer
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* I[Computer] */
                                                              SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Services'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*Service]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*Service]\" ] */
                                                SELECT DISTINCT 1 AS src, `Service`.`Service` AS tgt
                                                FROM `Service` AS `Service`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Service'
                                        // Normalized interface expression (== expressionSQL): EDcI Service
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => '/* I[Service] */
                                                              SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Service` AS src, `svcStatus` AS tgt
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Networks'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*Network]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*Network]\" ] */
                                                SELECT DISTINCT 1 AS src, `Network`.`Network` AS tgt
                                                FROM `Network` AS `Network`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Network'
                                        // Normalized interface expression (== expressionSQL): EDcI Network
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Network'
                                        , 'expressionSQL' => '/* I[Network] */
                                                              SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Network` AS src, `nwStatus` AS tgt
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Routers'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*Router]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*Router]\" ] */
                                                SELECT DISTINCT 1 AS src, `Router`.`Router` AS tgt
                                                FROM `Router` AS `Router`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Router'
                                        // Normalized interface expression (== expressionSQL): EDcI Router
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => '/* I[Router] */
                                                              SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Capabilities'
                          // Normalized interface expression (== expressionSQL): EDcV [ONE*Capability]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \"[ONE*Capability]\" ] */
                                                SELECT DISTINCT 1 AS src, `Capability`.`Capability` AS tgt
                                                FROM `Capability` AS `Capability`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Plan for all roles:
      'Plan' => 
      array ( 'name' => 'Plan'
            // Normalized interface expression (== expressionSQL): EDcI Plan
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('PlanID', 'Status', 'ActivityType')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Plan'
            , 'tgtConcept' => 'Plan'
            , 'expressionSQL' => '/* I[Plan] */
                                  SELECT DISTINCT `Plan` AS src, `Plan` AS tgt
                                  FROM `Plan`
                                  WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Plan'
                          // Normalized interface expression (== expressionSQL): EDcI Plan
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'Plan'
                          , 'expressionSQL' => '/* I[Plan] */
                                                SELECT DISTINCT `Plan` AS src, `Plan` AS tgt
                                                FROM `Plan`
                                                WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION planID [Plan*PlanID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ A Plan is identified by its PlanID +}
                                        , 'relation' => 'planID'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'PlanID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `planID` AS tgt
                                                              FROM `Plan`
                                                              WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION planStatus [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `planStatus` AS tgt
                                                              FROM `Plan`
                                                              WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION planMnlStat [Plan*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Plans can be assigned a new status +}
                                        , 'relation' => 'planMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `planMnlStat` AS tgt
                                                              FROM `Plan`
                                                              WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Capabilities'
                          // Normalization steps:
                          //     (actPlan~;actType \\/ planAT);atReqsCpb
                          // <=> { distribute ; over \\/ }
                          //     actPlan~;(actType;atReqsCpb) \\/ planAT;atReqsCpb
                          //
                          // Normalized interface expression (== expressionSQL): EUni (ECps (EFlp (EDcD RELATION actPlan [Activity*Plan] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is according to the plan -}),ECps (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -},EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability -})),ECps (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -},EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability +}))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => '/* case: EUni (l,r)
                                                   actPlan~;(actType;atReqsCpb) \\/ planAT;atReqsCpb ([Plan*Capability]) */
                                                (/* case: (ECps es), with two or more elements in es.
                                                       actPlan~;(actType;atReqsCpb) */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcPlan` AS src, ECps2.`TrgCapability` AS tgt
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlan` AS `SrcPlan`
                                                           FROM `Activity`
                                                           WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL
                                                         ) AS ECps0,
                                                         ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                                      FROM `Activity`
                                                      WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps1,
                                                         ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Capability` AS `TrgCapability`
                                                      FROM `atReqsCpb`
                                                      WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL ) AS ECps2
                                                    WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                                                      AND ECps1.`TrgActivityType`=ECps2.`SrcActivityType`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       planAT;atReqsCpb */
                                                    
                                                    SELECT DISTINCT ECps0.`SrcPlan` AS src, ECps1.`TrgCapability` AS tgt
                                                    FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `ActivityType` AS `TrgActivityType`
                                                      FROM `planAT`
                                                      WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps0,
                                                         ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Capability` AS `TrgCapability`
                                                      FROM `atReqsCpb`
                                                      WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL ) AS ECps1
                                                    WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                                )'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Activity types'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType +}
                          , 'relation' => 'planAT'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `ActivityType` AS tgt
                                                FROM `planAT`
                                                WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Activities'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION actPlan [Activity*Plan] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is according to the plan +})
                          , 'relation' => 'actPlan'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `actPlan` AS src, `Activity` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): EDcI Plan
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'Plan'
                          , 'expressionSQL' => '/* I[Plan] */
                                                SELECT DISTINCT `Plan` AS src, `Plan` AS tgt
                                                FROM `Plan`
                                                WHERE `Plan` IS NOT NULL AND `Plan` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ActivityTypes that require Services that have no implementation'
                                        // Normalized interface expression (== expressionSQL): ECps (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -},EBrk (EIsc (EDcI ActivityType,ECps (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -},ECps (EBrk (EIsc (EDcI Service,ECpl (EBrk (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}))))),EFlp (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service +}))))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 planAT;(I[ActivityType] /\\ atReqsSvc;((I[Service] /\\ -(scImplements~;scImplements));atReqsSvc~)) */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcPlan` AS src, ECps1.`TrgActivityType` AS tgt
                                                              FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `ActivityType` AS `TrgActivityType`
                                                                FROM `planAT`
                                                                WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst\'@(_:_:_))
                                                                        I[ActivityType] /\\ atReqsSvc;((I[Service] /\\ -(scImplements~;scImplements));atReqsSvc~) ([ActivityType*ActivityType]) */
                                                                     SELECT DISTINCT isect0.`SrcActivityType`, isect0.`TrgActivityType`
                                                                     FROM 
                                                                          ( /* case: (ECps es), with two or more elements in es.
                                                                               atReqsSvc;((I[Service] /\\ -(scImplements~;scImplements));atReqsSvc~) */
                                                                            
                                                                            SELECT DISTINCT ECps0.`SrcActivityType`, ECps2.`TrgActivityType`
                                                                            FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                                                              FROM `atReqsSvc`
                                                                              WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                                                                 
                                                                                 ( /* case: (EIsc lst\'@(_:_:_))
                                                                                      I[Service] /\\ -(scImplements~;scImplements) ([Service*Service]) */
                                                                                   SELECT DISTINCT isect0.`SrcService`, isect0.`TrgService`
                                                                                   FROM ( /* I[Service] */
                                                                                     SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                                                                                     FROM `Service`
                                                                                     WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect0
                                                                                   WHERE NOT EXISTS (SELECT * FROM 
                                                                                                    ( /* case: (ECps es), with two or more elements in es.
                                                                                                         scImplements~;scImplements */
                                                                                                      
                                                                                                      SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                                                                                      FROM 
                                                                                                           ( /* case: EFlp x. */
                                                                                                             SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                                                                             FROM `scImplements`
                                                                                                             WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                                                           ) AS ECps0,
                                                                                                           ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                                                                        FROM `scImplements`
                                                                                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                                                                      WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                                                                    ) AS cp
                                                                                               WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL
                                                                                 ) AS ECps1,
                                                                                 
                                                                                 ( /* case: EFlp x. */
                                                                                   SELECT DISTINCT `ActivityType` AS `TrgActivityType`, `Service` AS `SrcService`
                                                                                   FROM `atReqsSvc`
                                                                                   WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL
                                                                                 ) AS ECps2
                                                                            WHERE ECps0.`TrgService`=ECps1.`SrcService`
                                                                              AND ECps1.`TrgService`=ECps2.`SrcService`
                                                                          ) AS isect0, ( /* I[ActivityType] */
                                                                       SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `ActivityType` AS `TrgActivityType`
                                                                       FROM `ActivityType`
                                                                       WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect1
                                                                     WHERE isect0.`SrcActivityType` = isect0.`TrgActivityType` AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'ActivityTypes for which no OrgUnit is qualified'
                                        // Normalized interface expression (== expressionSQL): ECps (EDcD RELATION planAT [Plan*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the plan consists of executing (instances of) the ActivityType -},EBrk (EIsc (EDcI ActivityType,ECpl (EBrk (ECps (EFlp (EDcD RELATION ouMayExecuteAT [OrgUnit*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit has all necessary capabilities for executing activities of the ActivityType -}),EDcD RELATION ouMayExecuteAT [OrgUnit*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit has all necessary capabilities for executing activities of the ActivityType +}))))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 planAT;(I[ActivityType] /\\ -(ouMayExecuteAT~;ouMayExecuteAT)) */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcPlan` AS src, ECps1.`TrgActivityType` AS tgt
                                                              FROM ( SELECT DISTINCT `Plan` AS `SrcPlan`, `ActivityType` AS `TrgActivityType`
                                                                FROM `planAT`
                                                                WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst\'@(_:_:_))
                                                                        I[ActivityType] /\\ -(ouMayExecuteAT~;ouMayExecuteAT) ([ActivityType*ActivityType]) */
                                                                     SELECT DISTINCT isect0.`SrcActivityType`, isect0.`TrgActivityType`
                                                                     FROM ( /* I[ActivityType] */
                                                                       SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `ActivityType` AS `TrgActivityType`
                                                                       FROM `ActivityType`
                                                                       WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                      ( /* case: (ECps es), with two or more elements in es.
                                                                                           ouMayExecuteAT~;ouMayExecuteAT */
                                                                                        
                                                                                        SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgActivityType`
                                                                                        FROM 
                                                                                             ( /* case: EFlp x. */
                                                                                               SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `ActivityType` AS `SrcActivityType`
                                                                                               FROM `ouMayExecuteAT`
                                                                                               WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                                                             ) AS ECps0,
                                                                                             ( SELECT DISTINCT `OrgUnit` AS `SrcOrgUnit`, `ActivityType` AS `TrgActivityType`
                                                                                          FROM `ouMayExecuteAT`
                                                                                          WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL ) AS ECps1
                                                                                        WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                                                                                      ) AS cp
                                                                                 WHERE isect0.`SrcActivityType`=cp.`SrcActivityType` AND isect0.`TrgActivityType`=cp.`TrgActivityType`) AND isect0.`SrcActivityType` IS NOT NULL AND isect0.`TrgActivityType` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface ActivityType for all roles:
      'ActivityType' => 
      array ( 'name' => 'ActivityType'
            // Normalized interface expression (== expressionSQL): EDcI ActivityType
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('Capability', 'Service')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ActivityType'
            , 'tgtConcept' => 'ActivityType'
            , 'expressionSQL' => '/* I[ActivityType] */
                                  SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                  FROM `ActivityType`
                                  WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'ActivityType'
                          // Normalized interface expression (== expressionSQL): EDcI ActivityType
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => '/* I[ActivityType] */
                                                SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                                FROM `ActivityType`
                                                WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): EDcI ActivityType
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => '/* I[ActivityType] */
                                                              SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                                              FROM `ActivityType`
                                                              WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION atStatus [ActivityType*Status] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `atStatus` AS tgt
                                                              FROM `ActivityType`
                                                              WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Req\'d Capabilities'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability +}
                          , 'relation' => 'atReqsCpb'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `Capability` AS tgt
                                                FROM `atReqsCpb`
                                                WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Req\'d InfoServices'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service +}
                          , 'relation' => 'atReqsSvc'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `Service` AS tgt
                                                FROM `atReqsSvc`
                                                WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Instances'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType +})
                          , 'relation' => 'actType'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `actType` AS src, `Activity` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): EDcI ActivityType
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => '/* I[ActivityType] */
                                                SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                                FROM `ActivityType`
                                                WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Required Services that have no implementation'
                                        // Normalized interface expression (== expressionSQL): ECps (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -},EBrk (EIsc (EDcI Service,ECpl (EBrk (ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +}))))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 atReqsSvc;(I[Service] /\\ -(scImplements~;scImplements)) */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcActivityType` AS src, ECps1.`TrgService` AS tgt
                                                              FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                                                FROM `atReqsSvc`
                                                                WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst\'@(_:_:_))
                                                                        I[Service] /\\ -(scImplements~;scImplements) ([Service*Service]) */
                                                                     SELECT DISTINCT isect0.`SrcService`, isect0.`TrgService`
                                                                     FROM ( /* I[Service] */
                                                                       SELECT DISTINCT `Service` AS `SrcService`, `Service` AS `TrgService`
                                                                       FROM `Service`
                                                                       WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                      ( /* case: (ECps es), with two or more elements in es.
                                                                                           scImplements~;scImplements */
                                                                                        
                                                                                        SELECT DISTINCT ECps0.`SrcService`, ECps1.`TrgService`
                                                                                        FROM 
                                                                                             ( /* case: EFlp x. */
                                                                                               SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                                                               FROM `scImplements`
                                                                                               WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                                             ) AS ECps0,
                                                                                             ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                                                          FROM `scImplements`
                                                                                          WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                                                        WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                                                      ) AS cp
                                                                                 WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TrgService` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`TrgService`=ECps1.`SrcService`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'List of qualified OrgUnits'
                                        // Normalization steps:
                                        //     -atReqsCpb!ouQualifiedFor~
                                        // <=> { De Morgan }
                                        //     -(atReqsCpb;-ouQualifiedFor~)
                                        //
                                        // Normalized interface expression (== expressionSQL): ECpl (ECps (EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability -},ECpl (EFlp (EDcD RELATION ouQualifiedFor [OrgUnit*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit is qualified for the Capability +}))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => '/* case: ECpl e
                                                                 ECpl ( \"atReqsCpb;-ouQualifiedFor~\" ) */
                                                              SELECT DISTINCT cfst.`ActivityType` AS src, csnd.`OrgUnit` AS tgt
                                                              FROM `ActivityType` AS cfst,
                                                                   `OrgUnit` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM 
                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                          atReqsCpb;-ouQualifiedFor~ */
                                                                       
                                                                       SELECT DISTINCT ECps0.`SrcActivityType`, ECps1.`TrgOrgUnit`
                                                                       FROM ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Capability` AS `TrgCapability`
                                                                         FROM `atReqsCpb`
                                                                         WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL ) AS ECps0,
                                                                            
                                                                            ( /* case: ECpl e
                                                                                 ECpl ( \"ouQualifiedFor~\" ) */
                                                                              SELECT DISTINCT cfst.`Capability` AS `SrcCapability`, csnd.`OrgUnit` AS `TrgOrgUnit`
                                                                              FROM `Capability` AS cfst,
                                                                                   `OrgUnit` AS csnd
                                                                              WHERE NOT EXISTS
                                                                               (SELECT * FROM 
                                                                                     ( /* case: EFlp x. */
                                                                                       SELECT DISTINCT `OrgUnit` AS `TrgOrgUnit`, `Capability` AS `SrcCapability`
                                                                                       FROM `ouQualifiedFor`
                                                                                       WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL
                                                                                     ) AS cp
                                                                                WHERE cfst.`Capability`=cp.`SrcCapability` AND csnd.`OrgUnit`=cp.`TrgOrgUnit`)
                                                                            ) AS ECps1
                                                                       WHERE ECps0.`TrgCapability`=ECps1.`SrcCapability`
                                                                     ) AS cp
                                                                WHERE cfst.`ActivityType`=cp.`SrcActivityType` AND csnd.`OrgUnit`=cp.`TrgOrgUnit`)'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Activity for all roles:
      'Activity' => 
      array ( 'name' => 'Activity'
            // Normalized interface expression (== expressionSQL): EDcI Activity
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('ActivityType', 'ActivityID', 'Status', 'OrgUnit', 'Timestamp', 'Timestamp', 'Timestamp', 'Timestamp', 'SvcComponent')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Activity'
            , 'tgtConcept' => 'Activity'
            , 'expressionSQL' => '/* I[Activity] */
                                  SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                  FROM `Activity`
                                  WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Activity'
                          // Normalized interface expression (== expressionSQL): EDcI Activity
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* I[Activity] */
                                                SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Type'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType +}
                                        , 'relation' => 'actType'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actType` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION actID [Activity*ActivityID] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is identified by its ActivityID +}
                                        , 'relation' => 'actID'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'ActivityID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actID` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION actStatus [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actStatus` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION actMnlStat [Activity*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Activities can be assigned a new status +}
                                        , 'relation' => 'actMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actMnlStat` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Plan'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION actPlan [Activity*Plan] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is according to the plan +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Plan'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actPlan` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Required Services'
                                        // Normalized interface expression (== expressionSQL): ECps (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -},EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service +})
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 actType;atReqsSvc */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcActivity` AS src, ECps1.`TrgService` AS tgt
                                                              FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                                                FROM `Activity`
                                                                WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps0,
                                                                   ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                                                FROM `atReqsSvc`
                                                                WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                              WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Executed by'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit +}
                          , 'relation' => 'actExecutingOU'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actExecutingOU` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Planned start time'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. +}
                          , 'relation' => 'actPlanStart'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Timestamp'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actPlanStart` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Planned end time'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION actPlanEnd [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to end at the specified time. +}
                          , 'relation' => 'actPlanEnd'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Timestamp'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actPlanEnd` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actPlanEnd` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Actual start time'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION actStartTime [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is actually started at the specified time. +}
                          , 'relation' => 'actStartTime'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Timestamp'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actStartTime` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actStartTime` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Actual end time'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION actEndTime [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is actually ended at the specified time. +}
                          , 'relation' => 'actEndTime'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Timestamp'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actEndTime` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actEndTime` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Used SvcComponents'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION actUseSC [Activity*SvcComponent] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity requires the availability of the SvcComponent +}
                          , 'relation' => 'actUseSC'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `SvcComponent` AS tgt
                                                FROM `actUseSC`
                                                WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): EDcI Activity
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* I[Activity] */
                                                SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'A SvcComponent is needed for'
                                        // Normalized interface expression (== expressionSQL): EIsc (ECps (EDcD RELATION actType [Activity*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ An Activity is an instance of an ActivityType -},EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service -}),ECpl (EBrk (ECps (EDcD RELATION actUseSC [Activity*SvcComponent] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity requires the availability of the SvcComponent -},EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +}))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => '/* case: (EIsc lst\'@(_:_:_))
                                                                 actType;atReqsSvc /\\ -(actUseSC;scImplements) ([Activity*Service]) */
                                                              SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgService` AS tgt
                                                              FROM 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        actType;atReqsSvc */
                                                                     
                                                                     SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgService`
                                                                     FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actType` AS `TrgActivityType`
                                                                       FROM `Activity`
                                                                       WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL ) AS ECps0,
                                                                          ( SELECT DISTINCT `ActivityType` AS `SrcActivityType`, `Service` AS `TrgService`
                                                                       FROM `atReqsSvc`
                                                                       WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                                     WHERE ECps0.`TrgActivityType`=ECps1.`SrcActivityType`
                                                                   ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    actUseSC;scImplements */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgService`
                                                                                 FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `SvcComponent` AS `TrgSvcComponent`
                                                                                   FROM `actUseSC`
                                                                                   WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS ECps0,
                                                                                      ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Service` AS `TrgService`
                                                                                   FROM `scImplements`
                                                                                   WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL ) AS ECps1
                                                                                 WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                                               ) AS cp
                                                                          WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgService`=cp.`TrgService`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'SvcComponents to be deployed'
                                        // Normalized interface expression (== expressionSQL): EIsc (EDcD RELATION actUseSC [Activity*SvcComponent] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity requires the availability of the SvcComponent -},ECps (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -},ECpl (EBrk (ECps (EFlp (EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" ""),EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +}))))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* case: (EIsc lst\'@(_:_:_))
                                                                 actUseSC /\\ actExecutingOU;-(compOwner~;scDeployedOn~) ([Activity*SvcComponent]) */
                                                              SELECT DISTINCT isect0.`SrcActivity` AS src, isect0.`TrgSvcComponent` AS tgt
                                                              FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `SvcComponent` AS `TrgSvcComponent`
                                                                FROM `actUseSC`
                                                                WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect0, 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        actExecutingOU;-(compOwner~;scDeployedOn~) */
                                                                     
                                                                     SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgSvcComponent`
                                                                     FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actExecutingOU` AS `TrgOrgUnit`
                                                                       FROM `Activity`
                                                                       WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL ) AS ECps0,
                                                                          
                                                                          ( /* case: ECpl e
                                                                               ECpl ( \"compOwner~;scDeployedOn~\" ) */
                                                                            SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`SvcComponent` AS `TrgSvcComponent`
                                                                            FROM `OrgUnit` AS cfst,
                                                                                 `SvcComponent` AS csnd
                                                                            WHERE NOT EXISTS
                                                                             (SELECT * FROM 
                                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                                        compOwner~;scDeployedOn~ */
                                                                                     
                                                                                     SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgSvcComponent`
                                                                                     FROM 
                                                                                          ( /* case: EFlp x. */
                                                                                            SELECT DISTINCT `Computer` AS `TrgComputer`, `compOwner` AS `SrcOrgUnit`
                                                                                            FROM `Computer`
                                                                                            WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL
                                                                                          ) AS ECps0,
                                                                                          
                                                                                          ( /* case: EFlp x. */
                                                                                            SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                                                            FROM `scDeployedOn`
                                                                                            WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                                                          ) AS ECps1
                                                                                     WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                                                   ) AS cp
                                                                              WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`SvcComponent`=cp.`TrgSvcComponent`)
                                                                          ) AS ECps1
                                                                     WHERE ECps0.`TrgOrgUnit`=ECps1.`SrcOrgUnit`
                                                                   ) AS isect1
                                                              WHERE (isect0.`SrcActivity` = isect1.`SrcActivity` AND isect0.`TrgSvcComponent` = isect1.`TrgSvcComponent`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Capability for all roles:
      'Capability' => 
      array ( 'name' => 'Capability'
            // Normalized interface expression (== expressionSQL): EDcI Capability
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Capability'
            , 'tgtConcept' => 'Capability'
            , 'expressionSQL' => '/* I[Capability] */
                                  SELECT DISTINCT `Capability` AS src, `Capability` AS tgt
                                  FROM `Capability`
                                  WHERE `Capability` IS NOT NULL AND `Capability` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Capability'
                          // Normalized interface expression (== expressionSQL): EDcI Capability
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Capability'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => '/* I[Capability] */
                                                SELECT DISTINCT `Capability` AS src, `Capability` AS tgt
                                                FROM `Capability`
                                                WHERE `Capability` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Qualified OrgUnits'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION ouQualifiedFor [OrgUnit*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit is qualified for the Capability +})
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Capability'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Capability` AS src, `OrgUnit` AS tgt
                                                FROM `ouQualifiedFor`
                                                WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Required by (Act.Type)'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION atReqsCpb [ActivityType*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the Capability +})
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Capability'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Capability` AS src, `ActivityType` AS tgt
                                                FROM `atReqsCpb`
                                                WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface OrgUnit for all roles:
      'OrgUnit' => 
      array ( 'name' => 'OrgUnit'
            // Normalized interface expression (== expressionSQL): EDcI OrgUnit
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('Status', 'Capability')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'OrgUnit'
            , 'tgtConcept' => 'OrgUnit'
            , 'expressionSQL' => '/* I[OrgUnit] */
                                  SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                  FROM `OrgUnit`
                                  WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'OrgUnit'
                          // Normalized interface expression (== expressionSQL): EDcI OrgUnit
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* I[OrgUnit] */
                                                SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                                FROM `OrgUnit`
                                                WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): EDcI OrgUnit
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => '/* I[OrgUnit] */
                                                              SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION ouStatus [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `ouStatus` AS tgt
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION ouMnlStat [OrgUnit*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ OrgUnits can be assigned a new status +}
                                        , 'relation' => 'ouMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `ouMnlStat` AS tgt
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Capabilities'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION ouQualifiedFor [OrgUnit*Capability] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit is qualified for the Capability +}
                          , 'relation' => 'ouQualifiedFor'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `Capability` AS tgt
                                                FROM `ouQualifiedFor`
                                                WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Assignable ActivityTypes'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION ouMayExecuteAT [OrgUnit*ActivityType] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The OrgUnit has all necessary capabilities for executing activities of the ActivityType +}
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `ActivityType` AS tgt
                                                FROM `ouMayExecuteAT`
                                                WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Assigned Activities'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit +})
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `actExecutingOU` AS src, `Activity` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Owner of (Computer)'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" "")
                          , 'relation' => 'compOwner'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `compOwner` AS src, `Computer` AS tgt
                                                FROM `Computer`
                                                WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): EDcI OrgUnit
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* I[OrgUnit] */
                                                SELECT DISTINCT `OrgUnit` AS src, `OrgUnit` AS tgt
                                                FROM `OrgUnit`
                                                WHERE `OrgUnit` IS NOT NULL AND `OrgUnit` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'SvcComponents to be deployed'
                                        // Normalized interface expression (== expressionSQL): EIsc (ECps (EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -}),EDcD RELATION actUseSC [Activity*SvcComponent] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity requires the availability of the SvcComponent -}),ECpl (EBrk (ECps (EFlp (EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" ""),EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +})))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* case: (EIsc lst\'@(_:_:_))
                                                                 actExecutingOU~;actUseSC /\\ -(compOwner~;scDeployedOn~) ([OrgUnit*SvcComponent]) */
                                                              SELECT DISTINCT isect0.`SrcOrgUnit` AS src, isect0.`TrgSvcComponent` AS tgt
                                                              FROM 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        actExecutingOU~;actUseSC */
                                                                     
                                                                     SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgSvcComponent`
                                                                     FROM 
                                                                          ( /* case: EFlp x. */
                                                                            SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                                                            FROM `Activity`
                                                                            WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                                          ) AS ECps0,
                                                                          ( SELECT DISTINCT `Activity` AS `SrcActivity`, `SvcComponent` AS `TrgSvcComponent`
                                                                       FROM `actUseSC`
                                                                       WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS ECps1
                                                                     WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                                                                   ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    compOwner~;scDeployedOn~ */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`TrgSvcComponent`
                                                                                 FROM 
                                                                                      ( /* case: EFlp x. */
                                                                                        SELECT DISTINCT `Computer` AS `TrgComputer`, `compOwner` AS `SrcOrgUnit`
                                                                                        FROM `Computer`
                                                                                        WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL
                                                                                      ) AS ECps0,
                                                                                      
                                                                                      ( /* case: EFlp x. */
                                                                                        SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Computer` AS `SrcComputer`
                                                                                        FROM `scDeployedOn`
                                                                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                                                      ) AS ECps1
                                                                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                                               ) AS cp
                                                                          WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TrgSvcComponent`=cp.`TrgSvcComponent`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Activities to be planned'
                                        // Normalized interface expression (== expressionSQL): ECps (EFlp (EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -}),EBrk (EIsc (EDcI Activity,ECpl (EBrk (EIsc (ECps (EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. -},EFlp (EDcD RELATION actPlanStart [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to start at the specified time. -})),ECps (EDcD RELATION actPlanEnd [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to end at the specified time. -},EFlp (EDcD RELATION actPlanEnd [Activity*Timestamp] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Exeuction of the activity is planned to end at the specified time. +}))))))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Activity'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 actExecutingOU~;(I[Activity] /\\ -(actPlanStart;actPlanStart~ /\\ actPlanEnd;actPlanEnd~)) */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcOrgUnit` AS src, ECps1.`TrgActivity` AS tgt
                                                              FROM 
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `Activity` AS `TrgActivity`, `actExecutingOU` AS `SrcOrgUnit`
                                                                     FROM `Activity`
                                                                     WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst\'@(_:_:_))
                                                                        I[Activity] /\\ -(actPlanStart;actPlanStart~ /\\ actPlanEnd;actPlanEnd~) ([Activity*Activity]) */
                                                                     SELECT DISTINCT isect0.`SrcActivity`, isect0.`TrgActivity`
                                                                     FROM ( /* I[Activity] */
                                                                       SELECT DISTINCT `Activity` AS `SrcActivity`, `Activity` AS `TrgActivity`
                                                                       FROM `Activity`
                                                                       WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                      ( /* case: (EIsc lst\'@(_:_:_))
                                                                                           actPlanStart;actPlanStart~ /\\ actPlanEnd;actPlanEnd~ ([Activity*Activity]) */
                                                                                        SELECT DISTINCT isect0.`SrcActivity`, isect0.`TrgActivity`
                                                                                        FROM 
                                                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                                                  actPlanStart;actPlanStart~ */
                                                                                               
                                                                                               SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                                                                               FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actPlanStart` AS `TrgTimestamp`
                                                                                                 FROM `Activity`
                                                                                                 WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL ) AS ECps0,
                                                                                                    
                                                                                                    ( /* case: EFlp x. */
                                                                                                      SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlanStart` AS `SrcTimestamp`
                                                                                                      FROM `Activity`
                                                                                                      WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                                                                                    ) AS ECps1
                                                                                               WHERE ECps0.`TrgTimestamp`=ECps1.`SrcTimestamp`
                                                                                             ) AS isect0, 
                                                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                                                  actPlanEnd;actPlanEnd~ */
                                                                                               
                                                                                               SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`TrgActivity`
                                                                                               FROM ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actPlanEnd` AS `TrgTimestamp`
                                                                                                 FROM `Activity`
                                                                                                 WHERE `Activity` IS NOT NULL AND `actPlanEnd` IS NOT NULL ) AS ECps0,
                                                                                                    
                                                                                                    ( /* case: EFlp x. */
                                                                                                      SELECT DISTINCT `Activity` AS `TrgActivity`, `actPlanEnd` AS `SrcTimestamp`
                                                                                                      FROM `Activity`
                                                                                                      WHERE `Activity` IS NOT NULL AND `actPlanEnd` IS NOT NULL
                                                                                                    ) AS ECps1
                                                                                               WHERE ECps0.`TrgTimestamp`=ECps1.`SrcTimestamp`
                                                                                             ) AS isect1
                                                                                        WHERE (isect0.`SrcActivity` = isect1.`SrcActivity` AND isect0.`TrgActivity` = isect1.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL
                                                                                      ) AS cp
                                                                                 WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TrgActivity`=cp.`TrgActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TrgActivity` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Service for role Developer:
      'Service' => 
      array ( 'name' => 'Service'
            // Normalized interface expression (== expressionSQL): EDcI Service
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('ServiceID', 'Status')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Service'
            , 'tgtConcept' => 'Service'
            , 'expressionSQL' => '/* I[Service] */
                                  SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                  FROM `Service`
                                  WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Service'
                          // Normalized interface expression (== expressionSQL): EDcI Service
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => '/* I[Service] */
                                                SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                                FROM `Service`
                                                WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION svcID [Service*ServiceID] Nothing PRAGMA "" "" ""
                                        , 'relation' => 'svcID'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'ServiceID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Service` AS src, `svcID` AS tgt
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION svcStatus [Service*Status] Nothing PRAGMA "" "" ""
                                        , 'relation' => 'svcStatus'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Service` AS src, `svcStatus` AS tgt
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Required by (ActivityType)'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION atReqsSvc [ActivityType*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Executing an instance of ActivityType requires the availability of (a realization of) the Service +})
                          , 'relation' => 'atReqsSvc'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Service` AS src, `ActivityType` AS tgt
                                                FROM `atReqsSvc`
                                                WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Implemented by (SvcComponent)'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +})
                          , 'relation' => 'scImplements'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Service` AS src, `SvcComponent` AS tgt
                                                FROM `scImplements`
                                                WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Deployed on (Computer)'
                          // Normalized interface expression (== expressionSQL): ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +})
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   scImplements~;scDeployedOn */
                                                
                                                SELECT DISTINCT ECps0.`SrcService` AS src, ECps1.`TrgComputer` AS tgt
                                                FROM 
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                       FROM `scImplements`
                                                       WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                     ) AS ECps0,
                                                     ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                  FROM `scDeployedOn`
                                                  WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps1
                                                WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Networks used (Network)'
                          // Normalized interface expression (== expressionSQL): ECps (EFlp (EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service -}),ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +},ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   scImplements~;(scDeployedOn;(compRouter;routerNW)) */
                                                
                                                SELECT DISTINCT ECps0.`SrcService` AS src, ECps3.`TrgNetwork` AS tgt
                                                FROM 
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `SvcComponent` AS `TrgSvcComponent`, `Service` AS `SrcService`
                                                       FROM `scImplements`
                                                       WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                     ) AS ECps0,
                                                     ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                  FROM `scDeployedOn`
                                                  WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps1,
                                                     ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                  FROM `compRouter`
                                                  WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps2,
                                                     ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                  FROM `Router`
                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps3
                                                WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                  AND ECps1.`TrgComputer`=ECps2.`SrcComputer`
                                                  AND ECps2.`TrgRouter`=ECps3.`SrcRouter`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface SvcComponent for role Developer:
      'SvcComponent' => 
      array ( 'name' => 'SvcComponent'
            // Normalized interface expression (== expressionSQL): EDcI SvcComponent
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('SvcComponentID', 'SvcComponentName', 'Status', 'Status', 'Computer', 'SvcComponent', 'SvcComponent', 'Service')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'SvcComponent'
            , 'tgtConcept' => 'SvcComponent'
            , 'expressionSQL' => '/* I[SvcComponent] */
                                  SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                  FROM `SvcComponent`
                                  WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'SvcComponent'
                          // Normalized interface expression (== expressionSQL): EDcI SvcComponent
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* I[SvcComponent] */
                                                SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                                FROM `SvcComponent`
                                                WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Serial'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION scID [SvcComponent*SvcComponentID] Nothing PRAGMA "" "" ""
                                        , 'relation' => 'scID'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponentID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scID` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Name'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION scName [SvcComponent*SvcComponentName] Nothing PRAGMA "" "" ""
                                        , 'relation' => 'scName'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponentName'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scName` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scName` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +}
                                        , 'relation' => 'scStatus'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scStatus` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION scMnlStat [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can be assigned a new status +}
                                        , 'relation' => 'scMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scMnlStat` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Instantiated (runs) on (Computer)'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +}
                          , 'relation' => 'scDeployedOn'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `Computer` AS tgt
                                                FROM `scDeployedOn`
                                                WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Requires sending messages to (SvcComponent)'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION scReqCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""
                          , 'relation' => 'scReqCommWith'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => 'SELECT DISTINCT `sSvcComponent` AS src, `tSvcComponent` AS tgt
                                                FROM `scReqCommWith`
                                                WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Can actually send messages to (SvcComponent)'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION scHasCommWith [SvcComponent*SvcComponent] Nothing PRAGMA "" "" ""
                          , 'relation' => 'scHasCommWith'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => 'SELECT DISTINCT `sSvcComponent` AS src, `tSvcComponent` AS tgt
                                                FROM `scHasCommWith`
                                                WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Implements (Service)'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION scImplements [SvcComponent*Service] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is one (of the possible) implementation(s) of the Service +}
                          , 'relation' => 'scImplements'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `Service` AS tgt
                                                FROM `scImplements`
                                                WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): EDcI SvcComponent
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* I[SvcComponent] */
                                                SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                                FROM `SvcComponent`
                                                WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Must be deployed on computer owned by'
                                        // Normalized interface expression (== expressionSQL): EIsc (ECps (EFlp (EDcD RELATION actUseSC [Activity*SvcComponent] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity requires the availability of the SvcComponent -}),EDcD RELATION actExecutingOU [Activity*OrgUnit] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Execution of the activity is done by the OrgUnit -}),ECpl (EBrk (ECps (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +},EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" ""))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => '/* case: (EIsc lst\'@(_:_:_))
                                                                 actUseSC~;actExecutingOU /\\ -(scDeployedOn;compOwner) ([SvcComponent*OrgUnit]) */
                                                              SELECT DISTINCT isect0.`SrcSvcComponent` AS src, isect0.`TrgOrgUnit` AS tgt
                                                              FROM 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        actUseSC~;actExecutingOU */
                                                                     
                                                                     SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgOrgUnit`
                                                                     FROM 
                                                                          ( /* case: EFlp x. */
                                                                            SELECT DISTINCT `Activity` AS `TrgActivity`, `SvcComponent` AS `SrcSvcComponent`
                                                                            FROM `actUseSC`
                                                                            WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL
                                                                          ) AS ECps0,
                                                                          ( SELECT DISTINCT `Activity` AS `SrcActivity`, `actExecutingOU` AS `TrgOrgUnit`
                                                                       FROM `Activity`
                                                                       WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL ) AS ECps1
                                                                     WHERE ECps0.`TrgActivity`=ECps1.`SrcActivity`
                                                                   ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    scDeployedOn;compOwner */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgOrgUnit`
                                                                                 FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `Computer` AS `TrgComputer`
                                                                                   FROM `scDeployedOn`
                                                                                   WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL ) AS ECps0,
                                                                                      ( SELECT DISTINCT `Computer` AS `SrcComputer`, `compOwner` AS `TrgOrgUnit`
                                                                                   FROM `Computer`
                                                                                   WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL ) AS ECps1
                                                                                 WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                                               ) AS cp
                                                                          WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TrgOrgUnit`=cp.`TrgOrgUnit`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgOrgUnit` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Computer for role Developer:
      'Computer' => 
      array ( 'name' => 'Computer'
            // Normalized interface expression (== expressionSQL): EDcI Computer
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('ComputerID', 'ComputerName', 'Status', 'OrgUnit', 'Router', 'Computer')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Computer'
            , 'tgtConcept' => 'Computer'
            , 'expressionSQL' => '/* I[Computer] */
                                  SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                  FROM `Computer`
                                  WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'ID'
                          // Normalized interface expression (== expressionSQL): EDcI Computer
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* I[Computer] */
                                                SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                FROM `Computer`
                                                WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer ID'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION compID [Computer*ComputerID] Nothing PRAGMA "" "" ""
                                        , 'relation' => 'compID'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'ComputerID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compID` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Computer Name'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION compName [Computer*ComputerName] Nothing PRAGMA "" "" ""
                                        , 'relation' => 'compName'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'ComputerName'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compName` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compName` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION compMnlStat [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can be assigned a new status +}
                                        , 'relation' => 'compMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compMnlStat` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Owner'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION compOwner [Computer*OrgUnit] Nothing PRAGMA "" "" ""
                          , 'relation' => 'compOwner'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compOwner` AS tgt
                                                FROM `Computer`
                                                WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Runs an instance of (service component)'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION scDeployedOn [SvcComponent*Computer] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ The SvcComponent is deployed on (and hence can be used from) the Computer +})
                          , 'relation' => 'scDeployedOn'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Computer` AS src, `SvcComponent` AS tgt
                                                FROM `scDeployedOn`
                                                WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected to (Router)'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""
                          , 'relation' => 'compRouter'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Router` AS tgt
                                                FROM `compRouter`
                                                WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Requires sending messages to (Computer)'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" ""
                          , 'relation' => 'compReqCommWith'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => 'SELECT DISTINCT `sComputer` AS src, `tComputer` AS tgt
                                                FROM `compReqCommWith`
                                                WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): EDcI Computer
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* I[Computer] */
                                                SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                FROM `Computer`
                                                WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Organize connectivity with (Computer)'
                                        // Normalized interface expression (== expressionSQL): EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" ""))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* case: (EIsc lst\'@(_:_:_))
                                                                 compReqCommWith /\\ -compHasCommWith ([Computer*Computer]) */
                                                              SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                                                              FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                FROM `compReqCommWith`
                                                                WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                            FROM `compHasCommWith`
                                                                            WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                                                          WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Router for role Developer:
      'Router' => 
      array ( 'name' => 'Router'
            // Normalized interface expression (== expressionSQL): EDcI Router
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('RouterID', 'RouterName', 'Network', 'Router')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Router'
            , 'tgtConcept' => 'Router'
            , 'expressionSQL' => '/* I[Router] */
                                  SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                  FROM `Router`
                                  WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Router'
                          // Normalized interface expression (== expressionSQL): EDcI Router
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* I[Router] */
                                                SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Serial'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION routerID [Router*RouterID] Nothing PRAGMA "" "" ""
                                        , 'relation' => 'routerID'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'RouterID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerID` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Name'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION routerName [Router*RouterName] Nothing PRAGMA "" "" ""
                                        , 'relation' => 'routerName'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'RouterName'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerName` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerName` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Is part of'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""
                          , 'relation' => 'routerNW'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerNW` AS tgt
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Routes (directly) to (Router)'
                          // Normalized interface expression (== expressionSQL): EDcD RELATION routerRoutesTo [Router*Router] Nothing PRAGMA "" "" ""
                          , 'relation' => 'routerRoutesTo'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => 'SELECT DISTINCT `sRouter` AS src, `tRouter` AS tgt
                                                FROM `routerRoutesTo`
                                                WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Routes (directly) to (Network)'
                          // Normalized interface expression (== expressionSQL): EIsc (ECps (EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" "",EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",ECpl (EDcI Network)))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (EIsc lst\'@(_:_:_))
                                                   rrtDirect;routerNW /\\ routerNW;-I[Network] ([Router*Network]) */
                                                SELECT DISTINCT isect0.`SrcRouter` AS src, isect0.`TrgNetwork` AS tgt
                                                FROM 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          rrtDirect;routerNW */
                                                       
                                                       SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgNetwork`
                                                       FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                         FROM `rrtDirect`
                                                         WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps0,
                                                            ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                         FROM `Router`
                                                         WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps1
                                                       WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                     ) AS isect0, 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          routerNW;-I[Network] */
                                                       
                                                       SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgNetwork`
                                                       FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                         FROM `Router`
                                                         WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                            
                                                            ( /* case: ECpl e
                                                                 ECpl ( \"I[Network]\" ) */
                                                              SELECT DISTINCT cfst.`Network` AS `SrcNetwork`, csnd.`Network` AS `TrgNetwork`
                                                              FROM `Network` AS cfst,
                                                                   `Network` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM ( /* I[Network] */
                                                                  SELECT DISTINCT `Network` AS `SrcNetwork`, `Network` AS `TrgNetwork`
                                                                  FROM `Network`
                                                                  WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL ) AS cp
                                                                WHERE cfst.`Network`=cp.`SrcNetwork` AND csnd.`Network`=cp.`TrgNetwork`)
                                                            ) AS ECps1
                                                       WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                                     ) AS isect1
                                                WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TrgNetwork` = isect1.`TrgNetwork`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected to (Computer)'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "")
                          , 'relation' => 'compRouter'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Router` AS src, `Computer` AS tgt
                                                FROM `compRouter`
                                                WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): EDcI Router
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* I[Router] */
                                                SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Organize connectivity with (Router)'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `sRouter` AS src, `tRouter` AS tgt
                                                              FROM `routerNeedsPathTo`
                                                              WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Network for role Developer:
      'Network' => 
      array ( 'name' => 'Network'
            // Normalized interface expression (== expressionSQL): EDcI Network
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('NetworkID')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Network'
            , 'tgtConcept' => 'Network'
            , 'expressionSQL' => '/* I[Network] */
                                  SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                  FROM `Network`
                                  WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Network'
                          // Normalized interface expression (== expressionSQL): EDcI Network
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* I[Network] */
                                                SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                                FROM `Network`
                                                WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION nwID [Network*NetworkID] Nothing PRAGMA "" "" ""
                                        , 'relation' => 'nwID'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'NetworkID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Network` AS src, `nwID` AS tgt
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION nwStatus [Network*Status] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Network` AS src, `nwStatus` AS tgt
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Routers'
                          // Normalized interface expression (== expressionSQL): EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")
                          , 'relation' => 'routerNW'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `routerNW` AS src, `Router` AS tgt
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected Networks'
                          // Normalized interface expression (== expressionSQL): EIsc (ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),ECps (EDcD RELATION rrtDirect [Router*Router] Nothing PRAGMA "" "" "",EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")),ECpl (EDcI Network))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (EIsc lst\'@(_:_:_))
                                                   routerNW~;(rrtDirect;routerNW) /\\ -I[Network] ([Network*Network]) */
                                                SELECT DISTINCT isect0.`SrcNetwork` AS src, isect0.`TrgNetwork` AS tgt
                                                FROM 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          routerNW~;(rrtDirect;routerNW) */
                                                       
                                                       SELECT DISTINCT ECps0.`SrcNetwork`, ECps2.`TrgNetwork`
                                                       FROM 
                                                            ( /* case: EFlp x. */
                                                              SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                            ) AS ECps0,
                                                            ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                         FROM `rrtDirect`
                                                         WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps1,
                                                            ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                         FROM `Router`
                                                         WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps2
                                                       WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                         AND ECps1.`TrgRouter`=ECps2.`SrcRouter`
                                                     ) AS isect0
                                                WHERE isect0.`SrcNetwork` <> isect0.`TrgNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TrgNetwork` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected Computers'
                          // Normalized interface expression (== expressionSQL): ECps (EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" ""),EFlp (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" ""))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   routerNW~;compRouter~ */
                                                
                                                SELECT DISTINCT ECps0.`SrcNetwork` AS src, ECps1.`TrgComputer` AS tgt
                                                FROM 
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                       FROM `Router`
                                                       WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                     ) AS ECps0,
                                                     
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                       FROM `compRouter`
                                                       WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                     ) AS ECps1
                                                WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Obligations [Dev] for role Developer:
      'Obligations [Dev]' => 
      array ( 'name' => 'Obligations [Dev]'
            // Normalized interface expression (== expressionSQL): EDcI ONE
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* I[ONE] */
                                  SELECT 1 AS src, 1 AS tgt'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Connect computer to network router'
                          // Normalized interface expression (== expressionSQL): ECps (EDcV [ONE*Computer],EDcD RELATION connectComputerToNetworkRouter [Computer*Computer] Nothing PRAGMA "" "" "")
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case:  (EDcV (Sign ONE _): fs@(_:_))
                                                   V[ONE*Computer];connectComputerToNetworkRouter */
                                                SELECT DISTINCT 1 AS src, fst.`TrgComputer` AS tgt
                                                FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `connectComputerToNetworkRouter` AS `TrgComputer`
                                                  FROM `Computer`
                                                  WHERE `Computer` IS NOT NULL AND `connectComputerToNetworkRouter` IS NOT NULL ) AS fst
                                                WHERE fst.`TrgComputer` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer'
                                        // Normalized interface expression (== expressionSQL): EDcI Computer
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* I[Computer] */
                                                              SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Create router paths'
                          // Normalized interface expression (== expressionSQL): ECps (EDcV [ONE*Router],EBrk (EIsc (EDcI Router,ECps (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" "")))))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case:  (EDcV (Sign ONE _): fs@(_:_))
                                                   V[ONE*Router];(I[Router] /\\ routerNeedsPathTo;routerNeedsPathTo~) */
                                                SELECT DISTINCT 1 AS src, fst.`TrgRouter` AS tgt
                                                FROM 
                                                     ( /* case: (EIsc lst\'@(_:_:_))
                                                          I[Router] /\\ routerNeedsPathTo;routerNeedsPathTo~ ([Router*Router]) */
                                                       SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 routerNeedsPathTo;routerNeedsPathTo~ */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                              FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                                FROM `routerNeedsPathTo`
                                                                WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `sRouter` AS `TrgRouter`, `tRouter` AS `SrcRouter`
                                                                     FROM `routerNeedsPathTo`
                                                                     WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                            ) AS isect0, ( /* I[Router] */
                                                         SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                         FROM `Router`
                                                         WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                       WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                     ) AS fst
                                                WHERE fst.`TrgRouter` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Router'
                                        // Normalized interface expression (== expressionSQL): EDcI Router
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => '/* I[Router] */
                                                              SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Serial'
                                                      // Normalized interface expression (== expressionSQL): EDcI Router
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => '/* I[Router] */
                                                                            SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // Normalized interface expression (== expressionSQL): EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'needs path to'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `sRouter` AS src, `tRouter` AS tgt
                                                              FROM `routerNeedsPathTo`
                                                              WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Serial'
                                                      // Normalized interface expression (== expressionSQL): EDcI Router
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => '/* I[Router] */
                                                                            SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // Normalized interface expression (== expressionSQL): EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'Routes to be discarded'
                          // Normalized interface expression (== expressionSQL): ECps (EDcV [ONE*Router],EBrk (EIsc (EDcI Router,ECps (EDcD RELATION routesToBeDiscarded [Router*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routesToBeDiscarded [Router*Router] Nothing PRAGMA "" "" "")))))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case:  (EDcV (Sign ONE _): fs@(_:_))
                                                   V[ONE*Router];(I[Router] /\\ routesToBeDiscarded;routesToBeDiscarded~) */
                                                SELECT DISTINCT 1 AS src, fst.`TrgRouter` AS tgt
                                                FROM 
                                                     ( /* case: (EIsc lst\'@(_:_:_))
                                                          I[Router] /\\ routesToBeDiscarded;routesToBeDiscarded~ ([Router*Router]) */
                                                       SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 routesToBeDiscarded;routesToBeDiscarded~ */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                              FROM ( SELECT DISTINCT `sRouter` AS `SrcRouter`, `tRouter` AS `TrgRouter`
                                                                FROM `routesToBeDiscarded`
                                                                WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL ) AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `sRouter` AS `TrgRouter`, `tRouter` AS `SrcRouter`
                                                                     FROM `routesToBeDiscarded`
                                                                     WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                            ) AS isect0, ( /* I[Router] */
                                                         SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                         FROM `Router`
                                                         WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                       WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                     ) AS fst
                                                WHERE fst.`TrgRouter` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Discard route from'
                                        // Normalized interface expression (== expressionSQL): EDcI Router
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => '/* I[Router] */
                                                              SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Router'
                                                      // Normalized interface expression (== expressionSQL): EDcI Router
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => '/* I[Router] */
                                                                            SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // Normalized interface expression (== expressionSQL): EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'to'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION routerNeedsPathTo [Router*Router] Nothing PRAGMA "" "" ""
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `sRouter` AS src, `tRouter` AS tgt
                                                              FROM `routerNeedsPathTo`
                                                              WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Router'
                                                      // Normalized interface expression (== expressionSQL): EDcI Router
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => '/* I[Router] */
                                                                            SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // Normalized interface expression (== expressionSQL): EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'Computers to be disconnected'
                          // Normalized interface expression (== expressionSQL): ECps (EDcV [ONE*Computer],EBrk (EIsc (EDcI Computer,ECps (EDcD RELATION computerToBeDisconnected [Computer*Router] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION computerToBeDisconnected [Computer*Router] Nothing PRAGMA "" "" "")))))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case:  (EDcV (Sign ONE _): fs@(_:_))
                                                   V[ONE*Computer];(I[Computer] /\\ computerToBeDisconnected;computerToBeDisconnected~) */
                                                SELECT DISTINCT 1 AS src, fst.`TrgComputer` AS tgt
                                                FROM 
                                                     ( /* case: (EIsc lst\'@(_:_:_))
                                                          I[Computer] /\\ computerToBeDisconnected;computerToBeDisconnected~ ([Computer*Computer]) */
                                                       SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 computerToBeDisconnected;computerToBeDisconnected~ */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                                              FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                                FROM `computerToBeDisconnected`
                                                                WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `Computer` AS `TrgComputer`, `Router` AS `SrcRouter`
                                                                     FROM `computerToBeDisconnected`
                                                                     WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                            ) AS isect0, ( /* I[Computer] */
                                                         SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                                                         FROM `Computer`
                                                         WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                                                       WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                                     ) AS fst
                                                WHERE fst.`TrgComputer` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Disconnect'
                                        // Normalized interface expression (== expressionSQL): EDcI Computer
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* I[Computer] */
                                                              SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Computer'
                                                      // Normalized interface expression (== expressionSQL): EDcI Computer
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Computer'
                                                      , 'expressionSQL' => '/* I[Computer] */
                                                                            SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // Normalized interface expression (== expressionSQL): EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'from'
                                        // Normalized interface expression (== expressionSQL): EBrk (EIsc (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",ECpl (EBrk (ECps (EDcD RELATION compRouter [Computer*Router] Nothing PRAGMA "" "" "",EBrk (EIsc (EDcI Router,ECps (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION routerNW [Router*Network] Nothing PRAGMA "" "" "")))))))))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => '/* case: (EIsc lst\'@(_:_:_))
                                                                 compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)) ([Computer*Router]) */
                                                              SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgRouter` AS tgt
                                                              FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                                FROM `compRouter`
                                                                WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    compRouter;(I[Router] /\\ routerNW;routerNW~) */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgRouter`
                                                                                 FROM ( SELECT DISTINCT `Computer` AS `SrcComputer`, `Router` AS `TrgRouter`
                                                                                   FROM `compRouter`
                                                                                   WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL ) AS ECps0,
                                                                                      
                                                                                      ( /* case: (EIsc lst\'@(_:_:_))
                                                                                           I[Router] /\\ routerNW;routerNW~ ([Router*Router]) */
                                                                                        SELECT DISTINCT isect0.`SrcRouter`, isect0.`TrgRouter`
                                                                                        FROM 
                                                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                                                  routerNW;routerNW~ */
                                                                                               
                                                                                               SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TrgRouter`
                                                                                               FROM ( SELECT DISTINCT `Router` AS `SrcRouter`, `routerNW` AS `TrgNetwork`
                                                                                                 FROM `Router`
                                                                                                 WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL ) AS ECps0,
                                                                                                    
                                                                                                    ( /* case: EFlp x. */
                                                                                                      SELECT DISTINCT `Router` AS `TrgRouter`, `routerNW` AS `SrcNetwork`
                                                                                                      FROM `Router`
                                                                                                      WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                                                    ) AS ECps1
                                                                                               WHERE ECps0.`TrgNetwork`=ECps1.`SrcNetwork`
                                                                                             ) AS isect0, ( /* I[Router] */
                                                                                          SELECT DISTINCT `Router` AS `SrcRouter`, `Router` AS `TrgRouter`
                                                                                          FROM `Router`
                                                                                          WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL ) AS isect1
                                                                                        WHERE isect0.`SrcRouter` = isect0.`TrgRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL
                                                                                      ) AS ECps1
                                                                                 WHERE ECps0.`TrgRouter`=ECps1.`SrcRouter`
                                                                               ) AS cp
                                                                          WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgRouter`=cp.`TrgRouter`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgRouter` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Router'
                                                      // Normalized interface expression (== expressionSQL): EDcI Router
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => '/* I[Router] */
                                                                            SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // Normalized interface expression (== expressionSQL): EDcD RELATION routerStatus [Router*Status] Nothing PRAGMA "" "" ""
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'Set up computer-computer communications'
                          // Normalized interface expression (== expressionSQL): ECps (EDcV [ONE*Computer],EBrk (EIsc (EDcI Computer,ECps (EDcD RELATION setupComputerComputerCommunications [Computer*Computer] Nothing PRAGMA "" "" "",EFlp (EDcD RELATION setupComputerComputerCommunications [Computer*Computer] Nothing PRAGMA "" "" "")))))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case:  (EDcV (Sign ONE _): fs@(_:_))
                                                   V[ONE*Computer];(I[Computer] /\\ setupComputerComputerCommunications;setupComputerComputerCommunications~) */
                                                SELECT DISTINCT 1 AS src, fst.`TrgComputer` AS tgt
                                                FROM 
                                                     ( /* case: (EIsc lst\'@(_:_:_))
                                                          I[Computer] /\\ setupComputerComputerCommunications;setupComputerComputerCommunications~ ([Computer*Computer]) */
                                                       SELECT DISTINCT isect0.`SrcComputer`, isect0.`TrgComputer`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 setupComputerComputerCommunications;setupComputerComputerCommunications~ */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`TrgComputer`
                                                              FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                FROM `setupComputerComputerCommunications`
                                                                WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `sComputer` AS `TrgComputer`, `tComputer` AS `SrcComputer`
                                                                     FROM `setupComputerComputerCommunications`
                                                                     WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`TrgComputer`=ECps1.`SrcComputer`
                                                            ) AS isect0, ( /* I[Computer] */
                                                         SELECT DISTINCT `Computer` AS `SrcComputer`, `Computer` AS `TrgComputer`
                                                         FROM `Computer`
                                                         WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL ) AS isect1
                                                       WHERE isect0.`SrcComputer` = isect0.`TrgComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL
                                                     ) AS fst
                                                WHERE fst.`TrgComputer` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer'
                                        // Normalized interface expression (== expressionSQL): EDcI Computer
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* I[Computer] */
                                                              SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Computer'
                                                      // Normalized interface expression (== expressionSQL): EDcI Computer
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Computer'
                                                      , 'expressionSQL' => '/* I[Computer] */
                                                                            SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // Normalized interface expression (== expressionSQL): EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'requires communication with'
                                        // Normalized interface expression (== expressionSQL): EIsc (EDcD RELATION compReqCommWith [Computer*Computer] Nothing PRAGMA "" "" "",ECpl (EDcD RELATION compHasCommWith [Computer*Computer] Nothing PRAGMA "" "" ""))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* case: (EIsc lst\'@(_:_:_))
                                                                 compReqCommWith /\\ -compHasCommWith ([Computer*Computer]) */
                                                              SELECT DISTINCT isect0.`SrcComputer` AS src, isect0.`TrgComputer` AS tgt
                                                              FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                FROM `compReqCommWith`
                                                                WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM ( SELECT DISTINCT `sComputer` AS `SrcComputer`, `tComputer` AS `TrgComputer`
                                                                            FROM `compHasCommWith`
                                                                            WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL ) AS cp
                                                                          WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TrgComputer`=cp.`TrgComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TrgComputer` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Computer'
                                                      // Normalized interface expression (== expressionSQL): EDcI Computer
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Computer'
                                                      , 'expressionSQL' => '/* I[Computer] */
                                                                            SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // Normalized interface expression (== expressionSQL): EDcD RELATION compStatus [Computer*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ Computers can have a status (colour) +}
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'Start running service components'
                          // Normalization steps:
                          //     V[ONE*SvcComponent];(I[SvcComponent] /\\ startRunningServiceComponents;startRunningServiceComponents~)
                          // <=> { startRunningServiceComponents is symmetric }
                          //     V[ONE*SvcComponent];(I[SvcComponent] /\\ startRunningServiceComponents;startRunningServiceComponents)
                          //
                          // Normalized interface expression (== expressionSQL): ECps (EDcV [ONE*SvcComponent],EIsc (EDcI SvcComponent,ECps (EDcD RELATION startRunningServiceComponents [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "",EDcD RELATION startRunningServiceComponents [SvcComponent*SvcComponent] Nothing PRAGMA "" "" "")))
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case:  (EDcV (Sign ONE _): fs@(_:_))
                                                   V[ONE*SvcComponent];(I[SvcComponent] /\\ startRunningServiceComponents;startRunningServiceComponents) */
                                                SELECT DISTINCT 1 AS src, fst.`TrgSvcComponent` AS tgt
                                                FROM 
                                                     ( /* case: (EIsc lst\'@(_:_:_))
                                                          I[SvcComponent] /\\ startRunningServiceComponents;startRunningServiceComponents ([SvcComponent*SvcComponent]) */
                                                       SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TrgSvcComponent`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 startRunningServiceComponents;startRunningServiceComponents */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`TrgSvcComponent`
                                                              FROM ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `startRunningServiceComponents` AS `TrgSvcComponent`
                                                                FROM `SvcComponent`
                                                                WHERE `SvcComponent` IS NOT NULL AND `startRunningServiceComponents` IS NOT NULL ) AS ECps0,
                                                                   ( SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `startRunningServiceComponents` AS `TrgSvcComponent`
                                                                FROM `SvcComponent`
                                                                WHERE `SvcComponent` IS NOT NULL AND `startRunningServiceComponents` IS NOT NULL ) AS ECps1
                                                              WHERE ECps0.`TrgSvcComponent`=ECps1.`SrcSvcComponent`
                                                            ) AS isect0, ( /* I[SvcComponent] */
                                                         SELECT DISTINCT `SvcComponent` AS `SrcSvcComponent`, `SvcComponent` AS `TrgSvcComponent`
                                                         FROM `SvcComponent`
                                                         WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL ) AS isect1
                                                       WHERE isect0.`SrcSvcComponent` = isect0.`TrgSvcComponent` AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TrgSvcComponent` IS NOT NULL
                                                     ) AS fst
                                                WHERE fst.`TrgSvcComponent` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Service component'
                                        // Normalized interface expression (== expressionSQL): EDcI SvcComponent
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* I[SvcComponent] */
                                                              SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): EDcD RELATION scStatus [SvcComponent*Status] Nothing PRAGMA "" "" "" MEANING IN English HTML {+ SvcComponents can have a status (colour) +}
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scStatus` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    );
?>
