<?php
// module Generics.php generated by Generate.hs
// Prototype v2.2.0.1923:1935M, build time: 29-Mar-12 17:25.09 (lib: Ampersand v2.2.0.547:548M, build time: 27-Mar-12 16:02.13)


$versionInfo = 'Prototype v2.2.0.1923:1935M, build time: 29-Mar-12 17:25.09 (lib: Ampersand v2.2.0.547:548M, build time: 27-Mar-12 16:02.13)';

$dbName = 'rap';

$isDev = false;

$autoRefreshInterval = '0';

$allSpecializations =
  array
    ( 'PairID' => array ('Violation')
    , 'File' => array ('AdlFile', 'NewAdlFile', 'SavePopFile', 'SaveAdlFile')
    , 'AdlFile' => array ('NewAdlFile', 'SaveAdlFile')
    , 'Rule' => array ('PropertyRule')
    );

$relationTableInfo =
  array
    ( 'ctxnm' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Conid', 'table' => 'Conid', 'srcCol' => 'ctxnm', 'tgtCol' => 'Conid')
    , 'countrules' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Int', 'table' => 'Conid', 'srcCol' => 'ctxnm', 'tgtCol' => 'countrules')
    , 'countdecls' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Int', 'table' => 'Conid', 'srcCol' => 'ctxnm', 'tgtCol' => 'countdecls')
    , 'countcpts' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Int', 'table' => 'Conid', 'srcCol' => 'ctxnm', 'tgtCol' => 'countcpts')
    , 'ctxpats' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Pattern', 'table' => 'ctxpats', 'srcCol' => 'Context', 'tgtCol' => 'Pattern')
    , 'ptrls' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Rule', 'table' => 'ptrls', 'srcCol' => 'Pattern', 'tgtCol' => 'Rule')
    , 'ptdcs' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Declaration', 'table' => 'ptdcs', 'srcCol' => 'Pattern', 'tgtCol' => 'Declaration')
    , 'ptgns' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Gen', 'table' => 'ptgns', 'srcCol' => 'Pattern', 'tgtCol' => 'Gen')
    , 'ctxcs' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Concept', 'table' => 'ctxcs', 'srcCol' => 'Context', 'tgtCol' => 'Concept')
    , 'savecontext' => array ('srcConcept' => 'Context', 'tgtConcept' => 'SaveAdlFile', 'table' => 'Conid', 'srcCol' => 'ctxnm', 'tgtCol' => 'savecontext')
    , 'savepopulation' => array ('srcConcept' => 'Context', 'tgtConcept' => 'SavePopFile', 'table' => 'Conid', 'srcCol' => 'ctxnm', 'tgtCol' => 'savepopulation')
    , 'filename' => array ('srcConcept' => 'File', 'tgtConcept' => 'FileName', 'table' => 'File', 'srcCol' => 'File', 'tgtCol' => 'filename')
    , 'includes' => array ('srcConcept' => 'Context', 'tgtConcept' => 'File', 'table' => 'includes', 'srcCol' => 'Context', 'tgtCol' => 'File')
    , 'sourcefile' => array ('srcConcept' => 'Context', 'tgtConcept' => 'AdlFile', 'table' => 'Conid', 'srcCol' => 'ctxnm', 'tgtCol' => 'sourcefile')
    , 'applyto' => array ('srcConcept' => 'G', 'tgtConcept' => 'AdlFile', 'table' => 'G', 'srcCol' => 'G', 'tgtCol' => 'applyto')
    , 'newfile' => array ('srcConcept' => 'User', 'tgtConcept' => 'NewAdlFile', 'table' => 'User', 'srcCol' => 'User', 'tgtCol' => 'newfile')
    , 'uploaded' => array ('srcConcept' => 'User', 'tgtConcept' => 'File', 'table' => 'uploaded', 'srcCol' => 'User', 'tgtCol' => 'File')
    , 'ptxps' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Blob', 'table' => 'ptxps', 'srcCol' => 'Pattern', 'tgtCol' => 'Blob')
    , 'ptnm' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Conid', 'table' => 'Conid', 'srcCol' => 'ptnm', 'tgtCol' => 'Conid')
    , 'ptpic' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Image', 'table' => 'Conid', 'srcCol' => 'ptnm', 'tgtCol' => 'ptpic')
    , 'genspc' => array ('srcConcept' => 'Gen', 'tgtConcept' => 'Concept', 'table' => 'Gen', 'srcCol' => 'Gen', 'tgtCol' => 'genspc')
    , 'gengen' => array ('srcConcept' => 'Gen', 'tgtConcept' => 'Concept', 'table' => 'Gen', 'srcCol' => 'Gen', 'tgtCol' => 'gengen')
    , 'cptpurpose' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'Blob', 'table' => 'cptpurpose', 'srcCol' => 'Concept', 'tgtCol' => 'Blob')
    , 'cptdf' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'Blob', 'table' => 'cptdf', 'srcCol' => 'Concept', 'tgtCol' => 'Blob')
    , 'cptnm' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'Conid', 'table' => 'Conid', 'srcCol' => 'cptnm', 'tgtCol' => 'Conid')
    , 'cptos' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'AtomID', 'table' => 'AtomID', 'srcCol' => 'cptos', 'tgtCol' => 'AtomID')
    , 'atomvalue' => array ('srcConcept' => 'AtomID', 'tgtConcept' => 'Atom', 'table' => 'AtomID', 'srcCol' => 'AtomID', 'tgtCol' => 'atomvalue')
    , 'trg' => array ('srcConcept' => 'Sign', 'tgtConcept' => 'Concept', 'table' => 'Sign', 'srcCol' => 'Sign', 'tgtCol' => 'trg')
    , 'src' => array ('srcConcept' => 'Sign', 'tgtConcept' => 'Concept', 'table' => 'Sign', 'srcCol' => 'Sign', 'tgtCol' => 'src')
    , 'decsgn' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'Sign', 'table' => 'Declaration', 'srcCol' => 'Declaration', 'tgtCol' => 'decsgn')
    , 'declaredthrough' => array ('srcConcept' => 'PropertyRule', 'tgtConcept' => 'Property', 'table' => 'declaredthrough', 'srcCol' => 'PropertyRule', 'tgtCol' => 'Property')
    , 'decprps' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'PropertyRule', 'table' => 'ADLid', 'srcCol' => 'decprps', 'tgtCol' => 'PropertyRule')
    , 'relsgn' => array ('srcConcept' => 'Relation', 'tgtConcept' => 'Sign', 'table' => 'Relation', 'srcCol' => 'Relation', 'tgtCol' => 'relsgn')
    , 'rels' => array ('srcConcept' => 'ExpressionID', 'tgtConcept' => 'Relation', 'table' => 'rels', 'srcCol' => 'ExpressionID', 'tgtCol' => 'Relation')
    , 'rrexp' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'ExpressionID', 'table' => 'ADLid', 'srcCol' => 'rrnm', 'tgtCol' => 'rrexp')
    , 'cptpic' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'Image', 'table' => 'Conid', 'srcCol' => 'cptnm', 'tgtCol' => 'cptpic')
    , 'decpurpose' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'Blob', 'table' => 'decpurpose', 'srcCol' => 'Declaration', 'tgtCol' => 'Blob')
    , 'decmean' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'Blob', 'table' => 'decmean', 'srcCol' => 'Declaration', 'tgtCol' => 'Blob')
    , 'decnm' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'Varid', 'table' => 'Declaration', 'srcCol' => 'Declaration', 'tgtCol' => 'decnm')
    , 'decprL' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'String', 'table' => 'Declaration', 'srcCol' => 'Declaration', 'tgtCol' => 'decprL')
    , 'decprM' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'String', 'table' => 'Declaration', 'srcCol' => 'Declaration', 'tgtCol' => 'decprM')
    , 'decprR' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'String', 'table' => 'Declaration', 'srcCol' => 'Declaration', 'tgtCol' => 'decprR')
    , 'decpopu' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'PairID', 'table' => 'decpopu', 'srcCol' => 'Declaration', 'tgtCol' => 'PairID')
    , 'pairvalue' => array ('srcConcept' => 'PairID', 'tgtConcept' => 'Pair', 'table' => 'PairID', 'srcCol' => 'PairID', 'tgtCol' => 'pairvalue')
    , 'left' => array ('srcConcept' => 'Pair', 'tgtConcept' => 'AtomID', 'table' => 'Pair', 'srcCol' => 'Pair', 'tgtCol' => 'left')
    , 'right' => array ('srcConcept' => 'Pair', 'tgtConcept' => 'AtomID', 'table' => 'Pair', 'srcCol' => 'Pair', 'tgtCol' => 'right')
    , 'reldcl' => array ('srcConcept' => 'Relation', 'tgtConcept' => 'Declaration', 'table' => 'Relation', 'srcCol' => 'Relation', 'tgtCol' => 'reldcl')
    , 'rrpurpose' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'Blob', 'table' => 'rrpurpose', 'srcCol' => 'Rule', 'tgtCol' => 'Blob')
    , 'rrmean' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'Blob', 'table' => 'rrmean', 'srcCol' => 'Rule', 'tgtCol' => 'Blob')
    , 'rrnm' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'ADLid', 'table' => 'ADLid', 'srcCol' => 'rrnm', 'tgtCol' => 'ADLid')
    , 'rrpic' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'Image', 'table' => 'ADLid', 'srcCol' => 'rrnm', 'tgtCol' => 'rrpic')
    , 'compilererror' => array ('srcConcept' => 'File', 'tgtConcept' => 'ErrorMessage', 'table' => 'File', 'srcCol' => 'File', 'tgtCol' => 'compilererror')
    , 'filepath' => array ('srcConcept' => 'File', 'tgtConcept' => 'FilePath', 'table' => 'File', 'srcCol' => 'File', 'tgtCol' => 'filepath')
    , 'relnm' => array ('srcConcept' => 'Relation', 'tgtConcept' => 'Varid', 'table' => 'Relation', 'srcCol' => 'Relation', 'tgtCol' => 'relnm')
    , 'inios' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'AtomID', 'table' => 'inios', 'srcCol' => 'Concept', 'tgtCol' => 'AtomID')
    , 'inipopu' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'PairID', 'table' => 'inipopu', 'srcCol' => 'Declaration', 'tgtCol' => 'PairID')
    , 'rrviols' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'Violation', 'table' => 'rrviols', 'srcCol' => 'Rule', 'tgtCol' => 'Violation')
    );

$conceptTableInfo =
  array
    ( 'Concept' => array 
          ( array ( 'table' => 'Conid'
                  , 'cols' => array ('cptnm')
                  )
          )
    , 'AtomID' => array 
          ( array ( 'table' => 'AtomID'
                  , 'cols' => array ('AtomID')
                  )
          )
    , 'Declaration' => array 
          ( array ( 'table' => 'Declaration'
                  , 'cols' => array ('Declaration')
                  )
          )
    , 'PairID' => array 
          ( array ( 'table' => 'PairID'
                  , 'cols' => array ('PairID')
                  )
          )
    , 'File' => array 
          ( array ( 'table' => 'File'
                  , 'cols' => array ('File')
                  )
          )
    , 'ErrorMessage' => array 
          ( array ( 'table' => 'ErrorMessage'
                  , 'cols' => array ('ErrorMessage')
                  )
          )
    , 'Image' => array 
          ( array ( 'table' => 'Image'
                  , 'cols' => array ('Image')
                  )
          )
    , 'URL' => array 
          ( array ( 'table' => 'URL'
                  , 'cols' => array ('URL')
                  )
          )
    , 'FileName' => array 
          ( array ( 'table' => 'FileName'
                  , 'cols' => array ('FileName')
                  )
          )
    , 'FilePath' => array 
          ( array ( 'table' => 'FilePath'
                  , 'cols' => array ('FilePath')
                  )
          )
    , 'User' => array 
          ( array ( 'table' => 'User'
                  , 'cols' => array ('User')
                  )
          )
    , 'Context' => array 
          ( array ( 'table' => 'Conid'
                  , 'cols' => array ('ctxnm')
                  )
          )
    , 'AdlFile' => array 
          ( array ( 'table' => 'File'
                  , 'cols' => array ('AdlFile', 'File')
                  )
          )
    , 'G' => array 
          ( array ( 'table' => 'G'
                  , 'cols' => array ('G')
                  )
          )
    , 'String' => array 
          ( array ( 'table' => 'String'
                  , 'cols' => array ('String')
                  )
          )
    , 'Int' => array 
          ( array ( 'table' => 'Int'
                  , 'cols' => array ('Int')
                  )
          )
    , 'NewAdlFile' => array 
          ( array ( 'table' => 'File'
                  , 'cols' => array ('NewAdlFile', 'File', 'AdlFile')
                  )
          )
    , 'SavePopFile' => array 
          ( array ( 'table' => 'File'
                  , 'cols' => array ('SavePopFile', 'File')
                  )
          )
    , 'SaveAdlFile' => array 
          ( array ( 'table' => 'File'
                  , 'cols' => array ('SaveAdlFile', 'File', 'AdlFile')
                  )
          )
    , 'Pattern' => array 
          ( array ( 'table' => 'Conid'
                  , 'cols' => array ('ptnm')
                  )
          )
    , 'Rule' => array 
          ( array ( 'table' => 'ADLid'
                  , 'cols' => array ('rrnm')
                  )
          )
    , 'Violation' => array 
          ( array ( 'table' => 'PairID'
                  , 'cols' => array ('Violation', 'PairID')
                  )
          )
    , 'Conid' => array 
          ( array ( 'table' => 'Conid'
                  , 'cols' => array ('Conid')
                  )
          )
    , 'Gen' => array 
          ( array ( 'table' => 'Gen'
                  , 'cols' => array ('Gen')
                  )
          )
    , 'Blob' => array 
          ( array ( 'table' => 'Blob'
                  , 'cols' => array ('Blob')
                  )
          )
    , 'Atom' => array 
          ( array ( 'table' => 'Atom'
                  , 'cols' => array ('Atom')
                  )
          )
    , 'Sign' => array 
          ( array ( 'table' => 'Sign'
                  , 'cols' => array ('Sign')
                  )
          )
    , 'Pair' => array 
          ( array ( 'table' => 'Pair'
                  , 'cols' => array ('Pair')
                  )
          )
    , 'Varid' => array 
          ( array ( 'table' => 'Varid'
                  , 'cols' => array ('Varid')
                  )
          )
    , 'PropertyRule' => array 
          ( array ( 'table' => 'ADLid'
                  , 'cols' => array ('PropertyRule', 'rrnm')
                  )
          )
    , 'Property' => array 
          ( array ( 'table' => 'Property'
                  , 'cols' => array ('Property')
                  )
          )
    , 'ExpressionID' => array 
          ( array ( 'table' => 'ExpressionID'
                  , 'cols' => array ('ExpressionID')
                  )
          )
    , 'Expression' => array 
          ( array ( 'table' => 'Expression'
                  , 'cols' => array ('Expression')
                  )
          )
    , 'Relation' => array 
          ( array ( 'table' => 'Relation'
                  , 'cols' => array ('Relation')
                  )
          )
    , 'ADLid' => array 
          ( array ( 'table' => 'ADLid'
                  , 'cols' => array ('ADLid')
                  )
          )
    );

$tableColumnInfo =
  array
    ( 'Conid' =>
        array
          ( 'Conid' => array ( 'concept' => 'Conid', 'unique' => true, 'null' => false)
          , 'ctxnm' => array ( 'concept' => 'Context', 'unique' => true, 'null' => true)
          , 'ptnm' => array ( 'concept' => 'Pattern', 'unique' => true, 'null' => true)
          , 'cptnm' => array ( 'concept' => 'Concept', 'unique' => true, 'null' => true)
          , 'sourcefile' => array ( 'concept' => 'AdlFile', 'unique' => false, 'null' => true)
          , 'savepopulation' => array ( 'concept' => 'SavePopFile', 'unique' => false, 'null' => true)
          , 'savecontext' => array ( 'concept' => 'SaveAdlFile', 'unique' => false, 'null' => true)
          , 'countrules' => array ( 'concept' => 'Int', 'unique' => false, 'null' => true)
          , 'countdecls' => array ( 'concept' => 'Int', 'unique' => false, 'null' => true)
          , 'countcpts' => array ( 'concept' => 'Int', 'unique' => false, 'null' => true)
          , 'ptpic' => array ( 'concept' => 'Image', 'unique' => false, 'null' => true)
          , 'cptpic' => array ( 'concept' => 'Image', 'unique' => false, 'null' => true)
          )
    , 'File' =>
        array
          ( 'File' => array ( 'concept' => 'File', 'unique' => true, 'null' => false)
          , 'AdlFile' => array ( 'concept' => 'AdlFile', 'unique' => true, 'null' => true)
          , 'SavePopFile' => array ( 'concept' => 'SavePopFile', 'unique' => true, 'null' => true)
          , 'NewAdlFile' => array ( 'concept' => 'NewAdlFile', 'unique' => true, 'null' => true)
          , 'SaveAdlFile' => array ( 'concept' => 'SaveAdlFile', 'unique' => true, 'null' => true)
          , 'compilererror' => array ( 'concept' => 'ErrorMessage', 'unique' => false, 'null' => true)
          , 'filename' => array ( 'concept' => 'FileName', 'unique' => false, 'null' => false)
          , 'filepath' => array ( 'concept' => 'FilePath', 'unique' => false, 'null' => true)
          )
    , 'ADLid' =>
        array
          ( 'ADLid' => array ( 'concept' => 'ADLid', 'unique' => true, 'null' => false)
          , 'rrnm' => array ( 'concept' => 'Rule', 'unique' => true, 'null' => true)
          , 'PropertyRule' => array ( 'concept' => 'PropertyRule', 'unique' => true, 'null' => true)
          , 'rrpic' => array ( 'concept' => 'Image', 'unique' => false, 'null' => true)
          , 'rrexp' => array ( 'concept' => 'ExpressionID', 'unique' => false, 'null' => true)
          , 'decprps' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => true)
          )
    , 'Declaration' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => true, 'null' => false)
          , 'decnm' => array ( 'concept' => 'Varid', 'unique' => false, 'null' => false)
          , 'decsgn' => array ( 'concept' => 'Sign', 'unique' => false, 'null' => false)
          , 'decprL' => array ( 'concept' => 'String', 'unique' => false, 'null' => true)
          , 'decprM' => array ( 'concept' => 'String', 'unique' => false, 'null' => true)
          , 'decprR' => array ( 'concept' => 'String', 'unique' => false, 'null' => true)
          )
    , 'Relation' =>
        array
          ( 'Relation' => array ( 'concept' => 'Relation', 'unique' => true, 'null' => false)
          , 'relnm' => array ( 'concept' => 'Varid', 'unique' => false, 'null' => false)
          , 'relsgn' => array ( 'concept' => 'Sign', 'unique' => false, 'null' => false)
          , 'reldcl' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          )
    , 'G' =>
        array
          ( 'G' => array ( 'concept' => 'G', 'unique' => true, 'null' => false)
          , 'applyto' => array ( 'concept' => 'AdlFile', 'unique' => false, 'null' => false)
          , 'functionname' => array ( 'concept' => 'String', 'unique' => false, 'null' => false)
          , 'operation' => array ( 'concept' => 'Int', 'unique' => false, 'null' => false)
          )
    , 'Pair' =>
        array
          ( 'Pair' => array ( 'concept' => 'Pair', 'unique' => true, 'null' => false)
          , 'left' => array ( 'concept' => 'AtomID', 'unique' => false, 'null' => false)
          , 'right' => array ( 'concept' => 'AtomID', 'unique' => false, 'null' => false)
          )
    , 'Sign' =>
        array
          ( 'Sign' => array ( 'concept' => 'Sign', 'unique' => true, 'null' => false)
          , 'src' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'trg' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          )
    , 'Gen' =>
        array
          ( 'Gen' => array ( 'concept' => 'Gen', 'unique' => true, 'null' => false)
          , 'gengen' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'genspc' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          )
    , 'PairID' =>
        array
          ( 'PairID' => array ( 'concept' => 'PairID', 'unique' => true, 'null' => false)
          , 'Violation' => array ( 'concept' => 'Violation', 'unique' => true, 'null' => true)
          , 'pairvalue' => array ( 'concept' => 'Pair', 'unique' => false, 'null' => false)
          )
    , 'AtomID' =>
        array
          ( 'AtomID' => array ( 'concept' => 'AtomID', 'unique' => true, 'null' => false)
          , 'atomvalue' => array ( 'concept' => 'Atom', 'unique' => false, 'null' => false)
          , 'cptos' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => true)
          )
    , 'ExpressionID' =>
        array
          ( 'ExpressionID' => array ( 'concept' => 'ExpressionID', 'unique' => true, 'null' => false)
          , 'exprvalue' => array ( 'concept' => 'Expression', 'unique' => false, 'null' => false)
          )
    , 'User' =>
        array
          ( 'User' => array ( 'concept' => 'User', 'unique' => true, 'null' => false)
          , 'newfile' => array ( 'concept' => 'NewAdlFile', 'unique' => false, 'null' => false)
          )
    , 'Expression' =>
        array
          ( 'Expression' => array ( 'concept' => 'Expression', 'unique' => true, 'null' => false)
          )
    , 'Property' =>
        array
          ( 'Property' => array ( 'concept' => 'Property', 'unique' => true, 'null' => false)
          )
    , 'Varid' =>
        array
          ( 'Varid' => array ( 'concept' => 'Varid', 'unique' => true, 'null' => false)
          )
    , 'Atom' =>
        array
          ( 'Atom' => array ( 'concept' => 'Atom', 'unique' => true, 'null' => false)
          )
    , 'Blob' =>
        array
          ( 'Blob' => array ( 'concept' => 'Blob', 'unique' => true, 'null' => false)
          )
    , 'Int' =>
        array
          ( 'Int' => array ( 'concept' => 'Int', 'unique' => true, 'null' => false)
          )
    , 'String' =>
        array
          ( 'String' => array ( 'concept' => 'String', 'unique' => true, 'null' => false)
          )
    , 'FilePath' =>
        array
          ( 'FilePath' => array ( 'concept' => 'FilePath', 'unique' => true, 'null' => false)
          )
    , 'FileName' =>
        array
          ( 'FileName' => array ( 'concept' => 'FileName', 'unique' => true, 'null' => false)
          )
    , 'URL' =>
        array
          ( 'URL' => array ( 'concept' => 'URL', 'unique' => true, 'null' => false)
          )
    , 'Image' =>
        array
          ( 'Image' => array ( 'concept' => 'Image', 'unique' => true, 'null' => false)
          )
    , 'ErrorMessage' =>
        array
          ( 'ErrorMessage' => array ( 'concept' => 'ErrorMessage', 'unique' => true, 'null' => false)
          )
    , 'inios' =>
        array
          ( 'Concept' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'AtomID' => array ( 'concept' => 'AtomID', 'unique' => false, 'null' => false)
          )
    , 'inipopu' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          , 'PairID' => array ( 'concept' => 'PairID', 'unique' => false, 'null' => false)
          )
    , 'imageurl' =>
        array
          ( 'Image' => array ( 'concept' => 'Image', 'unique' => false, 'null' => false)
          , 'URL' => array ( 'concept' => 'URL', 'unique' => false, 'null' => false)
          )
    , 'uploaded' =>
        array
          ( 'User' => array ( 'concept' => 'User', 'unique' => false, 'null' => false)
          , 'File' => array ( 'concept' => 'File', 'unique' => false, 'null' => false)
          )
    , 'includes' =>
        array
          ( 'Context' => array ( 'concept' => 'Context', 'unique' => false, 'null' => false)
          , 'File' => array ( 'concept' => 'File', 'unique' => false, 'null' => false)
          )
    , 'rrviols' =>
        array
          ( 'Rule' => array ( 'concept' => 'Rule', 'unique' => false, 'null' => false)
          , 'Violation' => array ( 'concept' => 'Violation', 'unique' => false, 'null' => false)
          )
    , 'ctxpats' =>
        array
          ( 'Context' => array ( 'concept' => 'Context', 'unique' => false, 'null' => false)
          , 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          )
    , 'ctxcs' =>
        array
          ( 'Context' => array ( 'concept' => 'Context', 'unique' => false, 'null' => false)
          , 'Concept' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          )
    , 'ptrls' =>
        array
          ( 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          , 'Rule' => array ( 'concept' => 'Rule', 'unique' => false, 'null' => false)
          )
    , 'ptgns' =>
        array
          ( 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          , 'Gen' => array ( 'concept' => 'Gen', 'unique' => false, 'null' => false)
          )
    , 'ptdcs' =>
        array
          ( 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          , 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          )
    , 'ptxps' =>
        array
          ( 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'cptdf' =>
        array
          ( 'Concept' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'cptpurpose' =>
        array
          ( 'Concept' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'declaredthrough' =>
        array
          ( 'PropertyRule' => array ( 'concept' => 'PropertyRule', 'unique' => false, 'null' => true)
          , 'Property' => array ( 'concept' => 'Property', 'unique' => false, 'null' => false)
          )
    , 'decmean' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'decpurpose' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'decpopu' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          , 'PairID' => array ( 'concept' => 'PairID', 'unique' => false, 'null' => false)
          )
    , 'rels' =>
        array
          ( 'ExpressionID' => array ( 'concept' => 'ExpressionID', 'unique' => false, 'null' => false)
          , 'Relation' => array ( 'concept' => 'Relation', 'unique' => false, 'null' => false)
          )
    , 'rrmean' =>
        array
          ( 'Rule' => array ( 'concept' => 'Rule', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'rrpurpose' =>
        array
          ( 'Rule' => array ( 'concept' => 'Rule', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    );

$allRulesSql =
  array
    ( 'uniek path/filename' =>
        array ( 'name' => 'uniek path/filename'
              , 'ruleAdl' => 'filename;filename~/\\filepath;filepath~ |- I'
              , 'origin' => 'line 13, file "Fspec.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'File'
              // Normalization steps:
              //     -(-(filename;filename~/\\filepath;filepath~) \\/ I)
              // <=> { De Morgan }
              //     filename;filename~/\\filepath;filepath~/\\-I
              // 
              // Normalized complement (== violationsSQL): filename;filename~/\\filepath;filepath~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"filename;filename~\",\"filepath;filepath~\",\"-I\"] */
                          SELECT DISTINCT isect0.`File` AS src, isect0.`File1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"filename\",\"filename~\"] */
                                 
                                 SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                 FROM `File` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `filename`
                                        FROM `File`
                                        WHERE `File` IS NOT NULL AND `filename` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`filename`=ECps1.`filename`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"filepath\",\"filepath~\"] */
                                 
                                 SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                 FROM `File` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `filepath`
                                        FROM `File`
                                        WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`filepath`=ECps1.`filepath`
                               ) AS isect1
                          WHERE (isect0.`File` = isect1.`File` AND isect0.`File1` = isect1.`File1`) AND isect0.`File` <> isect0.`File1` AND isect0.`File` IS NOT NULL AND isect0.`File1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key gen' =>
        array ( 'name' => 'key gen'
              , 'ruleAdl' => 'gengen;gengen~/\\genspc;genspc~ |- I'
              , 'origin' => 'line 96, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Gen'
              , 'tgtConcept' => 'Gen'
              // Normalization steps:
              //     -(-(gengen;gengen~/\\genspc;genspc~) \\/ I)
              // <=> { De Morgan }
              //     gengen;gengen~/\\genspc;genspc~/\\-I
              // 
              // Normalized complement (== violationsSQL): gengen;gengen~/\\genspc;genspc~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"gengen;gengen~\",\"genspc;genspc~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Gen` AS src, isect0.`Gen1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"gengen\",\"gengen~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Gen`, ECps1.`Gen` AS `Gen1`
                                 FROM `Gen` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Gen`, `gengen`
                                        FROM `Gen`
                                        WHERE `Gen` IS NOT NULL AND `gengen` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`gengen`=ECps1.`gengen`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"genspc\",\"genspc~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Gen`, ECps1.`Gen` AS `Gen1`
                                 FROM `Gen` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Gen`, `genspc`
                                        FROM `Gen`
                                        WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`genspc`=ECps1.`genspc`
                               ) AS isect1
                          WHERE (isect0.`Gen` = isect1.`Gen` AND isect0.`Gen1` = isect1.`Gen1`) AND isect0.`Gen` <> isect0.`Gen1` AND isect0.`Gen` IS NOT NULL AND isect0.`Gen1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key pair' =>
        array ( 'name' => 'key pair'
              , 'ruleAdl' => 'left;left~/\\right;right~ |- I'
              , 'origin' => 'line 161, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Pair'
              , 'tgtConcept' => 'Pair'
              // Normalization steps:
              //     -(-(left;left~/\\right;right~) \\/ I)
              // <=> { De Morgan }
              //     left;left~/\\right;right~/\\-I
              // 
              // Normalized complement (== violationsSQL): left;left~/\\right;right~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"left;left~\",\"right;right~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Pair` AS src, isect0.`Pair1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"left\",\"left~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Pair`, ECps1.`Pair` AS `Pair1`
                                 FROM `Pair` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Pair`, `left`
                                        FROM `Pair`
                                        WHERE `Pair` IS NOT NULL AND `left` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`left`=ECps1.`left`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"right\",\"right~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Pair`, ECps1.`Pair` AS `Pair1`
                                 FROM `Pair` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Pair`, `right`
                                        FROM `Pair`
                                        WHERE `Pair` IS NOT NULL AND `right` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`right`=ECps1.`right`
                               ) AS isect1
                          WHERE (isect0.`Pair` = isect1.`Pair` AND isect0.`Pair1` = isect1.`Pair1`) AND isect0.`Pair` <> isect0.`Pair1` AND isect0.`Pair` IS NOT NULL AND isect0.`Pair1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key decl' =>
        array ( 'name' => 'key decl'
              , 'ruleAdl' => 'decnm;decnm~/\\decsgn;src;(decsgn;src)~/\\decsgn;trg;(decsgn;trg)~ |- I'
              , 'origin' => 'line 205, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalization steps:
              //     -(-(decnm;decnm~/\\decsgn;src;(decsgn;src)~/\\decsgn;trg;(decsgn;trg)~) \\/ I)
              // <=> { De Morgan }
              //     decnm;decnm~/\\decsgn;src;(decsgn;src)~/\\decsgn;trg;(decsgn;trg)~/\\-I
              // 
              // Normalized complement (== violationsSQL): decnm;decnm~/\\decsgn;src;(decsgn;src)~/\\decsgn;trg;(decsgn;trg)~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decnm;decnm~\",\"decsgn;src;(decsgn;src)~\",\"decsgn;trg;(decsgn;trg)~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`Declaration1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decnm\",\"decnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps1.`Declaration` AS `Declaration1`
                                 FROM `Declaration` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decnm`
                                        FROM `Declaration`
                                        WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`decnm`=ECps1.`decnm`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"src\",\"(decsgn;src)~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps2.`Declaration` AS `Declaration1`
                                 FROM `Declaration` AS ECps0,
                                      `Sign` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        /* case: (ECps es), with two or more elements in es.
                                           ECps [\"decsgn\",\"src\"] */
                                        
                                        SELECT DISTINCT ECps0.`Declaration`, ECps1.`src`
                                        FROM `Declaration` AS ECps0,
                                             `Sign` AS ECps1
                                        WHERE ECps0.`decsgn`=ECps1.`Sign`
                                      ) AS ECps2
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`
                                   AND ECps1.`src`=ECps2.`src`
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"trg\",\"(decsgn;trg)~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps2.`Declaration` AS `Declaration1`
                                 FROM `Declaration` AS ECps0,
                                      `Sign` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        /* case: (ECps es), with two or more elements in es.
                                           ECps [\"decsgn\",\"trg\"] */
                                        
                                        SELECT DISTINCT ECps0.`Declaration`, ECps1.`trg`
                                        FROM `Declaration` AS ECps0,
                                             `Sign` AS ECps1
                                        WHERE ECps0.`decsgn`=ECps1.`Sign`
                                      ) AS ECps2
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`
                                   AND ECps1.`trg`=ECps2.`trg`
                               ) AS isect2
                          WHERE (isect0.`Declaration` = isect1.`Declaration` AND isect0.`Declaration1` = isect1.`Declaration1`) AND (isect0.`Declaration` = isect2.`Declaration` AND isect0.`Declaration1` = isect2.`Declaration1`) AND isect0.`Declaration` <> isect0.`Declaration1` AND isect0.`Declaration` IS NOT NULL AND isect0.`Declaration1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'property enum' =>
        array ( 'name' => 'property enum'
              , 'ruleAdl' => 'I[Property] |- \'->\' \\/ \'UNI\' \\/ \'TOT\' \\/ \'INJ\' \\/ \'SUR\' \\/ \'RFX\' \\/ \'IRF\' \\/ \'SYM\' \\/ \'ASY\' \\/ \'TRN\' \\/ \'PROP\''
              , 'origin' => 'line 218, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Property'
              , 'tgtConcept' => 'Property'
              // Normalization steps:
              //     -(-I[Property] \\/ \'->\' \\/ \'UNI\' \\/ \'TOT\' \\/ \'INJ\' \\/ \'SUR\' \\/ \'RFX\' \\/ \'IRF\' \\/ \'SYM\' \\/ \'ASY\' \\/ \'TRN\' \\/ \'PROP\')
              // <=> { De Morgan }
              //     I[Property]/\\-\'->\'/\\-\'UNI\'/\\-\'TOT\'/\\-\'INJ\'/\\-\'SUR\'/\\-\'RFX\'/\\-\'IRF\'/\\-\'SYM\'/\\-\'ASY\'/\\-\'TRN\'/\\-\'PROP\'
              // 
              // Normalized complement (== violationsSQL): I[Property]/\\-\'->\'/\\-\'UNI\'/\\-\'TOT\'/\\-\'INJ\'/\\-\'SUR\'/\\-\'RFX\'/\\-\'IRF\'/\\-\'SYM\'/\\-\'ASY\'/\\-\'TRN\'/\\-\'PROP\'
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Property]\",\"-\'->\'\",\"-\'UNI\'\",\"-\'TOT\'\",\"-\'INJ\'\",\"-\'SUR\'\",\"-\'RFX\'\",\"-\'IRF\'\",\"-\'SYM\'\",\"-\'ASY\'\",\"-\'TRN\'\",\"-\'PROP\'\"] */
                          SELECT DISTINCT isect0.`Property` AS src, isect0.`Property1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Property`, `Property` AS `Property1`
                                 FROM `Property`
                                 WHERE `Property` IS NOT NULL AND `Property` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT \'->\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'UNI\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'TOT\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'INJ\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'SUR\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'RFX\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'IRF\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'SYM\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'ASY\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'TRN\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'PROP\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND isect0.`Property` IS NOT NULL AND isect0.`Property1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'typed domain' =>
        array ( 'name' => 'typed domain'
              , 'ruleAdl' => 'decpopu;pairvalue;left;cptos~ |- decsgn;src \\/ decsgn;src;(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~'
              , 'origin' => 'line 232, file "AST.adl"'
              , 'meaning' => 'The type of the elements in the domain of a declaration is the source of that relation.'
              , 'message' => 'Het linkeratoom van een paar dat u aan de populatie wil toevoegen is niet van het juiste type (zie source). TIP: type de naam van het gewenste type in \'links\', zodat u een beperktere keuzelijst krijgt. Als u een atoom van een generieker type wil gebruiken, dan zal u dat atoom specifieker moeten typeren. Een atoom kunt u typeren als een concept door het toe te voegen aan de populatie van dat concept.'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Concept'
              // Normalization steps:
              //     -(-(decpopu;pairvalue;left;cptos~) \\/ decsgn;src \\/ decsgn;src;(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~)
              // <=> { De Morgan }
              //     decpopu;pairvalue;left;cptos~/\\-(decsgn;src)/\\-(decsgn;src;(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~)
              // 
              // Normalized complement (== violationsSQL): decpopu;pairvalue;left;cptos~/\\-(decsgn;src)/\\-(decsgn;src;(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decpopu;pairvalue;left;cptos~\",\"-(decsgn;src)\",\"-(decsgn;src;(genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~)\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`cptos` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decpopu\",\"pairvalue\",\"left\",\"cptos~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps3.`cptos`
                                 FROM `decpopu` AS ECps0,
                                      `PairID` AS ECps1,
                                      `Pair` AS ECps2,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptos`, `AtomID`
                                        FROM `AtomID`
                                        WHERE `cptos` IS NOT NULL AND `AtomID` IS NOT NULL
                                      ) AS ECps3
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                                   AND ECps1.`pairvalue`=ECps2.`Pair`
                                   AND ECps2.`left`=ECps3.`AtomID`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decsgn\",\"src\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps1.`src`
                                             FROM `Declaration` AS ECps0,
                                                  `Sign` AS ECps1
                                             WHERE ECps0.`decsgn`=ECps1.`Sign`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`cptos`=cp.`src`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decsgn\",\"src\",\"(genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps2.`genspc`
                                             FROM `Declaration` AS ECps0,
                                                  `Sign` AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    /* case: EUni es
                                                       EUni [\"genspc~;gengen\",\"genspc~;gengen;genspc~;gengen\",\"genspc~;gengen;genspc~;gengen;genspc~;gengen\"] */
                                                    (/* case: (ECps es), with two or more elements in es.
                                                           ECps [\"genspc~\",\"gengen\"] */
                                                        
                                                        SELECT DISTINCT ECps0.`genspc`, ECps1.`gengen`
                                                        FROM 
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps0,
                                                             `Gen` AS ECps1
                                                        WHERE ECps0.`Gen`=ECps1.`Gen`
                                                    ) UNION (/* case: (ECps es), with two or more elements in es.
                                                           ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                        
                                                        SELECT DISTINCT ECps0.`genspc`, ECps3.`gengen`
                                                        FROM 
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps0,
                                                             `Gen` AS ECps1,
                                                             
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps2,
                                                             `Gen` AS ECps3
                                                        WHERE ECps0.`Gen`=ECps1.`Gen`
                                                          AND ECps1.`gengen`=ECps2.`genspc`
                                                          AND ECps2.`Gen`=ECps3.`Gen`
                                                    ) UNION (/* case: (ECps es), with two or more elements in es.
                                                           ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                        
                                                        SELECT DISTINCT ECps0.`genspc`, ECps5.`gengen`
                                                        FROM 
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps0,
                                                             `Gen` AS ECps1,
                                                             
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps2,
                                                             `Gen` AS ECps3,
                                                             
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps4,
                                                             `Gen` AS ECps5
                                                        WHERE ECps0.`Gen`=ECps1.`Gen`
                                                          AND ECps1.`gengen`=ECps2.`genspc`
                                                          AND ECps2.`Gen`=ECps3.`Gen`
                                                          AND ECps3.`gengen`=ECps4.`genspc`
                                                          AND ECps4.`Gen`=ECps5.`Gen`
                                                    
                                                    
                                                    )
                                                  ) AS ECps2
                                             WHERE ECps0.`decsgn`=ECps1.`Sign`
                                               AND ECps1.`src`=ECps2.`gengen`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`cptos`=cp.`genspc`) AND isect0.`Declaration` IS NOT NULL AND isect0.`cptos` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'typed codomain' =>
        array ( 'name' => 'typed codomain'
              , 'ruleAdl' => 'decpopu;pairvalue;right;cptos~ |- decsgn;trg \\/ decsgn;trg;(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~'
              , 'origin' => 'line 236, file "AST.adl"'
              , 'meaning' => 'The type of the elements in the codomain of a declaration is the target of that relation or a more specific concept of that target.'
              , 'message' => 'Het rechteratoom van een paar dat u aan de populatie wil toevoegen is niet van het juiste type (zie target). TIP: type de naam van het gewenste type in \'rechts\', zodat u een beperktere keuzelijst krijgt. Als u een atoom van een generieker type wil gebruiken, dan zal u dat atoom specifieker moeten typeren. Een atoom kunt u typeren als een concept door het toe te voegen aan de populatie van dat concept.'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Concept'
              // Normalization steps:
              //     -(-(decpopu;pairvalue;right;cptos~) \\/ decsgn;trg \\/ decsgn;trg;(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~)
              // <=> { De Morgan }
              //     decpopu;pairvalue;right;cptos~/\\-(decsgn;trg)/\\-(decsgn;trg;(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~)
              // 
              // Normalized complement (== violationsSQL): decpopu;pairvalue;right;cptos~/\\-(decsgn;trg)/\\-(decsgn;trg;(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decpopu;pairvalue;right;cptos~\",\"-(decsgn;trg)\",\"-(decsgn;trg;(genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~)\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`cptos` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decpopu\",\"pairvalue\",\"right\",\"cptos~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps3.`cptos`
                                 FROM `decpopu` AS ECps0,
                                      `PairID` AS ECps1,
                                      `Pair` AS ECps2,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptos`, `AtomID`
                                        FROM `AtomID`
                                        WHERE `cptos` IS NOT NULL AND `AtomID` IS NOT NULL
                                      ) AS ECps3
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                                   AND ECps1.`pairvalue`=ECps2.`Pair`
                                   AND ECps2.`right`=ECps3.`AtomID`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decsgn\",\"trg\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps1.`trg`
                                             FROM `Declaration` AS ECps0,
                                                  `Sign` AS ECps1
                                             WHERE ECps0.`decsgn`=ECps1.`Sign`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`cptos`=cp.`trg`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decsgn\",\"trg\",\"(genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps2.`genspc`
                                             FROM `Declaration` AS ECps0,
                                                  `Sign` AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    /* case: EUni es
                                                       EUni [\"genspc~;gengen\",\"genspc~;gengen;genspc~;gengen\",\"genspc~;gengen;genspc~;gengen;genspc~;gengen\"] */
                                                    (/* case: (ECps es), with two or more elements in es.
                                                           ECps [\"genspc~\",\"gengen\"] */
                                                        
                                                        SELECT DISTINCT ECps0.`genspc`, ECps1.`gengen`
                                                        FROM 
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps0,
                                                             `Gen` AS ECps1
                                                        WHERE ECps0.`Gen`=ECps1.`Gen`
                                                    ) UNION (/* case: (ECps es), with two or more elements in es.
                                                           ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                        
                                                        SELECT DISTINCT ECps0.`genspc`, ECps3.`gengen`
                                                        FROM 
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps0,
                                                             `Gen` AS ECps1,
                                                             
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps2,
                                                             `Gen` AS ECps3
                                                        WHERE ECps0.`Gen`=ECps1.`Gen`
                                                          AND ECps1.`gengen`=ECps2.`genspc`
                                                          AND ECps2.`Gen`=ECps3.`Gen`
                                                    ) UNION (/* case: (ECps es), with two or more elements in es.
                                                           ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                        
                                                        SELECT DISTINCT ECps0.`genspc`, ECps5.`gengen`
                                                        FROM 
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps0,
                                                             `Gen` AS ECps1,
                                                             
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps2,
                                                             `Gen` AS ECps3,
                                                             
                                                             ( /* case: EFlp x. */
                                                               SELECT DISTINCT `Gen`, `genspc`
                                                               FROM `Gen`
                                                               WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                             ) AS ECps4,
                                                             `Gen` AS ECps5
                                                        WHERE ECps0.`Gen`=ECps1.`Gen`
                                                          AND ECps1.`gengen`=ECps2.`genspc`
                                                          AND ECps2.`Gen`=ECps3.`Gen`
                                                          AND ECps3.`gengen`=ECps4.`genspc`
                                                          AND ECps4.`Gen`=ECps5.`Gen`
                                                    
                                                    
                                                    )
                                                  ) AS ECps2
                                             WHERE ECps0.`decsgn`=ECps1.`Sign`
                                               AND ECps1.`trg`=ECps2.`gengen`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`cptos`=cp.`genspc`) AND isect0.`Declaration` IS NOT NULL AND isect0.`cptos` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'rel name is decl name' =>
        array ( 'name' => 'rel name is decl name'
              , 'ruleAdl' => 'relnm = reldcl;decnm'
              , 'origin' => 'line 297, file "AST.adl"'
              , 'meaning' => 'the unqualified names of a relation and its declaration are the same.'
              , 'message' => ''
              , 'srcConcept' => 'Relation'
              , 'tgtConcept' => 'Varid'
              // Normalization steps:
              //     -((-relnm \\/ reldcl;decnm)/\\(-(reldcl;decnm) \\/ relnm))
              // <=> { De Morgan }
              //     -(-relnm \\/ reldcl;decnm) \\/ -(-(reldcl;decnm) \\/ relnm)
              // <=> { De Morgan and De Morgan }
              //     (relnm/\\-(reldcl;decnm)) \\/ (reldcl;decnm/\\-relnm)
              // <=> { Distribute:    (x/\\y)\\/z  <=>  x\\/z /\\ y\\/z }
              //     (relnm \\/ reldcl;decnm)/\\(relnm \\/ -relnm)/\\(-(reldcl;decnm) \\/ reldcl;decnm)/\\(-(reldcl;decnm) \\/ -relnm)
              // <=> { let relnm = e. Since -e\\/e = V we get and let reldcl;decnm = e. Since -e\\/e = V we get }
              //     (relnm \\/ reldcl;decnm)/\\(-(reldcl;decnm) \\/ -relnm)
              // 
              // Normalized complement (== violationsSQL): (relnm \\/ reldcl;decnm)/\\(-(reldcl;decnm) \\/ -relnm)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"relnm \\\\/ reldcl;decnm\",\"-(reldcl;decnm) \\\\/ -relnm\"] */
                          SELECT DISTINCT isect0.`Relation` AS src, isect0.`relnm` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"relnm\",\"reldcl;decnm\"] */
                                 (SELECT DISTINCT `Relation`, `relnm`
                                     FROM `Relation`
                                     WHERE `Relation` IS NOT NULL AND `relnm` IS NOT NULL
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"reldcl\",\"decnm\"] */
                                     
                                     SELECT DISTINCT ECps0.`Relation`, ECps1.`decnm` AS `relnm`
                                     FROM `Relation` AS ECps0,
                                          `Declaration` AS ECps1
                                     WHERE ECps0.`reldcl`=ECps1.`Declaration`
                                 
                                 )
                               ) AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-(reldcl;decnm)\",\"-relnm\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"reldcl;decnm\" ] */
                                     SELECT DISTINCT cfst.`Relation`, csnd.`Varid` AS `decnm`
                                     FROM `Relation` AS cfst,
                                          `Varid` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"reldcl\",\"decnm\"] */
                                              
                                              SELECT DISTINCT ECps0.`Relation`, ECps1.`decnm`
                                              FROM `Relation` AS ECps0,
                                                   `Declaration` AS ECps1
                                              WHERE ECps0.`reldcl`=ECps1.`Declaration`
                                            ) AS cp
                                       WHERE cfst.`Relation`=cp.`Relation` AND csnd.`Varid`=cp.`decnm`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"relnm\" ] */
                                     SELECT DISTINCT cfst.`Relation`, csnd.`Varid` AS `decnm`
                                     FROM `Relation` AS cfst,
                                          `Varid` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `Relation` AS cp
                                       WHERE cfst.`Relation`=cp.`Relation` AND csnd.`Varid`=cp.`relnm`)
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Relation` = isect1.`Relation` AND isect0.`relnm` = isect1.`decnm`) AND isect0.`Relation` IS NOT NULL AND isect0.`relnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'conceptwijzigingen2' =>
        array ( 'name' => 'conceptwijzigingen2'
              , 'ruleAdl' => 'cptos |- inios'
              , 'origin' => 'line 16, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => 'U heeft atomen toegevoegd aan de populatie van concepten, hetgeen nog niet effectief en persistent opgeslagen is. Mogelijk heeft u overtredingen verholpen of veroorzaakt. U kunt deze atlasbewerkingen effectueren en persistent maken door ze op te slaan in een volgende versie van het bronbestand.'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'AtomID'
              // Normalization steps:
              //     -(-cptos \\/ inios)
              // <=> { De Morgan }
              //     cptos/\\-inios
              // 
              // Normalized complement (== violationsSQL): cptos/\\-inios
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptos\",\"-inios\"] */
                          SELECT DISTINCT isect0.`cptos` AS src, isect0.`AtomID` AS tgt
                          FROM `AtomID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `inios` AS cp
                                      WHERE isect0.`cptos`=cp.`Concept` AND isect0.`AtomID`=cp.`AtomID`) AND isect0.`cptos` IS NOT NULL AND isect0.`AtomID` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'relatiewijzigingen' =>
        array ( 'name' => 'relatiewijzigingen'
              , 'ruleAdl' => 'inipopu = decpopu'
              , 'origin' => 'line 18, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => 'U heeft wijzigingen gemaakt in de populatie van relaties, die nog niet effectief en persistent opgeslagen zijn. Mogelijk heeft u overtredingen verholpen of veroorzaakt. U kunt deze atlasbewerkingen effectueren en persistent maken door ze op te slaan in een volgende versie van het bronbestand.'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'PairID'
              // Normalization steps:
              //     -((-inipopu \\/ decpopu)/\\(-decpopu \\/ inipopu))
              // <=> { De Morgan }
              //     -(-inipopu \\/ decpopu) \\/ -(-decpopu \\/ inipopu)
              // <=> { De Morgan and De Morgan }
              //     (inipopu/\\-decpopu) \\/ (decpopu/\\-inipopu)
              // <=> { Distribute:    (x/\\y)\\/z  <=>  x\\/z /\\ y\\/z }
              //     (inipopu \\/ decpopu)/\\(inipopu \\/ -inipopu)/\\(-decpopu \\/ decpopu)/\\(-decpopu \\/ -inipopu)
              // <=> { let inipopu = e. Since -e\\/e = V we get and let decpopu = e. Since -e\\/e = V we get }
              //     (inipopu \\/ decpopu)/\\(-decpopu \\/ -inipopu)
              // 
              // Normalized complement (== violationsSQL): (inipopu \\/ decpopu)/\\(-decpopu \\/ -inipopu)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"inipopu \\\\/ decpopu\",\"-decpopu \\\\/ -inipopu\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`PairID` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"inipopu\",\"decpopu\"] */
                                 (SELECT DISTINCT `Declaration`, `PairID`
                                     FROM `inipopu`
                                     WHERE `Declaration` IS NOT NULL AND `PairID` IS NOT NULL
                                 ) UNION (SELECT DISTINCT `Declaration`, `PairID`
                                     FROM `decpopu`
                                     WHERE `Declaration` IS NOT NULL AND `PairID` IS NOT NULL
                                 
                                 )
                               ) AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-decpopu\",\"-inipopu\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"decpopu\" ] */
                                     SELECT DISTINCT cfst.`Declaration`, csnd.`PairID`
                                     FROM `Declaration` AS cfst,
                                          `PairID` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `decpopu` AS cp
                                       WHERE cfst.`Declaration`=cp.`Declaration` AND csnd.`PairID`=cp.`PairID`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"inipopu\" ] */
                                     SELECT DISTINCT cfst.`Declaration`, csnd.`PairID`
                                     FROM `Declaration` AS cfst,
                                          `PairID` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `inipopu` AS cp
                                       WHERE cfst.`Declaration`=cp.`Declaration` AND csnd.`PairID`=cp.`PairID`)
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Declaration` = isect1.`Declaration` AND isect0.`PairID` = isect1.`PairID`) AND isect0.`Declaration` IS NOT NULL AND isect0.`PairID` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'parseoftypefout' =>
        array ( 'name' => 'parseoftypefout'
              , 'ruleAdl' => 'compilererror |- -compilererror'
              , 'origin' => 'line 20, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => 'Het bronbestand veroorzaakt een parse- of typefout (zie rechterlid). Er is daarom geen context in de Atlas geladen. Klik op de bestandsnaam (zie linkerlid) om het bronbestand te openen en eventueel te verbeteren.'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'ErrorMessage'
              // Normalization steps:
              //     -(-compilererror \\/ -compilererror)
              // <=> { De Morgan }
              //     compilererror/\\compilererror
              // <=> { compilererror/\\compilererror = compilererror }
              //     compilererror
              // 
              // Normalized complement (== violationsSQL): compilererror
              , 'violationsSQL' => 'SELECT DISTINCT `File` AS src, `compilererror` AS tgt
                          FROM `File`
                          WHERE `File` IS NOT NULL AND `compilererror` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'specgenatoom' =>
        array ( 'name' => 'specgenatoom'
              , 'ruleAdl' => '-(cptos;atomvalue/\\(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~;cptos;atomvalue)'
              , 'origin' => 'line 17, file "student_AST_interfaces.adl"'
              , 'meaning' => ''
              , 'message' => 'Voor een atoom met een specifiek type bestaat er een gelijkend doch ander atoom met een generiek type. Deze atomen zullen pas identiek worden nadat u de atlasbewerkingen heeft ge-effectueerd door de wijzigingen in een volgende versie op te slaan en te laden. Verifiren? Ga naar het generieke type (klik op linkerlid) en zie dat de atoomwaarde (rechterlid) voorkomt in de \'populatie\' en de \'populatie (van specifieker)\'.'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Atom'
              // Normalization steps:
              //     cptos;atomvalue/\\(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~;cptos;atomvalue
              // 
              // Normalized complement (== violationsSQL): cptos;atomvalue/\\(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~;cptos;atomvalue
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptos;atomvalue\",\"(genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~;cptos;atomvalue\"] */
                          SELECT DISTINCT isect0.`cptos` AS src, isect0.`atomvalue` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptos\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`cptos`, ECps1.`atomvalue`
                                 FROM `AtomID` AS ECps0,
                                      `AtomID` AS ECps1
                                 WHERE ECps0.`AtomID`=ECps1.`AtomID`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"(genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~\",\"cptos\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`gengen`, ECps2.`atomvalue`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        /* case: EUni es
                                           EUni [\"genspc~;gengen\",\"genspc~;gengen;genspc~;gengen\",\"genspc~;gengen;genspc~;gengen;genspc~;gengen\"] */
                                        (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"genspc~\",\"gengen\"] */
                                            
                                            SELECT DISTINCT ECps0.`genspc`, ECps1.`gengen`
                                            FROM 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `Gen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps0,
                                                 `Gen` AS ECps1
                                            WHERE ECps0.`Gen`=ECps1.`Gen`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                            
                                            SELECT DISTINCT ECps0.`genspc`, ECps3.`gengen`
                                            FROM 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `Gen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps0,
                                                 `Gen` AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `Gen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps2,
                                                 `Gen` AS ECps3
                                            WHERE ECps0.`Gen`=ECps1.`Gen`
                                              AND ECps1.`gengen`=ECps2.`genspc`
                                              AND ECps2.`Gen`=ECps3.`Gen`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                            
                                            SELECT DISTINCT ECps0.`genspc`, ECps5.`gengen`
                                            FROM 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `Gen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps0,
                                                 `Gen` AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `Gen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps2,
                                                 `Gen` AS ECps3,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `Gen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps4,
                                                 `Gen` AS ECps5
                                            WHERE ECps0.`Gen`=ECps1.`Gen`
                                              AND ECps1.`gengen`=ECps2.`genspc`
                                              AND ECps2.`Gen`=ECps3.`Gen`
                                              AND ECps3.`gengen`=ECps4.`genspc`
                                              AND ECps4.`Gen`=ECps5.`Gen`
                                        
                                        
                                        )
                                      ) AS ECps0,
                                      `AtomID` AS ECps1,
                                      `AtomID` AS ECps2
                                 WHERE ECps0.`genspc`=ECps1.`cptos`
                                   AND ECps1.`AtomID`=ECps2.`AtomID`
                               ) AS isect1
                          WHERE (isect0.`cptos` = isect1.`gengen` AND isect0.`atomvalue` = isect1.`atomvalue`) AND isect0.`cptos` IS NOT NULL AND isect0.`atomvalue` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'overtredingen' =>
        array ( 'name' => 'overtredingen'
              , 'ruleAdl' => 'rrviols |- -rrviols'
              , 'origin' => 'line 19, file "student_AST_interfaces.adl"'
              , 'meaning' => ''
              , 'message' => 'Er worden regels overtreden.'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Violation'
              // Normalization steps:
              //     -(-rrviols \\/ -rrviols)
              // <=> { De Morgan }
              //     rrviols/\\rrviols
              // <=> { rrviols/\\rrviols = rrviols }
              //     rrviols
              // 
              // Normalized complement (== violationsSQL): rrviols
              , 'violationsSQL' => 'SELECT DISTINCT `Rule` AS src, `Violation` AS tgt
                          FROM `rrviols`
                          WHERE `Rule` IS NOT NULL AND `Violation` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'dummy' =>
        array ( 'name' => 'dummy'
              , 'ruleAdl' => 'ctxnm |- ctxnm'
              , 'origin' => 'line 7, file "admin_interfaces.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Conid'
              // Normalization steps:
              //     -(-ctxnm \\/ ctxnm)
              // <=> { De Morgan }
              //     ctxnm/\\-ctxnm
              // <=> { ctxnm/\\-ctxnm = V- }
              //     -V
              // 
              // Normalized complement (== violationsSQL): -V
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compilererror' =>
        array ( 'name' => 'uni compilererror'
              , 'ruleAdl' => 'compilererror~;compilererror |- I'
              , 'origin' => 'line 28, file "rap.adl"'
              , 'meaning' => 'compilererror[File\\*ErrorMessage] is univalent'
              , 'message' => 'compilererror[File\\*ErrorMessage] is niet univalent'
              , 'srcConcept' => 'ErrorMessage'
              , 'tgtConcept' => 'ErrorMessage'
              // Normalization steps:
              //     -(-(compilererror~;compilererror) \\/ I)
              // <=> { De Morgan }
              //     compilererror~;compilererror/\\-I
              // 
              // Normalized complement (== violationsSQL): compilererror~;compilererror/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compilererror~;compilererror\",\"-I\"] */
                          SELECT DISTINCT isect0.`compilererror` AS src, isect0.`compilererror1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compilererror~\",\"compilererror\"] */
                                 
                                 SELECT DISTINCT ECps0.`compilererror`, ECps1.`compilererror` AS `compilererror1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `compilererror`
                                        FROM `File`
                                        WHERE `File` IS NOT NULL AND `compilererror` IS NOT NULL
                                      ) AS ECps0,
                                      `File` AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`compilererror` <> isect0.`compilererror1` AND isect0.`compilererror` IS NOT NULL AND isect0.`compilererror1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni filename' =>
        array ( 'name' => 'uni filename'
              , 'ruleAdl' => 'filename~;filename |- I'
              , 'origin' => 'line 10, file "Fspec.adl"'
              , 'meaning' => 'filename[File\\*FileName] is univalent'
              , 'message' => 'filename[File\\*FileName] is niet univalent'
              , 'srcConcept' => 'FileName'
              , 'tgtConcept' => 'FileName'
              // Normalization steps:
              //     -(-(filename~;filename) \\/ I)
              // <=> { De Morgan }
              //     filename~;filename/\\-I
              // 
              // Normalized complement (== violationsSQL): filename~;filename/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"filename~;filename\",\"-I\"] */
                          SELECT DISTINCT isect0.`filename` AS src, isect0.`filename1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"filename~\",\"filename\"] */
                                 
                                 SELECT DISTINCT ECps0.`filename`, ECps1.`filename` AS `filename1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `filename`
                                        FROM `File`
                                        WHERE `File` IS NOT NULL AND `filename` IS NOT NULL
                                      ) AS ECps0,
                                      `File` AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`filename` <> isect0.`filename1` AND isect0.`filename` IS NOT NULL AND isect0.`filename1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot filename' =>
        array ( 'name' => 'tot filename'
              , 'ruleAdl' => 'I |- filename;filename~'
              , 'origin' => 'line 10, file "Fspec.adl"'
              , 'meaning' => 'filename[File\\*FileName] is totaal'
              , 'message' => 'filename[File\\*FileName] is niet totaal'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'File'
              // Normalization steps:
              //     -(-I \\/ filename;filename~)
              // <=> { De Morgan }
              //     I/\\-(filename;filename~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(filename;filename~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(filename;filename~)\"] */
                          SELECT DISTINCT isect0.`File` AS src, isect0.`File` AS tgt
                          FROM `File` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"filename\",\"filename~\"] */
                                             
                                             SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                             FROM `File` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `File`, `filename`
                                                    FROM `File`
                                                    WHERE `File` IS NOT NULL AND `filename` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`filename`=ECps1.`filename`
                                           ) AS cp
                                      WHERE isect0.`File`=cp.`File` AND isect0.`File`=cp.`File1`) AND isect0.`File` IS NOT NULL AND isect0.`File` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni filepath' =>
        array ( 'name' => 'uni filepath'
              , 'ruleAdl' => 'filepath~;filepath |- I'
              , 'origin' => 'line 11, file "Fspec.adl"'
              , 'meaning' => 'filepath[File\\*FilePath] is univalent'
              , 'message' => 'filepath[File\\*FilePath] is niet univalent'
              , 'srcConcept' => 'FilePath'
              , 'tgtConcept' => 'FilePath'
              // Normalization steps:
              //     -(-(filepath~;filepath) \\/ I)
              // <=> { De Morgan }
              //     filepath~;filepath/\\-I
              // 
              // Normalized complement (== violationsSQL): filepath~;filepath/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"filepath~;filepath\",\"-I\"] */
                          SELECT DISTINCT isect0.`filepath` AS src, isect0.`filepath1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"filepath~\",\"filepath\"] */
                                 
                                 SELECT DISTINCT ECps0.`filepath`, ECps1.`filepath` AS `filepath1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `filepath`
                                        FROM `File`
                                        WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL
                                      ) AS ECps0,
                                      `File` AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`filepath` <> isect0.`filepath1` AND isect0.`filepath` IS NOT NULL AND isect0.`filepath1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni sourcefile' =>
        array ( 'name' => 'uni sourcefile'
              , 'ruleAdl' => 'sourcefile~;sourcefile |- I'
              , 'origin' => 'line 20, file "Fspec.adl"'
              , 'meaning' => 'sourcefile[Context\\*AdlFile] is univalent'
              , 'message' => 'sourcefile[Context\\*AdlFile] is niet univalent'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalization steps:
              //     -(-(sourcefile~;sourcefile) \\/ I)
              // <=> { De Morgan }
              //     sourcefile~;sourcefile/\\-I
              // 
              // Normalized complement (== violationsSQL): sourcefile~;sourcefile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"sourcefile~;sourcefile\",\"-I\"] */
                          SELECT DISTINCT isect0.`sourcefile` AS src, isect0.`sourcefile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"sourcefile~\",\"sourcefile\"] */
                                 
                                 SELECT DISTINCT ECps0.`sourcefile`, ECps1.`sourcefile` AS `sourcefile1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `sourcefile`
                                        FROM `Conid`
                                        WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`sourcefile` <> isect0.`sourcefile1` AND isect0.`sourcefile` IS NOT NULL AND isect0.`sourcefile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot sourcefile' =>
        array ( 'name' => 'tot sourcefile'
              , 'ruleAdl' => 'I |- sourcefile;sourcefile~'
              , 'origin' => 'line 20, file "Fspec.adl"'
              , 'meaning' => 'sourcefile[Context\\*AdlFile] is totaal'
              , 'message' => 'sourcefile[Context\\*AdlFile] is niet totaal'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalization steps:
              //     -(-I \\/ sourcefile;sourcefile~)
              // <=> { De Morgan }
              //     I/\\-(sourcefile;sourcefile~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(sourcefile;sourcefile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(sourcefile;sourcefile~)\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm` AS tgt
                          FROM `Conid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"sourcefile\",\"sourcefile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                             FROM `Conid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ctxnm`, `sourcefile`
                                                    FROM `Conid`
                                                    WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`sourcefile`=ECps1.`sourcefile`
                                           ) AS cp
                                      WHERE isect0.`ctxnm`=cp.`ctxnm` AND isect0.`ctxnm`=cp.`ctxnm1`) AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni applyto' =>
        array ( 'name' => 'uni applyto'
              , 'ruleAdl' => 'applyto~;applyto |- I'
              , 'origin' => 'line 23, file "Fspec.adl"'
              , 'meaning' => 'applyto[G\\*AdlFile] is univalent'
              , 'message' => 'applyto[G\\*AdlFile] is niet univalent'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalization steps:
              //     -(-(applyto~;applyto) \\/ I)
              // <=> { De Morgan }
              //     applyto~;applyto/\\-I
              // 
              // Normalized complement (== violationsSQL): applyto~;applyto/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"applyto~;applyto\",\"-I\"] */
                          SELECT DISTINCT isect0.`applyto` AS src, isect0.`applyto1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"applyto~\",\"applyto\"] */
                                 
                                 SELECT DISTINCT ECps0.`applyto`, ECps1.`applyto` AS `applyto1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `G`, `applyto`
                                        FROM `G`
                                        WHERE `G` IS NOT NULL AND `applyto` IS NOT NULL
                                      ) AS ECps0,
                                      `G` AS ECps1
                                 WHERE ECps0.`G`=ECps1.`G`
                               ) AS isect0
                          WHERE isect0.`applyto` <> isect0.`applyto1` AND isect0.`applyto` IS NOT NULL AND isect0.`applyto1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot applyto' =>
        array ( 'name' => 'tot applyto'
              , 'ruleAdl' => 'I |- applyto;applyto~'
              , 'origin' => 'line 23, file "Fspec.adl"'
              , 'meaning' => 'applyto[G\\*AdlFile] is totaal'
              , 'message' => 'applyto[G\\*AdlFile] is niet totaal'
              , 'srcConcept' => 'G'
              , 'tgtConcept' => 'G'
              // Normalization steps:
              //     -(-I \\/ applyto;applyto~)
              // <=> { De Morgan }
              //     I/\\-(applyto;applyto~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(applyto;applyto~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(applyto;applyto~)\"] */
                          SELECT DISTINCT isect0.`G` AS src, isect0.`G` AS tgt
                          FROM `G` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"applyto\",\"applyto~\"] */
                                             
                                             SELECT DISTINCT ECps0.`G`, ECps1.`G` AS `G1`
                                             FROM `G` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `G`, `applyto`
                                                    FROM `G`
                                                    WHERE `G` IS NOT NULL AND `applyto` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`applyto`=ECps1.`applyto`
                                           ) AS cp
                                      WHERE isect0.`G`=cp.`G` AND isect0.`G`=cp.`G1`) AND isect0.`G` IS NOT NULL AND isect0.`G` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni functionname' =>
        array ( 'name' => 'uni functionname'
              , 'ruleAdl' => 'functionname~;functionname |- I'
              , 'origin' => 'line 25, file "Fspec.adl"'
              , 'meaning' => 'functionname[G\\*String] is univalent'
              , 'message' => 'functionname[G\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalization steps:
              //     -(-(functionname~;functionname) \\/ I)
              // <=> { De Morgan }
              //     functionname~;functionname/\\-I
              // 
              // Normalized complement (== violationsSQL): functionname~;functionname/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"functionname~;functionname\",\"-I\"] */
                          SELECT DISTINCT isect0.`functionname` AS src, isect0.`functionname1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"functionname~\",\"functionname\"] */
                                 
                                 SELECT DISTINCT ECps0.`functionname`, ECps1.`functionname` AS `functionname1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `G`, `functionname`
                                        FROM `G`
                                        WHERE `G` IS NOT NULL AND `functionname` IS NOT NULL
                                      ) AS ECps0,
                                      `G` AS ECps1
                                 WHERE ECps0.`G`=ECps1.`G`
                               ) AS isect0
                          WHERE isect0.`functionname` <> isect0.`functionname1` AND isect0.`functionname` IS NOT NULL AND isect0.`functionname1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot functionname' =>
        array ( 'name' => 'tot functionname'
              , 'ruleAdl' => 'I |- functionname;functionname~'
              , 'origin' => 'line 25, file "Fspec.adl"'
              , 'meaning' => 'functionname[G\\*String] is totaal'
              , 'message' => 'functionname[G\\*String] is niet totaal'
              , 'srcConcept' => 'G'
              , 'tgtConcept' => 'G'
              // Normalization steps:
              //     -(-I \\/ functionname;functionname~)
              // <=> { De Morgan }
              //     I/\\-(functionname;functionname~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(functionname;functionname~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(functionname;functionname~)\"] */
                          SELECT DISTINCT isect0.`G` AS src, isect0.`G` AS tgt
                          FROM `G` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"functionname\",\"functionname~\"] */
                                             
                                             SELECT DISTINCT ECps0.`G`, ECps1.`G` AS `G1`
                                             FROM `G` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `G`, `functionname`
                                                    FROM `G`
                                                    WHERE `G` IS NOT NULL AND `functionname` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`functionname`=ECps1.`functionname`
                                           ) AS cp
                                      WHERE isect0.`G`=cp.`G` AND isect0.`G`=cp.`G1`) AND isect0.`G` IS NOT NULL AND isect0.`G` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni operation' =>
        array ( 'name' => 'uni operation'
              , 'ruleAdl' => 'operation~;operation |- I'
              , 'origin' => 'line 26, file "Fspec.adl"'
              , 'meaning' => 'operation[G\\*Int] is univalent'
              , 'message' => 'operation[G\\*Int] is niet univalent'
              , 'srcConcept' => 'Int'
              , 'tgtConcept' => 'Int'
              // Normalization steps:
              //     -(-(operation~;operation) \\/ I)
              // <=> { De Morgan }
              //     operation~;operation/\\-I
              // 
              // Normalized complement (== violationsSQL): operation~;operation/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"operation~;operation\",\"-I\"] */
                          SELECT DISTINCT isect0.`operation` AS src, isect0.`operation1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"operation~\",\"operation\"] */
                                 
                                 SELECT DISTINCT ECps0.`operation`, ECps1.`operation` AS `operation1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `G`, `operation`
                                        FROM `G`
                                        WHERE `G` IS NOT NULL AND `operation` IS NOT NULL
                                      ) AS ECps0,
                                      `G` AS ECps1
                                 WHERE ECps0.`G`=ECps1.`G`
                               ) AS isect0
                          WHERE isect0.`operation` <> isect0.`operation1` AND isect0.`operation` IS NOT NULL AND isect0.`operation1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot operation' =>
        array ( 'name' => 'tot operation'
              , 'ruleAdl' => 'I |- operation;operation~'
              , 'origin' => 'line 26, file "Fspec.adl"'
              , 'meaning' => 'operation[G\\*Int] is totaal'
              , 'message' => 'operation[G\\*Int] is niet totaal'
              , 'srcConcept' => 'G'
              , 'tgtConcept' => 'G'
              // Normalization steps:
              //     -(-I \\/ operation;operation~)
              // <=> { De Morgan }
              //     I/\\-(operation;operation~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(operation;operation~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(operation;operation~)\"] */
                          SELECT DISTINCT isect0.`G` AS src, isect0.`G` AS tgt
                          FROM `G` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"operation\",\"operation~\"] */
                                             
                                             SELECT DISTINCT ECps0.`G`, ECps1.`G` AS `G1`
                                             FROM `G` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `G`, `operation`
                                                    FROM `G`
                                                    WHERE `G` IS NOT NULL AND `operation` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`operation`=ECps1.`operation`
                                           ) AS cp
                                      WHERE isect0.`G`=cp.`G` AND isect0.`G`=cp.`G1`) AND isect0.`G` IS NOT NULL AND isect0.`G` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni newfile' =>
        array ( 'name' => 'uni newfile'
              , 'ruleAdl' => 'newfile~;newfile |- I'
              , 'origin' => 'line 34, file "Fspec.adl"'
              , 'meaning' => 'newfile[User\\*NewAdlFile] is univalent'
              , 'message' => 'newfile[User\\*NewAdlFile] is niet univalent'
              , 'srcConcept' => 'NewAdlFile'
              , 'tgtConcept' => 'NewAdlFile'
              // Normalization steps:
              //     -(-(newfile~;newfile) \\/ I)
              // <=> { De Morgan }
              //     newfile~;newfile/\\-I
              // 
              // Normalized complement (== violationsSQL): newfile~;newfile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"newfile~;newfile\",\"-I\"] */
                          SELECT DISTINCT isect0.`newfile` AS src, isect0.`newfile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"newfile~\",\"newfile\"] */
                                 
                                 SELECT DISTINCT ECps0.`newfile`, ECps1.`newfile` AS `newfile1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `User`, `newfile`
                                        FROM `User`
                                        WHERE `User` IS NOT NULL AND `newfile` IS NOT NULL
                                      ) AS ECps0,
                                      `User` AS ECps1
                                 WHERE ECps0.`User`=ECps1.`User`
                               ) AS isect0
                          WHERE isect0.`newfile` <> isect0.`newfile1` AND isect0.`newfile` IS NOT NULL AND isect0.`newfile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot newfile' =>
        array ( 'name' => 'tot newfile'
              , 'ruleAdl' => 'I |- newfile;newfile~'
              , 'origin' => 'line 34, file "Fspec.adl"'
              , 'meaning' => 'newfile[User\\*NewAdlFile] is totaal'
              , 'message' => 'newfile[User\\*NewAdlFile] is niet totaal'
              , 'srcConcept' => 'User'
              , 'tgtConcept' => 'User'
              // Normalization steps:
              //     -(-I \\/ newfile;newfile~)
              // <=> { De Morgan }
              //     I/\\-(newfile;newfile~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(newfile;newfile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(newfile;newfile~)\"] */
                          SELECT DISTINCT isect0.`User` AS src, isect0.`User` AS tgt
                          FROM `User` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"newfile\",\"newfile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`User`, ECps1.`User` AS `User1`
                                             FROM `User` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `User`, `newfile`
                                                    FROM `User`
                                                    WHERE `User` IS NOT NULL AND `newfile` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`newfile`=ECps1.`newfile`
                                           ) AS cp
                                      WHERE isect0.`User`=cp.`User` AND isect0.`User`=cp.`User1`) AND isect0.`User` IS NOT NULL AND isect0.`User` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni savepopulation' =>
        array ( 'name' => 'uni savepopulation'
              , 'ruleAdl' => 'savepopulation~;savepopulation |- I'
              , 'origin' => 'line 40, file "Fspec.adl"'
              , 'meaning' => 'savepopulation[Context\\*SavePopFile] is univalent'
              , 'message' => 'savepopulation[Context\\*SavePopFile] is niet univalent'
              , 'srcConcept' => 'SavePopFile'
              , 'tgtConcept' => 'SavePopFile'
              // Normalization steps:
              //     -(-(savepopulation~;savepopulation) \\/ I)
              // <=> { De Morgan }
              //     savepopulation~;savepopulation/\\-I
              // 
              // Normalized complement (== violationsSQL): savepopulation~;savepopulation/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"savepopulation~;savepopulation\",\"-I\"] */
                          SELECT DISTINCT isect0.`savepopulation` AS src, isect0.`savepopulation1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"savepopulation~\",\"savepopulation\"] */
                                 
                                 SELECT DISTINCT ECps0.`savepopulation`, ECps1.`savepopulation` AS `savepopulation1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `savepopulation`
                                        FROM `Conid`
                                        WHERE `ctxnm` IS NOT NULL AND `savepopulation` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`savepopulation` <> isect0.`savepopulation1` AND isect0.`savepopulation` IS NOT NULL AND isect0.`savepopulation1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot savepopulation' =>
        array ( 'name' => 'tot savepopulation'
              , 'ruleAdl' => 'I |- savepopulation;savepopulation~'
              , 'origin' => 'line 40, file "Fspec.adl"'
              , 'meaning' => 'savepopulation[Context\\*SavePopFile] is totaal'
              , 'message' => 'savepopulation[Context\\*SavePopFile] is niet totaal'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalization steps:
              //     -(-I \\/ savepopulation;savepopulation~)
              // <=> { De Morgan }
              //     I/\\-(savepopulation;savepopulation~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(savepopulation;savepopulation~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(savepopulation;savepopulation~)\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm` AS tgt
                          FROM `Conid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"savepopulation\",\"savepopulation~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                             FROM `Conid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ctxnm`, `savepopulation`
                                                    FROM `Conid`
                                                    WHERE `ctxnm` IS NOT NULL AND `savepopulation` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`savepopulation`=ECps1.`savepopulation`
                                           ) AS cp
                                      WHERE isect0.`ctxnm`=cp.`ctxnm` AND isect0.`ctxnm`=cp.`ctxnm1`) AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni savecontext' =>
        array ( 'name' => 'uni savecontext'
              , 'ruleAdl' => 'savecontext~;savecontext |- I'
              , 'origin' => 'line 46, file "Fspec.adl"'
              , 'meaning' => 'savecontext[Context\\*SaveAdlFile] is univalent'
              , 'message' => 'savecontext[Context\\*SaveAdlFile] is niet univalent'
              , 'srcConcept' => 'SaveAdlFile'
              , 'tgtConcept' => 'SaveAdlFile'
              // Normalization steps:
              //     -(-(savecontext~;savecontext) \\/ I)
              // <=> { De Morgan }
              //     savecontext~;savecontext/\\-I
              // 
              // Normalized complement (== violationsSQL): savecontext~;savecontext/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"savecontext~;savecontext\",\"-I\"] */
                          SELECT DISTINCT isect0.`savecontext` AS src, isect0.`savecontext1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"savecontext~\",\"savecontext\"] */
                                 
                                 SELECT DISTINCT ECps0.`savecontext`, ECps1.`savecontext` AS `savecontext1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `savecontext`
                                        FROM `Conid`
                                        WHERE `ctxnm` IS NOT NULL AND `savecontext` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`savecontext` <> isect0.`savecontext1` AND isect0.`savecontext` IS NOT NULL AND isect0.`savecontext1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot savecontext' =>
        array ( 'name' => 'tot savecontext'
              , 'ruleAdl' => 'I |- savecontext;savecontext~'
              , 'origin' => 'line 46, file "Fspec.adl"'
              , 'meaning' => 'savecontext[Context\\*SaveAdlFile] is totaal'
              , 'message' => 'savecontext[Context\\*SaveAdlFile] is niet totaal'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalization steps:
              //     -(-I \\/ savecontext;savecontext~)
              // <=> { De Morgan }
              //     I/\\-(savecontext;savecontext~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(savecontext;savecontext~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(savecontext;savecontext~)\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm` AS tgt
                          FROM `Conid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"savecontext\",\"savecontext~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                             FROM `Conid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ctxnm`, `savecontext`
                                                    FROM `Conid`
                                                    WHERE `ctxnm` IS NOT NULL AND `savecontext` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`savecontext`=ECps1.`savecontext`
                                           ) AS cp
                                      WHERE isect0.`ctxnm`=cp.`ctxnm` AND isect0.`ctxnm`=cp.`ctxnm1`) AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni AdlFile' =>
        array ( 'name' => 'uni AdlFile'
              , 'ruleAdl' => 'AdlFile~;AdlFile |- I'
              , 'origin' => 'line 18, file "Fspec.adl"'
              , 'meaning' => 'AdlFile[AdlFile\\*File] is univalent'
              , 'message' => 'AdlFile[AdlFile\\*File] is niet univalent'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'File'
              // Normalization steps:
              //     -(-(AdlFile~;AdlFile) \\/ I)
              // <=> { De Morgan }
              //     AdlFile~;AdlFile/\\-I
              // 
              // Normalized complement (== violationsSQL): AdlFile~;AdlFile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"AdlFile~;AdlFile\",\"-I\"] */
                          SELECT DISTINCT isect0.`File` AS src, isect0.`File1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"AdlFile~\",\"AdlFile\"] */
                                 
                                 SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `AdlFile`, `File`
                                        FROM `File`
                                        WHERE `AdlFile` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps0,
                                      `File` AS ECps1
                                 WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                               ) AS isect0
                          WHERE isect0.`File` <> isect0.`File1` AND isect0.`File` IS NOT NULL AND isect0.`File1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot AdlFile' =>
        array ( 'name' => 'tot AdlFile'
              , 'ruleAdl' => 'I |- AdlFile;AdlFile~'
              , 'origin' => 'line 18, file "Fspec.adl"'
              , 'meaning' => 'AdlFile[AdlFile\\*File] is totaal'
              , 'message' => 'AdlFile[AdlFile\\*File] is niet totaal'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalization steps:
              //     -(-I \\/ AdlFile;AdlFile~)
              // <=> { De Morgan }
              //     I/\\-(AdlFile;AdlFile~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(AdlFile;AdlFile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(AdlFile;AdlFile~)\"] */
                          SELECT DISTINCT isect0.`AdlFile` AS src, isect0.`AdlFile` AS tgt
                          FROM `File` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"AdlFile\",\"AdlFile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`AdlFile`, ECps1.`AdlFile` AS `AdlFile1`
                                             FROM `File` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `AdlFile`, `File`
                                                    FROM `File`
                                                    WHERE `AdlFile` IS NOT NULL AND `File` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`File`=ECps1.`File`
                                           ) AS cp
                                      WHERE isect0.`AdlFile`=cp.`AdlFile` AND isect0.`AdlFile`=cp.`AdlFile1`) AND isect0.`AdlFile` IS NOT NULL AND isect0.`AdlFile` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj AdlFile' =>
        array ( 'name' => 'inj AdlFile'
              , 'ruleAdl' => 'AdlFile;AdlFile~ |- I'
              , 'origin' => 'line 18, file "Fspec.adl"'
              , 'meaning' => 'AdlFile[AdlFile\\*File] is injectief'
              , 'message' => 'AdlFile[AdlFile\\*File] is niet injectief'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalization steps:
              //     -(-(AdlFile;AdlFile~) \\/ I)
              // <=> { De Morgan }
              //     AdlFile;AdlFile~/\\-I
              // 
              // Normalized complement (== violationsSQL): AdlFile;AdlFile~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"AdlFile;AdlFile~\",\"-I\"] */
                          SELECT DISTINCT isect0.`AdlFile` AS src, isect0.`AdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"AdlFile\",\"AdlFile~\"] */
                                 
                                 SELECT DISTINCT ECps0.`AdlFile`, ECps1.`AdlFile` AS `AdlFile1`
                                 FROM `File` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `AdlFile`, `File`
                                        FROM `File`
                                        WHERE `AdlFile` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`AdlFile` <> isect0.`AdlFile1` AND isect0.`AdlFile` IS NOT NULL AND isect0.`AdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni NewAdlFile' =>
        array ( 'name' => 'uni NewAdlFile'
              , 'ruleAdl' => 'NewAdlFile~;NewAdlFile |- I'
              , 'origin' => 'line 32, file "Fspec.adl"'
              , 'meaning' => 'NewAdlFile[NewAdlFile\\*AdlFile] is univalent'
              , 'message' => 'NewAdlFile[NewAdlFile\\*AdlFile] is niet univalent'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalization steps:
              //     -(-(NewAdlFile~;NewAdlFile) \\/ I)
              // <=> { De Morgan }
              //     NewAdlFile~;NewAdlFile/\\-I
              // 
              // Normalized complement (== violationsSQL): NewAdlFile~;NewAdlFile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"NewAdlFile~;NewAdlFile\",\"-I\"] */
                          SELECT DISTINCT isect0.`AdlFile` AS src, isect0.`AdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"NewAdlFile~\",\"NewAdlFile\"] */
                                 
                                 SELECT DISTINCT ECps0.`AdlFile`, ECps1.`AdlFile` AS `AdlFile1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `NewAdlFile`, `AdlFile`
                                        FROM `File`
                                        WHERE `NewAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                      ) AS ECps0,
                                      `File` AS ECps1
                                 WHERE ECps0.`NewAdlFile`=ECps1.`NewAdlFile`
                               ) AS isect0
                          WHERE isect0.`AdlFile` <> isect0.`AdlFile1` AND isect0.`AdlFile` IS NOT NULL AND isect0.`AdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot NewAdlFile' =>
        array ( 'name' => 'tot NewAdlFile'
              , 'ruleAdl' => 'I |- NewAdlFile;NewAdlFile~'
              , 'origin' => 'line 32, file "Fspec.adl"'
              , 'meaning' => 'NewAdlFile[NewAdlFile\\*AdlFile] is totaal'
              , 'message' => 'NewAdlFile[NewAdlFile\\*AdlFile] is niet totaal'
              , 'srcConcept' => 'NewAdlFile'
              , 'tgtConcept' => 'NewAdlFile'
              // Normalization steps:
              //     -(-I \\/ NewAdlFile;NewAdlFile~)
              // <=> { De Morgan }
              //     I/\\-(NewAdlFile;NewAdlFile~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(NewAdlFile;NewAdlFile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(NewAdlFile;NewAdlFile~)\"] */
                          SELECT DISTINCT isect0.`NewAdlFile` AS src, isect0.`NewAdlFile` AS tgt
                          FROM `File` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"NewAdlFile\",\"NewAdlFile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`NewAdlFile`, ECps1.`NewAdlFile` AS `NewAdlFile1`
                                             FROM `File` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `NewAdlFile`, `AdlFile`
                                                    FROM `File`
                                                    WHERE `NewAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                                           ) AS cp
                                      WHERE isect0.`NewAdlFile`=cp.`NewAdlFile` AND isect0.`NewAdlFile`=cp.`NewAdlFile1`) AND isect0.`NewAdlFile` IS NOT NULL AND isect0.`NewAdlFile` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj NewAdlFile' =>
        array ( 'name' => 'inj NewAdlFile'
              , 'ruleAdl' => 'NewAdlFile;NewAdlFile~ |- I'
              , 'origin' => 'line 32, file "Fspec.adl"'
              , 'meaning' => 'NewAdlFile[NewAdlFile\\*AdlFile] is injectief'
              , 'message' => 'NewAdlFile[NewAdlFile\\*AdlFile] is niet injectief'
              , 'srcConcept' => 'NewAdlFile'
              , 'tgtConcept' => 'NewAdlFile'
              // Normalization steps:
              //     -(-(NewAdlFile;NewAdlFile~) \\/ I)
              // <=> { De Morgan }
              //     NewAdlFile;NewAdlFile~/\\-I
              // 
              // Normalized complement (== violationsSQL): NewAdlFile;NewAdlFile~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"NewAdlFile;NewAdlFile~\",\"-I\"] */
                          SELECT DISTINCT isect0.`NewAdlFile` AS src, isect0.`NewAdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"NewAdlFile\",\"NewAdlFile~\"] */
                                 
                                 SELECT DISTINCT ECps0.`NewAdlFile`, ECps1.`NewAdlFile` AS `NewAdlFile1`
                                 FROM `File` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `NewAdlFile`, `AdlFile`
                                        FROM `File`
                                        WHERE `NewAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                               ) AS isect0
                          WHERE isect0.`NewAdlFile` <> isect0.`NewAdlFile1` AND isect0.`NewAdlFile` IS NOT NULL AND isect0.`NewAdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni SavePopFile' =>
        array ( 'name' => 'uni SavePopFile'
              , 'ruleAdl' => 'SavePopFile~;SavePopFile |- I'
              , 'origin' => 'line 37, file "Fspec.adl"'
              , 'meaning' => 'SavePopFile[SavePopFile\\*File] is univalent'
              , 'message' => 'SavePopFile[SavePopFile\\*File] is niet univalent'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'File'
              // Normalization steps:
              //     -(-(SavePopFile~;SavePopFile) \\/ I)
              // <=> { De Morgan }
              //     SavePopFile~;SavePopFile/\\-I
              // 
              // Normalized complement (== violationsSQL): SavePopFile~;SavePopFile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"SavePopFile~;SavePopFile\",\"-I\"] */
                          SELECT DISTINCT isect0.`File` AS src, isect0.`File1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"SavePopFile~\",\"SavePopFile\"] */
                                 
                                 SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SavePopFile`, `File`
                                        FROM `File`
                                        WHERE `SavePopFile` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps0,
                                      `File` AS ECps1
                                 WHERE ECps0.`SavePopFile`=ECps1.`SavePopFile`
                               ) AS isect0
                          WHERE isect0.`File` <> isect0.`File1` AND isect0.`File` IS NOT NULL AND isect0.`File1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot SavePopFile' =>
        array ( 'name' => 'tot SavePopFile'
              , 'ruleAdl' => 'I |- SavePopFile;SavePopFile~'
              , 'origin' => 'line 37, file "Fspec.adl"'
              , 'meaning' => 'SavePopFile[SavePopFile\\*File] is totaal'
              , 'message' => 'SavePopFile[SavePopFile\\*File] is niet totaal'
              , 'srcConcept' => 'SavePopFile'
              , 'tgtConcept' => 'SavePopFile'
              // Normalization steps:
              //     -(-I \\/ SavePopFile;SavePopFile~)
              // <=> { De Morgan }
              //     I/\\-(SavePopFile;SavePopFile~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(SavePopFile;SavePopFile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(SavePopFile;SavePopFile~)\"] */
                          SELECT DISTINCT isect0.`SavePopFile` AS src, isect0.`SavePopFile` AS tgt
                          FROM `File` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"SavePopFile\",\"SavePopFile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SavePopFile`, ECps1.`SavePopFile` AS `SavePopFile1`
                                             FROM `File` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SavePopFile`, `File`
                                                    FROM `File`
                                                    WHERE `SavePopFile` IS NOT NULL AND `File` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`File`=ECps1.`File`
                                           ) AS cp
                                      WHERE isect0.`SavePopFile`=cp.`SavePopFile` AND isect0.`SavePopFile`=cp.`SavePopFile1`) AND isect0.`SavePopFile` IS NOT NULL AND isect0.`SavePopFile` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj SavePopFile' =>
        array ( 'name' => 'inj SavePopFile'
              , 'ruleAdl' => 'SavePopFile;SavePopFile~ |- I'
              , 'origin' => 'line 37, file "Fspec.adl"'
              , 'meaning' => 'SavePopFile[SavePopFile\\*File] is injectief'
              , 'message' => 'SavePopFile[SavePopFile\\*File] is niet injectief'
              , 'srcConcept' => 'SavePopFile'
              , 'tgtConcept' => 'SavePopFile'
              // Normalization steps:
              //     -(-(SavePopFile;SavePopFile~) \\/ I)
              // <=> { De Morgan }
              //     SavePopFile;SavePopFile~/\\-I
              // 
              // Normalized complement (== violationsSQL): SavePopFile;SavePopFile~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"SavePopFile;SavePopFile~\",\"-I\"] */
                          SELECT DISTINCT isect0.`SavePopFile` AS src, isect0.`SavePopFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"SavePopFile\",\"SavePopFile~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SavePopFile`, ECps1.`SavePopFile` AS `SavePopFile1`
                                 FROM `File` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SavePopFile`, `File`
                                        FROM `File`
                                        WHERE `SavePopFile` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`SavePopFile` <> isect0.`SavePopFile1` AND isect0.`SavePopFile` IS NOT NULL AND isect0.`SavePopFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni SaveAdlFile' =>
        array ( 'name' => 'uni SaveAdlFile'
              , 'ruleAdl' => 'SaveAdlFile~;SaveAdlFile |- I'
              , 'origin' => 'line 43, file "Fspec.adl"'
              , 'meaning' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is univalent'
              , 'message' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is niet univalent'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalization steps:
              //     -(-(SaveAdlFile~;SaveAdlFile) \\/ I)
              // <=> { De Morgan }
              //     SaveAdlFile~;SaveAdlFile/\\-I
              // 
              // Normalized complement (== violationsSQL): SaveAdlFile~;SaveAdlFile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"SaveAdlFile~;SaveAdlFile\",\"-I\"] */
                          SELECT DISTINCT isect0.`AdlFile` AS src, isect0.`AdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"SaveAdlFile~\",\"SaveAdlFile\"] */
                                 
                                 SELECT DISTINCT ECps0.`AdlFile`, ECps1.`AdlFile` AS `AdlFile1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SaveAdlFile`, `AdlFile`
                                        FROM `File`
                                        WHERE `SaveAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                      ) AS ECps0,
                                      `File` AS ECps1
                                 WHERE ECps0.`SaveAdlFile`=ECps1.`SaveAdlFile`
                               ) AS isect0
                          WHERE isect0.`AdlFile` <> isect0.`AdlFile1` AND isect0.`AdlFile` IS NOT NULL AND isect0.`AdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot SaveAdlFile' =>
        array ( 'name' => 'tot SaveAdlFile'
              , 'ruleAdl' => 'I |- SaveAdlFile;SaveAdlFile~'
              , 'origin' => 'line 43, file "Fspec.adl"'
              , 'meaning' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is totaal'
              , 'message' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is niet totaal'
              , 'srcConcept' => 'SaveAdlFile'
              , 'tgtConcept' => 'SaveAdlFile'
              // Normalization steps:
              //     -(-I \\/ SaveAdlFile;SaveAdlFile~)
              // <=> { De Morgan }
              //     I/\\-(SaveAdlFile;SaveAdlFile~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(SaveAdlFile;SaveAdlFile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(SaveAdlFile;SaveAdlFile~)\"] */
                          SELECT DISTINCT isect0.`SaveAdlFile` AS src, isect0.`SaveAdlFile` AS tgt
                          FROM `File` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"SaveAdlFile\",\"SaveAdlFile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SaveAdlFile`, ECps1.`SaveAdlFile` AS `SaveAdlFile1`
                                             FROM `File` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SaveAdlFile`, `AdlFile`
                                                    FROM `File`
                                                    WHERE `SaveAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                                           ) AS cp
                                      WHERE isect0.`SaveAdlFile`=cp.`SaveAdlFile` AND isect0.`SaveAdlFile`=cp.`SaveAdlFile1`) AND isect0.`SaveAdlFile` IS NOT NULL AND isect0.`SaveAdlFile` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj SaveAdlFile' =>
        array ( 'name' => 'inj SaveAdlFile'
              , 'ruleAdl' => 'SaveAdlFile;SaveAdlFile~ |- I'
              , 'origin' => 'line 43, file "Fspec.adl"'
              , 'meaning' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is injectief'
              , 'message' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is niet injectief'
              , 'srcConcept' => 'SaveAdlFile'
              , 'tgtConcept' => 'SaveAdlFile'
              // Normalization steps:
              //     -(-(SaveAdlFile;SaveAdlFile~) \\/ I)
              // <=> { De Morgan }
              //     SaveAdlFile;SaveAdlFile~/\\-I
              // 
              // Normalized complement (== violationsSQL): SaveAdlFile;SaveAdlFile~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"SaveAdlFile;SaveAdlFile~\",\"-I\"] */
                          SELECT DISTINCT isect0.`SaveAdlFile` AS src, isect0.`SaveAdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"SaveAdlFile\",\"SaveAdlFile~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SaveAdlFile`, ECps1.`SaveAdlFile` AS `SaveAdlFile1`
                                 FROM `File` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SaveAdlFile`, `AdlFile`
                                        FROM `File`
                                        WHERE `SaveAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                               ) AS isect0
                          WHERE isect0.`SaveAdlFile` <> isect0.`SaveAdlFile1` AND isect0.`SaveAdlFile` IS NOT NULL AND isect0.`SaveAdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni countrules' =>
        array ( 'name' => 'uni countrules'
              , 'ruleAdl' => 'countrules~;countrules |- I'
              , 'origin' => 'line 51, file "Fspec.adl"'
              , 'meaning' => 'countrules[Context\\*Int] is univalent'
              , 'message' => 'countrules[Context\\*Int] is niet univalent'
              , 'srcConcept' => 'Int'
              , 'tgtConcept' => 'Int'
              // Normalization steps:
              //     -(-(countrules~;countrules) \\/ I)
              // <=> { De Morgan }
              //     countrules~;countrules/\\-I
              // 
              // Normalized complement (== violationsSQL): countrules~;countrules/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"countrules~;countrules\",\"-I\"] */
                          SELECT DISTINCT isect0.`countrules` AS src, isect0.`countrules1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"countrules~\",\"countrules\"] */
                                 
                                 SELECT DISTINCT ECps0.`countrules`, ECps1.`countrules` AS `countrules1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `countrules`
                                        FROM `Conid`
                                        WHERE `ctxnm` IS NOT NULL AND `countrules` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`countrules` <> isect0.`countrules1` AND isect0.`countrules` IS NOT NULL AND isect0.`countrules1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni countdecls' =>
        array ( 'name' => 'uni countdecls'
              , 'ruleAdl' => 'countdecls~;countdecls |- I'
              , 'origin' => 'line 52, file "Fspec.adl"'
              , 'meaning' => 'countdecls[Context\\*Int] is univalent'
              , 'message' => 'countdecls[Context\\*Int] is niet univalent'
              , 'srcConcept' => 'Int'
              , 'tgtConcept' => 'Int'
              // Normalization steps:
              //     -(-(countdecls~;countdecls) \\/ I)
              // <=> { De Morgan }
              //     countdecls~;countdecls/\\-I
              // 
              // Normalized complement (== violationsSQL): countdecls~;countdecls/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"countdecls~;countdecls\",\"-I\"] */
                          SELECT DISTINCT isect0.`countdecls` AS src, isect0.`countdecls1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"countdecls~\",\"countdecls\"] */
                                 
                                 SELECT DISTINCT ECps0.`countdecls`, ECps1.`countdecls` AS `countdecls1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `countdecls`
                                        FROM `Conid`
                                        WHERE `ctxnm` IS NOT NULL AND `countdecls` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`countdecls` <> isect0.`countdecls1` AND isect0.`countdecls` IS NOT NULL AND isect0.`countdecls1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni countcpts' =>
        array ( 'name' => 'uni countcpts'
              , 'ruleAdl' => 'countcpts~;countcpts |- I'
              , 'origin' => 'line 53, file "Fspec.adl"'
              , 'meaning' => 'countcpts[Context\\*Int] is univalent'
              , 'message' => 'countcpts[Context\\*Int] is niet univalent'
              , 'srcConcept' => 'Int'
              , 'tgtConcept' => 'Int'
              // Normalization steps:
              //     -(-(countcpts~;countcpts) \\/ I)
              // <=> { De Morgan }
              //     countcpts~;countcpts/\\-I
              // 
              // Normalized complement (== violationsSQL): countcpts~;countcpts/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"countcpts~;countcpts\",\"-I\"] */
                          SELECT DISTINCT isect0.`countcpts` AS src, isect0.`countcpts1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"countcpts~\",\"countcpts\"] */
                                 
                                 SELECT DISTINCT ECps0.`countcpts`, ECps1.`countcpts` AS `countcpts1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `countcpts`
                                        FROM `Conid`
                                        WHERE `ctxnm` IS NOT NULL AND `countcpts` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`countcpts` <> isect0.`countcpts1` AND isect0.`countcpts` IS NOT NULL AND isect0.`countcpts1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni ptpic' =>
        array ( 'name' => 'uni ptpic'
              , 'ruleAdl' => 'ptpic~;ptpic |- I'
              , 'origin' => 'line 57, file "Fspec.adl"'
              , 'meaning' => 'ptpic[Pattern\\*Image] is univalent'
              , 'message' => 'ptpic[Pattern\\*Image] is niet univalent'
              , 'srcConcept' => 'Image'
              , 'tgtConcept' => 'Image'
              // Normalization steps:
              //     -(-(ptpic~;ptpic) \\/ I)
              // <=> { De Morgan }
              //     ptpic~;ptpic/\\-I
              // 
              // Normalized complement (== violationsSQL): ptpic~;ptpic/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ptpic~;ptpic\",\"-I\"] */
                          SELECT DISTINCT isect0.`ptpic` AS src, isect0.`ptpic1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ptpic~\",\"ptpic\"] */
                                 
                                 SELECT DISTINCT ECps0.`ptpic`, ECps1.`ptpic` AS `ptpic1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ptnm`, `ptpic`
                                        FROM `Conid`
                                        WHERE `ptnm` IS NOT NULL AND `ptpic` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`ptnm`=ECps1.`ptnm`
                               ) AS isect0
                          WHERE isect0.`ptpic` <> isect0.`ptpic1` AND isect0.`ptpic` IS NOT NULL AND isect0.`ptpic1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni cptpic' =>
        array ( 'name' => 'uni cptpic'
              , 'ruleAdl' => 'cptpic~;cptpic |- I'
              , 'origin' => 'line 58, file "Fspec.adl"'
              , 'meaning' => 'cptpic[Concept\\*Image] is univalent'
              , 'message' => 'cptpic[Concept\\*Image] is niet univalent'
              , 'srcConcept' => 'Image'
              , 'tgtConcept' => 'Image'
              // Normalization steps:
              //     -(-(cptpic~;cptpic) \\/ I)
              // <=> { De Morgan }
              //     cptpic~;cptpic/\\-I
              // 
              // Normalized complement (== violationsSQL): cptpic~;cptpic/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptpic~;cptpic\",\"-I\"] */
                          SELECT DISTINCT isect0.`cptpic` AS src, isect0.`cptpic1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptpic~\",\"cptpic\"] */
                                 
                                 SELECT DISTINCT ECps0.`cptpic`, ECps1.`cptpic` AS `cptpic1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptnm`, `cptpic`
                                        FROM `Conid`
                                        WHERE `cptnm` IS NOT NULL AND `cptpic` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`cptnm`=ECps1.`cptnm`
                               ) AS isect0
                          WHERE isect0.`cptpic` <> isect0.`cptpic1` AND isect0.`cptpic` IS NOT NULL AND isect0.`cptpic1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni rrpic' =>
        array ( 'name' => 'uni rrpic'
              , 'ruleAdl' => 'rrpic~;rrpic |- I'
              , 'origin' => 'line 59, file "Fspec.adl"'
              , 'meaning' => 'rrpic[Rule\\*Image] is univalent'
              , 'message' => 'rrpic[Rule\\*Image] is niet univalent'
              , 'srcConcept' => 'Image'
              , 'tgtConcept' => 'Image'
              // Normalization steps:
              //     -(-(rrpic~;rrpic) \\/ I)
              // <=> { De Morgan }
              //     rrpic~;rrpic/\\-I
              // 
              // Normalized complement (== violationsSQL): rrpic~;rrpic/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrpic~;rrpic\",\"-I\"] */
                          SELECT DISTINCT isect0.`rrpic` AS src, isect0.`rrpic1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrpic~\",\"rrpic\"] */
                                 
                                 SELECT DISTINCT ECps0.`rrpic`, ECps1.`rrpic` AS `rrpic1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `rrnm`, `rrpic`
                                        FROM `ADLid`
                                        WHERE `rrnm` IS NOT NULL AND `rrpic` IS NOT NULL
                                      ) AS ECps0,
                                      `ADLid` AS ECps1
                                 WHERE ECps0.`rrnm`=ECps1.`rrnm`
                               ) AS isect0
                          WHERE isect0.`rrpic` <> isect0.`rrpic1` AND isect0.`rrpic` IS NOT NULL AND isect0.`rrpic1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni Violation' =>
        array ( 'name' => 'uni Violation'
              , 'ruleAdl' => 'Violation~;Violation |- I'
              , 'origin' => 'line 63, file "Fspec.adl"'
              , 'meaning' => 'Violation[Violation\\*PairID] is univalent'
              , 'message' => 'Violation[Violation\\*PairID] is niet univalent'
              , 'srcConcept' => 'PairID'
              , 'tgtConcept' => 'PairID'
              // Normalization steps:
              //     -(-(Violation~;Violation) \\/ I)
              // <=> { De Morgan }
              //     Violation~;Violation/\\-I
              // 
              // Normalized complement (== violationsSQL): Violation~;Violation/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"Violation~;Violation\",\"-I\"] */
                          SELECT DISTINCT isect0.`PairID` AS src, isect0.`PairID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"Violation~\",\"Violation\"] */
                                 
                                 SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Violation`, `PairID`
                                        FROM `PairID`
                                        WHERE `Violation` IS NOT NULL AND `PairID` IS NOT NULL
                                      ) AS ECps0,
                                      `PairID` AS ECps1
                                 WHERE ECps0.`Violation`=ECps1.`Violation`
                               ) AS isect0
                          WHERE isect0.`PairID` <> isect0.`PairID1` AND isect0.`PairID` IS NOT NULL AND isect0.`PairID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot Violation' =>
        array ( 'name' => 'tot Violation'
              , 'ruleAdl' => 'I |- Violation;Violation~'
              , 'origin' => 'line 63, file "Fspec.adl"'
              , 'meaning' => 'Violation[Violation\\*PairID] is totaal'
              , 'message' => 'Violation[Violation\\*PairID] is niet totaal'
              , 'srcConcept' => 'Violation'
              , 'tgtConcept' => 'Violation'
              // Normalization steps:
              //     -(-I \\/ Violation;Violation~)
              // <=> { De Morgan }
              //     I/\\-(Violation;Violation~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(Violation;Violation~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(Violation;Violation~)\"] */
                          SELECT DISTINCT isect0.`Violation` AS src, isect0.`Violation` AS tgt
                          FROM `PairID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"Violation\",\"Violation~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Violation`, ECps1.`Violation` AS `Violation1`
                                             FROM `PairID` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Violation`, `PairID`
                                                    FROM `PairID`
                                                    WHERE `Violation` IS NOT NULL AND `PairID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`PairID`=ECps1.`PairID`
                                           ) AS cp
                                      WHERE isect0.`Violation`=cp.`Violation` AND isect0.`Violation`=cp.`Violation1`) AND isect0.`Violation` IS NOT NULL AND isect0.`Violation` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj Violation' =>
        array ( 'name' => 'inj Violation'
              , 'ruleAdl' => 'Violation;Violation~ |- I'
              , 'origin' => 'line 63, file "Fspec.adl"'
              , 'meaning' => 'Violation[Violation\\*PairID] is injectief'
              , 'message' => 'Violation[Violation\\*PairID] is niet injectief'
              , 'srcConcept' => 'Violation'
              , 'tgtConcept' => 'Violation'
              // Normalization steps:
              //     -(-(Violation;Violation~) \\/ I)
              // <=> { De Morgan }
              //     Violation;Violation~/\\-I
              // 
              // Normalized complement (== violationsSQL): Violation;Violation~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"Violation;Violation~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Violation` AS src, isect0.`Violation1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"Violation\",\"Violation~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Violation`, ECps1.`Violation` AS `Violation1`
                                 FROM `PairID` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Violation`, `PairID`
                                        FROM `PairID`
                                        WHERE `Violation` IS NOT NULL AND `PairID` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                               ) AS isect0
                          WHERE isect0.`Violation` <> isect0.`Violation1` AND isect0.`Violation` IS NOT NULL AND isect0.`Violation1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj ctxnm' =>
        array ( 'name' => 'inj ctxnm'
              , 'ruleAdl' => 'ctxnm;ctxnm~ |- I'
              , 'origin' => 'line 43, file "AST.adl"'
              , 'meaning' => 'ctxnm[Context\\*Conid] is injectief'
              , 'message' => 'ctxnm[Context\\*Conid] is niet injectief'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalization steps:
              //     -(-(ctxnm;ctxnm~) \\/ I)
              // <=> { De Morgan }
              //     ctxnm;ctxnm~/\\-I
              // 
              // Normalized complement (== violationsSQL): ctxnm;ctxnm~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ctxnm;ctxnm~\",\"-I\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ctxnm\",\"ctxnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                 FROM `Conid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `Conid`
                                        FROM `Conid`
                                        WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Conid`=ECps1.`Conid`
                               ) AS isect0
                          WHERE isect0.`ctxnm` <> isect0.`ctxnm1` AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni ctxnm' =>
        array ( 'name' => 'uni ctxnm'
              , 'ruleAdl' => 'ctxnm~;ctxnm |- I'
              , 'origin' => 'line 43, file "AST.adl"'
              , 'meaning' => 'ctxnm[Context\\*Conid] is univalent'
              , 'message' => 'ctxnm[Context\\*Conid] is niet univalent'
              , 'srcConcept' => 'Conid'
              , 'tgtConcept' => 'Conid'
              // Normalization steps:
              //     -(-(ctxnm~;ctxnm) \\/ I)
              // <=> { De Morgan }
              //     ctxnm~;ctxnm/\\-I
              // 
              // Normalized complement (== violationsSQL): ctxnm~;ctxnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ctxnm~;ctxnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`Conid` AS src, isect0.`Conid1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ctxnm~\",\"ctxnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Conid`, ECps1.`Conid` AS `Conid1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `Conid`
                                        FROM `Conid`
                                        WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`Conid` <> isect0.`Conid1` AND isect0.`Conid` IS NOT NULL AND isect0.`Conid1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot ctxnm' =>
        array ( 'name' => 'tot ctxnm'
              , 'ruleAdl' => 'I |- ctxnm;ctxnm~'
              , 'origin' => 'line 43, file "AST.adl"'
              , 'meaning' => 'ctxnm[Context\\*Conid] is totaal'
              , 'message' => 'ctxnm[Context\\*Conid] is niet totaal'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalization steps:
              //     -(-I \\/ ctxnm;ctxnm~)
              // <=> { De Morgan }
              //     I/\\-(ctxnm;ctxnm~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(ctxnm;ctxnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(ctxnm;ctxnm~)\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm` AS tgt
                          FROM `Conid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"ctxnm\",\"ctxnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                             FROM `Conid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ctxnm`, `Conid`
                                                    FROM `Conid`
                                                    WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Conid`=ECps1.`Conid`
                                           ) AS cp
                                      WHERE isect0.`ctxnm`=cp.`ctxnm` AND isect0.`ctxnm`=cp.`ctxnm1`) AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj ptnm' =>
        array ( 'name' => 'inj ptnm'
              , 'ruleAdl' => 'ptnm;ptnm~ |- I'
              , 'origin' => 'line 71, file "AST.adl"'
              , 'meaning' => 'ptnm[Pattern\\*Conid] is injectief'
              , 'message' => 'ptnm[Pattern\\*Conid] is niet injectief'
              , 'srcConcept' => 'Pattern'
              , 'tgtConcept' => 'Pattern'
              // Normalization steps:
              //     -(-(ptnm;ptnm~) \\/ I)
              // <=> { De Morgan }
              //     ptnm;ptnm~/\\-I
              // 
              // Normalized complement (== violationsSQL): ptnm;ptnm~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ptnm;ptnm~\",\"-I\"] */
                          SELECT DISTINCT isect0.`ptnm` AS src, isect0.`ptnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ptnm\",\"ptnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`ptnm`, ECps1.`ptnm` AS `ptnm1`
                                 FROM `Conid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ptnm`, `Conid`
                                        FROM `Conid`
                                        WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Conid`=ECps1.`Conid`
                               ) AS isect0
                          WHERE isect0.`ptnm` <> isect0.`ptnm1` AND isect0.`ptnm` IS NOT NULL AND isect0.`ptnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni ptnm' =>
        array ( 'name' => 'uni ptnm'
              , 'ruleAdl' => 'ptnm~;ptnm |- I'
              , 'origin' => 'line 71, file "AST.adl"'
              , 'meaning' => 'ptnm[Pattern\\*Conid] is univalent'
              , 'message' => 'ptnm[Pattern\\*Conid] is niet univalent'
              , 'srcConcept' => 'Conid'
              , 'tgtConcept' => 'Conid'
              // Normalization steps:
              //     -(-(ptnm~;ptnm) \\/ I)
              // <=> { De Morgan }
              //     ptnm~;ptnm/\\-I
              // 
              // Normalized complement (== violationsSQL): ptnm~;ptnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ptnm~;ptnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`Conid` AS src, isect0.`Conid1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ptnm~\",\"ptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Conid`, ECps1.`Conid` AS `Conid1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ptnm`, `Conid`
                                        FROM `Conid`
                                        WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`ptnm`=ECps1.`ptnm`
                               ) AS isect0
                          WHERE isect0.`Conid` <> isect0.`Conid1` AND isect0.`Conid` IS NOT NULL AND isect0.`Conid1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot ptnm' =>
        array ( 'name' => 'tot ptnm'
              , 'ruleAdl' => 'I |- ptnm;ptnm~'
              , 'origin' => 'line 71, file "AST.adl"'
              , 'meaning' => 'ptnm[Pattern\\*Conid] is totaal'
              , 'message' => 'ptnm[Pattern\\*Conid] is niet totaal'
              , 'srcConcept' => 'Pattern'
              , 'tgtConcept' => 'Pattern'
              // Normalization steps:
              //     -(-I \\/ ptnm;ptnm~)
              // <=> { De Morgan }
              //     I/\\-(ptnm;ptnm~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(ptnm;ptnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(ptnm;ptnm~)\"] */
                          SELECT DISTINCT isect0.`ptnm` AS src, isect0.`ptnm` AS tgt
                          FROM `Conid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"ptnm\",\"ptnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ptnm`, ECps1.`ptnm` AS `ptnm1`
                                             FROM `Conid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ptnm`, `Conid`
                                                    FROM `Conid`
                                                    WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Conid`=ECps1.`Conid`
                                           ) AS cp
                                      WHERE isect0.`ptnm`=cp.`ptnm` AND isect0.`ptnm`=cp.`ptnm1`) AND isect0.`ptnm` IS NOT NULL AND isect0.`ptnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni gengen' =>
        array ( 'name' => 'uni gengen'
              , 'ruleAdl' => 'gengen~;gengen |- I'
              , 'origin' => 'line 98, file "AST.adl"'
              , 'meaning' => 'gengen[Gen\\*Concept] is univalent'
              , 'message' => 'gengen[Gen\\*Concept] is niet univalent'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalization steps:
              //     -(-(gengen~;gengen) \\/ I)
              // <=> { De Morgan }
              //     gengen~;gengen/\\-I
              // 
              // Normalized complement (== violationsSQL): gengen~;gengen/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"gengen~;gengen\",\"-I\"] */
                          SELECT DISTINCT isect0.`gengen` AS src, isect0.`gengen1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"gengen~\",\"gengen\"] */
                                 
                                 SELECT DISTINCT ECps0.`gengen`, ECps1.`gengen` AS `gengen1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Gen`, `gengen`
                                        FROM `Gen`
                                        WHERE `Gen` IS NOT NULL AND `gengen` IS NOT NULL
                                      ) AS ECps0,
                                      `Gen` AS ECps1
                                 WHERE ECps0.`Gen`=ECps1.`Gen`
                               ) AS isect0
                          WHERE isect0.`gengen` <> isect0.`gengen1` AND isect0.`gengen` IS NOT NULL AND isect0.`gengen1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot gengen' =>
        array ( 'name' => 'tot gengen'
              , 'ruleAdl' => 'I |- gengen;gengen~'
              , 'origin' => 'line 98, file "AST.adl"'
              , 'meaning' => 'gengen[Gen\\*Concept] is totaal'
              , 'message' => 'gengen[Gen\\*Concept] is niet totaal'
              , 'srcConcept' => 'Gen'
              , 'tgtConcept' => 'Gen'
              // Normalization steps:
              //     -(-I \\/ gengen;gengen~)
              // <=> { De Morgan }
              //     I/\\-(gengen;gengen~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(gengen;gengen~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(gengen;gengen~)\"] */
                          SELECT DISTINCT isect0.`Gen` AS src, isect0.`Gen` AS tgt
                          FROM `Gen` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"gengen\",\"gengen~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Gen`, ECps1.`Gen` AS `Gen1`
                                             FROM `Gen` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Gen`, `gengen`
                                                    FROM `Gen`
                                                    WHERE `Gen` IS NOT NULL AND `gengen` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`gengen`=ECps1.`gengen`
                                           ) AS cp
                                      WHERE isect0.`Gen`=cp.`Gen` AND isect0.`Gen`=cp.`Gen1`) AND isect0.`Gen` IS NOT NULL AND isect0.`Gen` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni genspc' =>
        array ( 'name' => 'uni genspc'
              , 'ruleAdl' => 'genspc~;genspc |- I'
              , 'origin' => 'line 100, file "AST.adl"'
              , 'meaning' => 'genspc[Gen\\*Concept] is univalent'
              , 'message' => 'genspc[Gen\\*Concept] is niet univalent'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalization steps:
              //     -(-(genspc~;genspc) \\/ I)
              // <=> { De Morgan }
              //     genspc~;genspc/\\-I
              // 
              // Normalized complement (== violationsSQL): genspc~;genspc/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"genspc~;genspc\",\"-I\"] */
                          SELECT DISTINCT isect0.`genspc` AS src, isect0.`genspc1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"genspc~\",\"genspc\"] */
                                 
                                 SELECT DISTINCT ECps0.`genspc`, ECps1.`genspc` AS `genspc1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Gen`, `genspc`
                                        FROM `Gen`
                                        WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                      ) AS ECps0,
                                      `Gen` AS ECps1
                                 WHERE ECps0.`Gen`=ECps1.`Gen`
                               ) AS isect0
                          WHERE isect0.`genspc` <> isect0.`genspc1` AND isect0.`genspc` IS NOT NULL AND isect0.`genspc1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot genspc' =>
        array ( 'name' => 'tot genspc'
              , 'ruleAdl' => 'I |- genspc;genspc~'
              , 'origin' => 'line 100, file "AST.adl"'
              , 'meaning' => 'genspc[Gen\\*Concept] is totaal'
              , 'message' => 'genspc[Gen\\*Concept] is niet totaal'
              , 'srcConcept' => 'Gen'
              , 'tgtConcept' => 'Gen'
              // Normalization steps:
              //     -(-I \\/ genspc;genspc~)
              // <=> { De Morgan }
              //     I/\\-(genspc;genspc~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(genspc;genspc~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(genspc;genspc~)\"] */
                          SELECT DISTINCT isect0.`Gen` AS src, isect0.`Gen` AS tgt
                          FROM `Gen` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"genspc\",\"genspc~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Gen`, ECps1.`Gen` AS `Gen1`
                                             FROM `Gen` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Gen`, `genspc`
                                                    FROM `Gen`
                                                    WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`genspc`=ECps1.`genspc`
                                           ) AS cp
                                      WHERE isect0.`Gen`=cp.`Gen` AND isect0.`Gen`=cp.`Gen1`) AND isect0.`Gen` IS NOT NULL AND isect0.`Gen` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj cptnm' =>
        array ( 'name' => 'inj cptnm'
              , 'ruleAdl' => 'cptnm;cptnm~ |- I'
              , 'origin' => 'line 124, file "AST.adl"'
              , 'meaning' => 'cptnm[Concept\\*Conid] is injectief'
              , 'message' => 'cptnm[Concept\\*Conid] is niet injectief'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalization steps:
              //     -(-(cptnm;cptnm~) \\/ I)
              // <=> { De Morgan }
              //     cptnm;cptnm~/\\-I
              // 
              // Normalized complement (== violationsSQL): cptnm;cptnm~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptnm;cptnm~\",\"-I\"] */
                          SELECT DISTINCT isect0.`cptnm` AS src, isect0.`cptnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptnm\",\"cptnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`cptnm`, ECps1.`cptnm` AS `cptnm1`
                                 FROM `Conid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptnm`, `Conid`
                                        FROM `Conid`
                                        WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Conid`=ECps1.`Conid`
                               ) AS isect0
                          WHERE isect0.`cptnm` <> isect0.`cptnm1` AND isect0.`cptnm` IS NOT NULL AND isect0.`cptnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni cptnm' =>
        array ( 'name' => 'uni cptnm'
              , 'ruleAdl' => 'cptnm~;cptnm |- I'
              , 'origin' => 'line 124, file "AST.adl"'
              , 'meaning' => 'cptnm[Concept\\*Conid] is univalent'
              , 'message' => 'cptnm[Concept\\*Conid] is niet univalent'
              , 'srcConcept' => 'Conid'
              , 'tgtConcept' => 'Conid'
              // Normalization steps:
              //     -(-(cptnm~;cptnm) \\/ I)
              // <=> { De Morgan }
              //     cptnm~;cptnm/\\-I
              // 
              // Normalized complement (== violationsSQL): cptnm~;cptnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptnm~;cptnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`Conid` AS src, isect0.`Conid1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptnm~\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Conid`, ECps1.`Conid` AS `Conid1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptnm`, `Conid`
                                        FROM `Conid`
                                        WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`cptnm`=ECps1.`cptnm`
                               ) AS isect0
                          WHERE isect0.`Conid` <> isect0.`Conid1` AND isect0.`Conid` IS NOT NULL AND isect0.`Conid1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot cptnm' =>
        array ( 'name' => 'tot cptnm'
              , 'ruleAdl' => 'I |- cptnm;cptnm~'
              , 'origin' => 'line 124, file "AST.adl"'
              , 'meaning' => 'cptnm[Concept\\*Conid] is totaal'
              , 'message' => 'cptnm[Concept\\*Conid] is niet totaal'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalization steps:
              //     -(-I \\/ cptnm;cptnm~)
              // <=> { De Morgan }
              //     I/\\-(cptnm;cptnm~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(cptnm;cptnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(cptnm;cptnm~)\"] */
                          SELECT DISTINCT isect0.`cptnm` AS src, isect0.`cptnm` AS tgt
                          FROM `Conid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"cptnm\",\"cptnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`cptnm`, ECps1.`cptnm` AS `cptnm1`
                                             FROM `Conid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `cptnm`, `Conid`
                                                    FROM `Conid`
                                                    WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Conid`=ECps1.`Conid`
                                           ) AS cp
                                      WHERE isect0.`cptnm`=cp.`cptnm` AND isect0.`cptnm`=cp.`cptnm1`) AND isect0.`cptnm` IS NOT NULL AND isect0.`cptnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj cptos' =>
        array ( 'name' => 'inj cptos'
              , 'ruleAdl' => 'cptos;cptos~ |- I'
              , 'origin' => 'line 126, file "AST.adl"'
              , 'meaning' => 'cptos[Concept\\*AtomID] is injectief'
              , 'message' => 'cptos[Concept\\*AtomID] is niet injectief'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalization steps:
              //     -(-(cptos;cptos~) \\/ I)
              // <=> { De Morgan }
              //     cptos;cptos~/\\-I
              // 
              // Normalized complement (== violationsSQL): cptos;cptos~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptos;cptos~\",\"-I\"] */
                          SELECT DISTINCT isect0.`cptos` AS src, isect0.`cptos1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptos\",\"cptos~\"] */
                                 
                                 SELECT DISTINCT ECps0.`cptos`, ECps1.`cptos` AS `cptos1`
                                 FROM `AtomID` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptos`, `AtomID`
                                        FROM `AtomID`
                                        WHERE `cptos` IS NOT NULL AND `AtomID` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`AtomID`=ECps1.`AtomID`
                               ) AS isect0
                          WHERE isect0.`cptos` <> isect0.`cptos1` AND isect0.`cptos` IS NOT NULL AND isect0.`cptos1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni atomvalue' =>
        array ( 'name' => 'uni atomvalue'
              , 'ruleAdl' => 'atomvalue~;atomvalue |- I'
              , 'origin' => 'line 137, file "AST.adl"'
              , 'meaning' => 'atomvalue[AtomID\\*Atom] is univalent'
              , 'message' => 'atomvalue[AtomID\\*Atom] is niet univalent'
              , 'srcConcept' => 'Atom'
              , 'tgtConcept' => 'Atom'
              // Normalization steps:
              //     -(-(atomvalue~;atomvalue) \\/ I)
              // <=> { De Morgan }
              //     atomvalue~;atomvalue/\\-I
              // 
              // Normalized complement (== violationsSQL): atomvalue~;atomvalue/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"atomvalue~;atomvalue\",\"-I\"] */
                          SELECT DISTINCT isect0.`atomvalue` AS src, isect0.`atomvalue1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"atomvalue~\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`atomvalue`, ECps1.`atomvalue` AS `atomvalue1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `AtomID`, `atomvalue`
                                        FROM `AtomID`
                                        WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL
                                      ) AS ECps0,
                                      `AtomID` AS ECps1
                                 WHERE ECps0.`AtomID`=ECps1.`AtomID`
                               ) AS isect0
                          WHERE isect0.`atomvalue` <> isect0.`atomvalue1` AND isect0.`atomvalue` IS NOT NULL AND isect0.`atomvalue1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot atomvalue' =>
        array ( 'name' => 'tot atomvalue'
              , 'ruleAdl' => 'I |- atomvalue;atomvalue~'
              , 'origin' => 'line 137, file "AST.adl"'
              , 'meaning' => 'atomvalue[AtomID\\*Atom] is totaal'
              , 'message' => 'atomvalue[AtomID\\*Atom] is niet totaal'
              , 'srcConcept' => 'AtomID'
              , 'tgtConcept' => 'AtomID'
              // Normalization steps:
              //     -(-I \\/ atomvalue;atomvalue~)
              // <=> { De Morgan }
              //     I/\\-(atomvalue;atomvalue~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(atomvalue;atomvalue~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(atomvalue;atomvalue~)\"] */
                          SELECT DISTINCT isect0.`AtomID` AS src, isect0.`AtomID` AS tgt
                          FROM `AtomID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"atomvalue\",\"atomvalue~\"] */
                                             
                                             SELECT DISTINCT ECps0.`AtomID`, ECps1.`AtomID` AS `AtomID1`
                                             FROM `AtomID` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `AtomID`, `atomvalue`
                                                    FROM `AtomID`
                                                    WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`atomvalue`=ECps1.`atomvalue`
                                           ) AS cp
                                      WHERE isect0.`AtomID`=cp.`AtomID` AND isect0.`AtomID`=cp.`AtomID1`) AND isect0.`AtomID` IS NOT NULL AND isect0.`AtomID` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni src' =>
        array ( 'name' => 'uni src'
              , 'ruleAdl' => 'src~;src |- I'
              , 'origin' => 'line 152, file "AST.adl"'
              , 'meaning' => 'src[Sign\\*Concept] is univalent'
              , 'message' => 'src[Sign\\*Concept] is niet univalent'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalization steps:
              //     -(-(src~;src) \\/ I)
              // <=> { De Morgan }
              //     src~;src/\\-I
              // 
              // Normalized complement (== violationsSQL): src~;src/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"src~;src\",\"-I\"] */
                          SELECT DISTINCT isect0.`src`, isect0.`src1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"src~\",\"src\"] */
                                 
                                 SELECT DISTINCT ECps0.`src`, ECps1.`src` AS `src1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Sign`, `src`
                                        FROM `Sign`
                                        WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL
                                      ) AS ECps0,
                                      `Sign` AS ECps1
                                 WHERE ECps0.`Sign`=ECps1.`Sign`
                               ) AS isect0
                          WHERE isect0.`src` <> isect0.`src1` AND isect0.`src` IS NOT NULL AND isect0.`src1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot src' =>
        array ( 'name' => 'tot src'
              , 'ruleAdl' => 'I |- src;src~'
              , 'origin' => 'line 152, file "AST.adl"'
              , 'meaning' => 'src[Sign\\*Concept] is totaal'
              , 'message' => 'src[Sign\\*Concept] is niet totaal'
              , 'srcConcept' => 'Sign'
              , 'tgtConcept' => 'Sign'
              // Normalization steps:
              //     -(-I \\/ src;src~)
              // <=> { De Morgan }
              //     I/\\-(src;src~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(src;src~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(src;src~)\"] */
                          SELECT DISTINCT isect0.`Sign` AS src, isect0.`Sign` AS tgt
                          FROM `Sign` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"src\",\"src~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Sign`, ECps1.`Sign` AS `Sign1`
                                             FROM `Sign` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Sign`, `src`
                                                    FROM `Sign`
                                                    WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`src`=ECps1.`src`
                                           ) AS cp
                                      WHERE isect0.`Sign`=cp.`Sign` AND isect0.`Sign`=cp.`Sign1`) AND isect0.`Sign` IS NOT NULL AND isect0.`Sign` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni trg' =>
        array ( 'name' => 'uni trg'
              , 'ruleAdl' => 'trg~;trg |- I'
              , 'origin' => 'line 154, file "AST.adl"'
              , 'meaning' => 'trg[Sign\\*Concept] is univalent'
              , 'message' => 'trg[Sign\\*Concept] is niet univalent'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalization steps:
              //     -(-(trg~;trg) \\/ I)
              // <=> { De Morgan }
              //     trg~;trg/\\-I
              // 
              // Normalized complement (== violationsSQL): trg~;trg/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"trg~;trg\",\"-I\"] */
                          SELECT DISTINCT isect0.`trg` AS src, isect0.`trg1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"trg~\",\"trg\"] */
                                 
                                 SELECT DISTINCT ECps0.`trg`, ECps1.`trg` AS `trg1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Sign`, `trg`
                                        FROM `Sign`
                                        WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL
                                      ) AS ECps0,
                                      `Sign` AS ECps1
                                 WHERE ECps0.`Sign`=ECps1.`Sign`
                               ) AS isect0
                          WHERE isect0.`trg` <> isect0.`trg1` AND isect0.`trg` IS NOT NULL AND isect0.`trg1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot trg' =>
        array ( 'name' => 'tot trg'
              , 'ruleAdl' => 'I |- trg;trg~'
              , 'origin' => 'line 154, file "AST.adl"'
              , 'meaning' => 'trg[Sign\\*Concept] is totaal'
              , 'message' => 'trg[Sign\\*Concept] is niet totaal'
              , 'srcConcept' => 'Sign'
              , 'tgtConcept' => 'Sign'
              // Normalization steps:
              //     -(-I \\/ trg;trg~)
              // <=> { De Morgan }
              //     I/\\-(trg;trg~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(trg;trg~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(trg;trg~)\"] */
                          SELECT DISTINCT isect0.`Sign` AS src, isect0.`Sign` AS tgt
                          FROM `Sign` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"trg\",\"trg~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Sign`, ECps1.`Sign` AS `Sign1`
                                             FROM `Sign` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Sign`, `trg`
                                                    FROM `Sign`
                                                    WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`trg`=ECps1.`trg`
                                           ) AS cp
                                      WHERE isect0.`Sign`=cp.`Sign` AND isect0.`Sign`=cp.`Sign1`) AND isect0.`Sign` IS NOT NULL AND isect0.`Sign` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni pairvalue' =>
        array ( 'name' => 'uni pairvalue'
              , 'ruleAdl' => 'pairvalue~;pairvalue |- I'
              , 'origin' => 'line 163, file "AST.adl"'
              , 'meaning' => 'pairvalue[PairID\\*Pair] is univalent'
              , 'message' => 'pairvalue[PairID\\*Pair] is niet univalent'
              , 'srcConcept' => 'Pair'
              , 'tgtConcept' => 'Pair'
              // Normalization steps:
              //     -(-(pairvalue~;pairvalue) \\/ I)
              // <=> { De Morgan }
              //     pairvalue~;pairvalue/\\-I
              // 
              // Normalized complement (== violationsSQL): pairvalue~;pairvalue/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"pairvalue~;pairvalue\",\"-I\"] */
                          SELECT DISTINCT isect0.`pairvalue` AS src, isect0.`pairvalue1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"pairvalue~\",\"pairvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`pairvalue`, ECps1.`pairvalue` AS `pairvalue1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PairID`, `pairvalue`
                                        FROM `PairID`
                                        WHERE `PairID` IS NOT NULL AND `pairvalue` IS NOT NULL
                                      ) AS ECps0,
                                      `PairID` AS ECps1
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                               ) AS isect0
                          WHERE isect0.`pairvalue` <> isect0.`pairvalue1` AND isect0.`pairvalue` IS NOT NULL AND isect0.`pairvalue1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot pairvalue' =>
        array ( 'name' => 'tot pairvalue'
              , 'ruleAdl' => 'I |- pairvalue;pairvalue~'
              , 'origin' => 'line 163, file "AST.adl"'
              , 'meaning' => 'pairvalue[PairID\\*Pair] is totaal'
              , 'message' => 'pairvalue[PairID\\*Pair] is niet totaal'
              , 'srcConcept' => 'PairID'
              , 'tgtConcept' => 'PairID'
              // Normalization steps:
              //     -(-I \\/ pairvalue;pairvalue~)
              // <=> { De Morgan }
              //     I/\\-(pairvalue;pairvalue~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(pairvalue;pairvalue~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(pairvalue;pairvalue~)\"] */
                          SELECT DISTINCT isect0.`PairID` AS src, isect0.`PairID` AS tgt
                          FROM `PairID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"pairvalue\",\"pairvalue~\"] */
                                             
                                             SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                             FROM `PairID` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `PairID`, `pairvalue`
                                                    FROM `PairID`
                                                    WHERE `PairID` IS NOT NULL AND `pairvalue` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`pairvalue`=ECps1.`pairvalue`
                                           ) AS cp
                                      WHERE isect0.`PairID`=cp.`PairID` AND isect0.`PairID`=cp.`PairID1`) AND isect0.`PairID` IS NOT NULL AND isect0.`PairID` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni left' =>
        array ( 'name' => 'uni left'
              , 'ruleAdl' => 'left~;left |- I'
              , 'origin' => 'line 165, file "AST.adl"'
              , 'meaning' => 'left[Pair\\*AtomID] is univalent'
              , 'message' => 'left[Pair\\*AtomID] is niet univalent'
              , 'srcConcept' => 'AtomID'
              , 'tgtConcept' => 'AtomID'
              // Normalization steps:
              //     -(-(left~;left) \\/ I)
              // <=> { De Morgan }
              //     left~;left/\\-I
              // 
              // Normalized complement (== violationsSQL): left~;left/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"left~;left\",\"-I\"] */
                          SELECT DISTINCT isect0.`left` AS src, isect0.`left1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"left~\",\"left\"] */
                                 
                                 SELECT DISTINCT ECps0.`left`, ECps1.`left` AS `left1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Pair`, `left`
                                        FROM `Pair`
                                        WHERE `Pair` IS NOT NULL AND `left` IS NOT NULL
                                      ) AS ECps0,
                                      `Pair` AS ECps1
                                 WHERE ECps0.`Pair`=ECps1.`Pair`
                               ) AS isect0
                          WHERE isect0.`left` <> isect0.`left1` AND isect0.`left` IS NOT NULL AND isect0.`left1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot left' =>
        array ( 'name' => 'tot left'
              , 'ruleAdl' => 'I |- left;left~'
              , 'origin' => 'line 165, file "AST.adl"'
              , 'meaning' => 'left[Pair\\*AtomID] is totaal'
              , 'message' => 'left[Pair\\*AtomID] is niet totaal'
              , 'srcConcept' => 'Pair'
              , 'tgtConcept' => 'Pair'
              // Normalization steps:
              //     -(-I \\/ left;left~)
              // <=> { De Morgan }
              //     I/\\-(left;left~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(left;left~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(left;left~)\"] */
                          SELECT DISTINCT isect0.`Pair` AS src, isect0.`Pair` AS tgt
                          FROM `Pair` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"left\",\"left~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Pair`, ECps1.`Pair` AS `Pair1`
                                             FROM `Pair` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Pair`, `left`
                                                    FROM `Pair`
                                                    WHERE `Pair` IS NOT NULL AND `left` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`left`=ECps1.`left`
                                           ) AS cp
                                      WHERE isect0.`Pair`=cp.`Pair` AND isect0.`Pair`=cp.`Pair1`) AND isect0.`Pair` IS NOT NULL AND isect0.`Pair` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni right' =>
        array ( 'name' => 'uni right'
              , 'ruleAdl' => 'right~;right |- I'
              , 'origin' => 'line 167, file "AST.adl"'
              , 'meaning' => 'right[Pair\\*AtomID] is univalent'
              , 'message' => 'right[Pair\\*AtomID] is niet univalent'
              , 'srcConcept' => 'AtomID'
              , 'tgtConcept' => 'AtomID'
              // Normalization steps:
              //     -(-(right~;right) \\/ I)
              // <=> { De Morgan }
              //     right~;right/\\-I
              // 
              // Normalized complement (== violationsSQL): right~;right/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"right~;right\",\"-I\"] */
                          SELECT DISTINCT isect0.`right` AS src, isect0.`right1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"right~\",\"right\"] */
                                 
                                 SELECT DISTINCT ECps0.`right`, ECps1.`right` AS `right1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Pair`, `right`
                                        FROM `Pair`
                                        WHERE `Pair` IS NOT NULL AND `right` IS NOT NULL
                                      ) AS ECps0,
                                      `Pair` AS ECps1
                                 WHERE ECps0.`Pair`=ECps1.`Pair`
                               ) AS isect0
                          WHERE isect0.`right` <> isect0.`right1` AND isect0.`right` IS NOT NULL AND isect0.`right1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot right' =>
        array ( 'name' => 'tot right'
              , 'ruleAdl' => 'I |- right;right~'
              , 'origin' => 'line 167, file "AST.adl"'
              , 'meaning' => 'right[Pair\\*AtomID] is totaal'
              , 'message' => 'right[Pair\\*AtomID] is niet totaal'
              , 'srcConcept' => 'Pair'
              , 'tgtConcept' => 'Pair'
              // Normalization steps:
              //     -(-I \\/ right;right~)
              // <=> { De Morgan }
              //     I/\\-(right;right~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(right;right~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(right;right~)\"] */
                          SELECT DISTINCT isect0.`Pair` AS src, isect0.`Pair` AS tgt
                          FROM `Pair` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"right\",\"right~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Pair`, ECps1.`Pair` AS `Pair1`
                                             FROM `Pair` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Pair`, `right`
                                                    FROM `Pair`
                                                    WHERE `Pair` IS NOT NULL AND `right` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`right`=ECps1.`right`
                                           ) AS cp
                                      WHERE isect0.`Pair`=cp.`Pair` AND isect0.`Pair`=cp.`Pair1`) AND isect0.`Pair` IS NOT NULL AND isect0.`Pair` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni decnm' =>
        array ( 'name' => 'uni decnm'
              , 'ruleAdl' => 'decnm~;decnm |- I'
              , 'origin' => 'line 207, file "AST.adl"'
              , 'meaning' => 'decnm[Declaration\\*Varid] is univalent'
              , 'message' => 'decnm[Declaration\\*Varid] is niet univalent'
              , 'srcConcept' => 'Varid'
              , 'tgtConcept' => 'Varid'
              // Normalization steps:
              //     -(-(decnm~;decnm) \\/ I)
              // <=> { De Morgan }
              //     decnm~;decnm/\\-I
              // 
              // Normalized complement (== violationsSQL): decnm~;decnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decnm~;decnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`decnm` AS src, isect0.`decnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decnm~\",\"decnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`decnm`, ECps1.`decnm` AS `decnm1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decnm`
                                        FROM `Declaration`
                                        WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL
                                      ) AS ECps0,
                                      `Declaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decnm` <> isect0.`decnm1` AND isect0.`decnm` IS NOT NULL AND isect0.`decnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot decnm' =>
        array ( 'name' => 'tot decnm'
              , 'ruleAdl' => 'I |- decnm;decnm~'
              , 'origin' => 'line 207, file "AST.adl"'
              , 'meaning' => 'decnm[Declaration\\*Varid] is totaal'
              , 'message' => 'decnm[Declaration\\*Varid] is niet totaal'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalization steps:
              //     -(-I \\/ decnm;decnm~)
              // <=> { De Morgan }
              //     I/\\-(decnm;decnm~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(decnm;decnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(decnm;decnm~)\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`Declaration` AS tgt
                          FROM `Declaration` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decnm\",\"decnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps1.`Declaration` AS `Declaration1`
                                             FROM `Declaration` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Declaration`, `decnm`
                                                    FROM `Declaration`
                                                    WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`decnm`=ECps1.`decnm`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`Declaration`=cp.`Declaration1`) AND isect0.`Declaration` IS NOT NULL AND isect0.`Declaration` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni decsgn' =>
        array ( 'name' => 'uni decsgn'
              , 'ruleAdl' => 'decsgn~;decsgn |- I'
              , 'origin' => 'line 209, file "AST.adl"'
              , 'meaning' => 'decsgn[Declaration\\*Sign] is univalent'
              , 'message' => 'decsgn[Declaration\\*Sign] is niet univalent'
              , 'srcConcept' => 'Sign'
              , 'tgtConcept' => 'Sign'
              // Normalization steps:
              //     -(-(decsgn~;decsgn) \\/ I)
              // <=> { De Morgan }
              //     decsgn~;decsgn/\\-I
              // 
              // Normalized complement (== violationsSQL): decsgn~;decsgn/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decsgn~;decsgn\",\"-I\"] */
                          SELECT DISTINCT isect0.`decsgn` AS src, isect0.`decsgn1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn~\",\"decsgn\"] */
                                 
                                 SELECT DISTINCT ECps0.`decsgn`, ECps1.`decsgn` AS `decsgn1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decsgn`
                                        FROM `Declaration`
                                        WHERE `Declaration` IS NOT NULL AND `decsgn` IS NOT NULL
                                      ) AS ECps0,
                                      `Declaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decsgn` <> isect0.`decsgn1` AND isect0.`decsgn` IS NOT NULL AND isect0.`decsgn1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot decsgn' =>
        array ( 'name' => 'tot decsgn'
              , 'ruleAdl' => 'I |- decsgn;decsgn~'
              , 'origin' => 'line 209, file "AST.adl"'
              , 'meaning' => 'decsgn[Declaration\\*Sign] is totaal'
              , 'message' => 'decsgn[Declaration\\*Sign] is niet totaal'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalization steps:
              //     -(-I \\/ decsgn;decsgn~)
              // <=> { De Morgan }
              //     I/\\-(decsgn;decsgn~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(decsgn;decsgn~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(decsgn;decsgn~)\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`Declaration` AS tgt
                          FROM `Declaration` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decsgn\",\"decsgn~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps1.`Declaration` AS `Declaration1`
                                             FROM `Declaration` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Declaration`, `decsgn`
                                                    FROM `Declaration`
                                                    WHERE `Declaration` IS NOT NULL AND `decsgn` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`decsgn`=ECps1.`decsgn`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`Declaration`=cp.`Declaration1`) AND isect0.`Declaration` IS NOT NULL AND isect0.`Declaration` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj decprps' =>
        array ( 'name' => 'inj decprps'
              , 'ruleAdl' => 'decprps;decprps~ |- I'
              , 'origin' => 'line 211, file "AST.adl"'
              , 'meaning' => 'decprps[Declaration\\*PropertyRule] is injectief'
              , 'message' => 'decprps[Declaration\\*PropertyRule] is niet injectief'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalization steps:
              //     -(-(decprps;decprps~) \\/ I)
              // <=> { De Morgan }
              //     decprps;decprps~/\\-I
              // 
              // Normalized complement (== violationsSQL): decprps;decprps~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decprps;decprps~\",\"-I\"] */
                          SELECT DISTINCT isect0.`decprps` AS src, isect0.`decprps1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decprps\",\"decprps~\"] */
                                 
                                 SELECT DISTINCT ECps0.`decprps`, ECps1.`decprps` AS `decprps1`
                                 FROM `ADLid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `decprps`, `PropertyRule`
                                        FROM `ADLid`
                                        WHERE `decprps` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`PropertyRule`=ECps1.`PropertyRule`
                               ) AS isect0
                          WHERE isect0.`decprps` <> isect0.`decprps1` AND isect0.`decprps` IS NOT NULL AND isect0.`decprps1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot declaredthrough' =>
        array ( 'name' => 'tot declaredthrough'
              , 'ruleAdl' => 'I |- declaredthrough;declaredthrough~'
              , 'origin' => 'line 219, file "AST.adl"'
              , 'meaning' => 'declaredthrough[PropertyRule\\*Property] is totaal'
              , 'message' => 'declaredthrough[PropertyRule\\*Property] is niet totaal'
              , 'srcConcept' => 'PropertyRule'
              , 'tgtConcept' => 'PropertyRule'
              // Normalization steps:
              //     -(-I \\/ declaredthrough;declaredthrough~)
              // <=> { De Morgan }
              //     I/\\-(declaredthrough;declaredthrough~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(declaredthrough;declaredthrough~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(declaredthrough;declaredthrough~)\"] */
                          SELECT DISTINCT isect0.`PropertyRule` AS src, isect0.`PropertyRule` AS tgt
                          FROM `ADLid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"declaredthrough\",\"declaredthrough~\"] */
                                             
                                             SELECT DISTINCT ECps0.`PropertyRule`, ECps1.`PropertyRule` AS `PropertyRule1`
                                             FROM `declaredthrough` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `PropertyRule`, `Property`
                                                    FROM `declaredthrough`
                                                    WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Property`=ECps1.`Property`
                                           ) AS cp
                                      WHERE isect0.`PropertyRule`=cp.`PropertyRule` AND isect0.`PropertyRule`=cp.`PropertyRule1`) AND isect0.`PropertyRule` IS NOT NULL AND isect0.`PropertyRule` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni decprL' =>
        array ( 'name' => 'uni decprL'
              , 'ruleAdl' => 'decprL~;decprL |- I'
              , 'origin' => 'line 222, file "AST.adl"'
              , 'meaning' => 'decprL[Declaration\\*String] is univalent'
              , 'message' => 'decprL[Declaration\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalization steps:
              //     -(-(decprL~;decprL) \\/ I)
              // <=> { De Morgan }
              //     decprL~;decprL/\\-I
              // 
              // Normalized complement (== violationsSQL): decprL~;decprL/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decprL~;decprL\",\"-I\"] */
                          SELECT DISTINCT isect0.`decprL` AS src, isect0.`decprL1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decprL~\",\"decprL\"] */
                                 
                                 SELECT DISTINCT ECps0.`decprL`, ECps1.`decprL` AS `decprL1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decprL`
                                        FROM `Declaration`
                                        WHERE `Declaration` IS NOT NULL AND `decprL` IS NOT NULL
                                      ) AS ECps0,
                                      `Declaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decprL` <> isect0.`decprL1` AND isect0.`decprL` IS NOT NULL AND isect0.`decprL1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni decprM' =>
        array ( 'name' => 'uni decprM'
              , 'ruleAdl' => 'decprM~;decprM |- I'
              , 'origin' => 'line 223, file "AST.adl"'
              , 'meaning' => 'decprM[Declaration\\*String] is univalent'
              , 'message' => 'decprM[Declaration\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalization steps:
              //     -(-(decprM~;decprM) \\/ I)
              // <=> { De Morgan }
              //     decprM~;decprM/\\-I
              // 
              // Normalized complement (== violationsSQL): decprM~;decprM/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decprM~;decprM\",\"-I\"] */
                          SELECT DISTINCT isect0.`decprM` AS src, isect0.`decprM1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decprM~\",\"decprM\"] */
                                 
                                 SELECT DISTINCT ECps0.`decprM`, ECps1.`decprM` AS `decprM1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decprM`
                                        FROM `Declaration`
                                        WHERE `Declaration` IS NOT NULL AND `decprM` IS NOT NULL
                                      ) AS ECps0,
                                      `Declaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decprM` <> isect0.`decprM1` AND isect0.`decprM` IS NOT NULL AND isect0.`decprM1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni decprR' =>
        array ( 'name' => 'uni decprR'
              , 'ruleAdl' => 'decprR~;decprR |- I'
              , 'origin' => 'line 224, file "AST.adl"'
              , 'meaning' => 'decprR[Declaration\\*String] is univalent'
              , 'message' => 'decprR[Declaration\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalization steps:
              //     -(-(decprR~;decprR) \\/ I)
              // <=> { De Morgan }
              //     decprR~;decprR/\\-I
              // 
              // Normalized complement (== violationsSQL): decprR~;decprR/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decprR~;decprR\",\"-I\"] */
                          SELECT DISTINCT isect0.`decprR` AS src, isect0.`decprR1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decprR~\",\"decprR\"] */
                                 
                                 SELECT DISTINCT ECps0.`decprR`, ECps1.`decprR` AS `decprR1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decprR`
                                        FROM `Declaration`
                                        WHERE `Declaration` IS NOT NULL AND `decprR` IS NOT NULL
                                      ) AS ECps0,
                                      `Declaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decprR` <> isect0.`decprR1` AND isect0.`decprR` IS NOT NULL AND isect0.`decprR1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni PropertyRule' =>
        array ( 'name' => 'uni PropertyRule'
              , 'ruleAdl' => 'PropertyRule~;PropertyRule |- I'
              , 'origin' => 'line 216, file "AST.adl"'
              , 'meaning' => 'PropertyRule[PropertyRule\\*Rule] is univalent'
              , 'message' => 'PropertyRule[PropertyRule\\*Rule] is niet univalent'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Rule'
              // Normalization steps:
              //     -(-(PropertyRule~;PropertyRule) \\/ I)
              // <=> { De Morgan }
              //     PropertyRule~;PropertyRule/\\-I
              // 
              // Normalized complement (== violationsSQL): PropertyRule~;PropertyRule/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"PropertyRule~;PropertyRule\",\"-I\"] */
                          SELECT DISTINCT isect0.`rrnm` AS src, isect0.`rrnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"PropertyRule~\",\"PropertyRule\"] */
                                 
                                 SELECT DISTINCT ECps0.`rrnm`, ECps1.`rrnm` AS `rrnm1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PropertyRule`, `rrnm`
                                        FROM `ADLid`
                                        WHERE `PropertyRule` IS NOT NULL AND `rrnm` IS NOT NULL
                                      ) AS ECps0,
                                      `ADLid` AS ECps1
                                 WHERE ECps0.`PropertyRule`=ECps1.`PropertyRule`
                               ) AS isect0
                          WHERE isect0.`rrnm` <> isect0.`rrnm1` AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot PropertyRule' =>
        array ( 'name' => 'tot PropertyRule'
              , 'ruleAdl' => 'I |- PropertyRule;PropertyRule~'
              , 'origin' => 'line 216, file "AST.adl"'
              , 'meaning' => 'PropertyRule[PropertyRule\\*Rule] is totaal'
              , 'message' => 'PropertyRule[PropertyRule\\*Rule] is niet totaal'
              , 'srcConcept' => 'PropertyRule'
              , 'tgtConcept' => 'PropertyRule'
              // Normalization steps:
              //     -(-I \\/ PropertyRule;PropertyRule~)
              // <=> { De Morgan }
              //     I/\\-(PropertyRule;PropertyRule~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(PropertyRule;PropertyRule~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(PropertyRule;PropertyRule~)\"] */
                          SELECT DISTINCT isect0.`PropertyRule` AS src, isect0.`PropertyRule` AS tgt
                          FROM `ADLid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"PropertyRule\",\"PropertyRule~\"] */
                                             
                                             SELECT DISTINCT ECps0.`PropertyRule`, ECps1.`PropertyRule` AS `PropertyRule1`
                                             FROM `ADLid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `PropertyRule`, `rrnm`
                                                    FROM `ADLid`
                                                    WHERE `PropertyRule` IS NOT NULL AND `rrnm` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`rrnm`=ECps1.`rrnm`
                                           ) AS cp
                                      WHERE isect0.`PropertyRule`=cp.`PropertyRule` AND isect0.`PropertyRule`=cp.`PropertyRule1`) AND isect0.`PropertyRule` IS NOT NULL AND isect0.`PropertyRule` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj PropertyRule' =>
        array ( 'name' => 'inj PropertyRule'
              , 'ruleAdl' => 'PropertyRule;PropertyRule~ |- I'
              , 'origin' => 'line 216, file "AST.adl"'
              , 'meaning' => 'PropertyRule[PropertyRule\\*Rule] is injectief'
              , 'message' => 'PropertyRule[PropertyRule\\*Rule] is niet injectief'
              , 'srcConcept' => 'PropertyRule'
              , 'tgtConcept' => 'PropertyRule'
              // Normalization steps:
              //     -(-(PropertyRule;PropertyRule~) \\/ I)
              // <=> { De Morgan }
              //     PropertyRule;PropertyRule~/\\-I
              // 
              // Normalized complement (== violationsSQL): PropertyRule;PropertyRule~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"PropertyRule;PropertyRule~\",\"-I\"] */
                          SELECT DISTINCT isect0.`PropertyRule` AS src, isect0.`PropertyRule1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"PropertyRule\",\"PropertyRule~\"] */
                                 
                                 SELECT DISTINCT ECps0.`PropertyRule`, ECps1.`PropertyRule` AS `PropertyRule1`
                                 FROM `ADLid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PropertyRule`, `rrnm`
                                        FROM `ADLid`
                                        WHERE `PropertyRule` IS NOT NULL AND `rrnm` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`rrnm`=ECps1.`rrnm`
                               ) AS isect0
                          WHERE isect0.`PropertyRule` <> isect0.`PropertyRule1` AND isect0.`PropertyRule` IS NOT NULL AND isect0.`PropertyRule1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni exprvalue' =>
        array ( 'name' => 'uni exprvalue'
              , 'ruleAdl' => 'exprvalue~;exprvalue |- I'
              , 'origin' => 'line 286, file "AST.adl"'
              , 'meaning' => 'exprvalue[ExpressionID\\*Expression] is univalent'
              , 'message' => 'exprvalue[ExpressionID\\*Expression] is niet univalent'
              , 'srcConcept' => 'Expression'
              , 'tgtConcept' => 'Expression'
              // Normalization steps:
              //     -(-(exprvalue~;exprvalue) \\/ I)
              // <=> { De Morgan }
              //     exprvalue~;exprvalue/\\-I
              // 
              // Normalized complement (== violationsSQL): exprvalue~;exprvalue/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"exprvalue~;exprvalue\",\"-I\"] */
                          SELECT DISTINCT isect0.`exprvalue` AS src, isect0.`exprvalue1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"exprvalue~\",\"exprvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`exprvalue`, ECps1.`exprvalue` AS `exprvalue1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ExpressionID`, `exprvalue`
                                        FROM `ExpressionID`
                                        WHERE `ExpressionID` IS NOT NULL AND `exprvalue` IS NOT NULL
                                      ) AS ECps0,
                                      `ExpressionID` AS ECps1
                                 WHERE ECps0.`ExpressionID`=ECps1.`ExpressionID`
                               ) AS isect0
                          WHERE isect0.`exprvalue` <> isect0.`exprvalue1` AND isect0.`exprvalue` IS NOT NULL AND isect0.`exprvalue1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot exprvalue' =>
        array ( 'name' => 'tot exprvalue'
              , 'ruleAdl' => 'I |- exprvalue;exprvalue~'
              , 'origin' => 'line 286, file "AST.adl"'
              , 'meaning' => 'exprvalue[ExpressionID\\*Expression] is totaal'
              , 'message' => 'exprvalue[ExpressionID\\*Expression] is niet totaal'
              , 'srcConcept' => 'ExpressionID'
              , 'tgtConcept' => 'ExpressionID'
              // Normalization steps:
              //     -(-I \\/ exprvalue;exprvalue~)
              // <=> { De Morgan }
              //     I/\\-(exprvalue;exprvalue~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(exprvalue;exprvalue~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(exprvalue;exprvalue~)\"] */
                          SELECT DISTINCT isect0.`ExpressionID` AS src, isect0.`ExpressionID` AS tgt
                          FROM `ExpressionID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"exprvalue\",\"exprvalue~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ExpressionID`, ECps1.`ExpressionID` AS `ExpressionID1`
                                             FROM `ExpressionID` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ExpressionID`, `exprvalue`
                                                    FROM `ExpressionID`
                                                    WHERE `ExpressionID` IS NOT NULL AND `exprvalue` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`exprvalue`=ECps1.`exprvalue`
                                           ) AS cp
                                      WHERE isect0.`ExpressionID`=cp.`ExpressionID` AND isect0.`ExpressionID`=cp.`ExpressionID1`) AND isect0.`ExpressionID` IS NOT NULL AND isect0.`ExpressionID` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni relnm' =>
        array ( 'name' => 'uni relnm'
              , 'ruleAdl' => 'relnm~;relnm |- I'
              , 'origin' => 'line 293, file "AST.adl"'
              , 'meaning' => 'relnm[Relation\\*Varid] is univalent'
              , 'message' => 'relnm[Relation\\*Varid] is niet univalent'
              , 'srcConcept' => 'Varid'
              , 'tgtConcept' => 'Varid'
              // Normalization steps:
              //     -(-(relnm~;relnm) \\/ I)
              // <=> { De Morgan }
              //     relnm~;relnm/\\-I
              // 
              // Normalized complement (== violationsSQL): relnm~;relnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"relnm~;relnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`relnm` AS src, isect0.`relnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"relnm~\",\"relnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`relnm`, ECps1.`relnm` AS `relnm1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Relation`, `relnm`
                                        FROM `Relation`
                                        WHERE `Relation` IS NOT NULL AND `relnm` IS NOT NULL
                                      ) AS ECps0,
                                      `Relation` AS ECps1
                                 WHERE ECps0.`Relation`=ECps1.`Relation`
                               ) AS isect0
                          WHERE isect0.`relnm` <> isect0.`relnm1` AND isect0.`relnm` IS NOT NULL AND isect0.`relnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot relnm' =>
        array ( 'name' => 'tot relnm'
              , 'ruleAdl' => 'I |- relnm;relnm~'
              , 'origin' => 'line 293, file "AST.adl"'
              , 'meaning' => 'relnm[Relation\\*Varid] is totaal'
              , 'message' => 'relnm[Relation\\*Varid] is niet totaal'
              , 'srcConcept' => 'Relation'
              , 'tgtConcept' => 'Relation'
              // Normalization steps:
              //     -(-I \\/ relnm;relnm~)
              // <=> { De Morgan }
              //     I/\\-(relnm;relnm~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(relnm;relnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(relnm;relnm~)\"] */
                          SELECT DISTINCT isect0.`Relation` AS src, isect0.`Relation` AS tgt
                          FROM `Relation` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"relnm\",\"relnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Relation`, ECps1.`Relation` AS `Relation1`
                                             FROM `Relation` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Relation`, `relnm`
                                                    FROM `Relation`
                                                    WHERE `Relation` IS NOT NULL AND `relnm` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`relnm`=ECps1.`relnm`
                                           ) AS cp
                                      WHERE isect0.`Relation`=cp.`Relation` AND isect0.`Relation`=cp.`Relation1`) AND isect0.`Relation` IS NOT NULL AND isect0.`Relation` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni relsgn' =>
        array ( 'name' => 'uni relsgn'
              , 'ruleAdl' => 'relsgn~;relsgn |- I'
              , 'origin' => 'line 294, file "AST.adl"'
              , 'meaning' => 'relsgn[Relation\\*Sign] is univalent'
              , 'message' => 'relsgn[Relation\\*Sign] is niet univalent'
              , 'srcConcept' => 'Sign'
              , 'tgtConcept' => 'Sign'
              // Normalization steps:
              //     -(-(relsgn~;relsgn) \\/ I)
              // <=> { De Morgan }
              //     relsgn~;relsgn/\\-I
              // 
              // Normalized complement (== violationsSQL): relsgn~;relsgn/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"relsgn~;relsgn\",\"-I\"] */
                          SELECT DISTINCT isect0.`relsgn` AS src, isect0.`relsgn1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"relsgn~\",\"relsgn\"] */
                                 
                                 SELECT DISTINCT ECps0.`relsgn`, ECps1.`relsgn` AS `relsgn1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Relation`, `relsgn`
                                        FROM `Relation`
                                        WHERE `Relation` IS NOT NULL AND `relsgn` IS NOT NULL
                                      ) AS ECps0,
                                      `Relation` AS ECps1
                                 WHERE ECps0.`Relation`=ECps1.`Relation`
                               ) AS isect0
                          WHERE isect0.`relsgn` <> isect0.`relsgn1` AND isect0.`relsgn` IS NOT NULL AND isect0.`relsgn1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot relsgn' =>
        array ( 'name' => 'tot relsgn'
              , 'ruleAdl' => 'I |- relsgn;relsgn~'
              , 'origin' => 'line 294, file "AST.adl"'
              , 'meaning' => 'relsgn[Relation\\*Sign] is totaal'
              , 'message' => 'relsgn[Relation\\*Sign] is niet totaal'
              , 'srcConcept' => 'Relation'
              , 'tgtConcept' => 'Relation'
              // Normalization steps:
              //     -(-I \\/ relsgn;relsgn~)
              // <=> { De Morgan }
              //     I/\\-(relsgn;relsgn~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(relsgn;relsgn~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(relsgn;relsgn~)\"] */
                          SELECT DISTINCT isect0.`Relation` AS src, isect0.`Relation` AS tgt
                          FROM `Relation` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"relsgn\",\"relsgn~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Relation`, ECps1.`Relation` AS `Relation1`
                                             FROM `Relation` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Relation`, `relsgn`
                                                    FROM `Relation`
                                                    WHERE `Relation` IS NOT NULL AND `relsgn` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`relsgn`=ECps1.`relsgn`
                                           ) AS cp
                                      WHERE isect0.`Relation`=cp.`Relation` AND isect0.`Relation`=cp.`Relation1`) AND isect0.`Relation` IS NOT NULL AND isect0.`Relation` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni reldcl' =>
        array ( 'name' => 'uni reldcl'
              , 'ruleAdl' => 'reldcl~;reldcl |- I'
              , 'origin' => 'line 295, file "AST.adl"'
              , 'meaning' => 'reldcl[Relation\\*Declaration] is univalent'
              , 'message' => 'reldcl[Relation\\*Declaration] is niet univalent'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalization steps:
              //     -(-(reldcl~;reldcl) \\/ I)
              // <=> { De Morgan }
              //     reldcl~;reldcl/\\-I
              // 
              // Normalized complement (== violationsSQL): reldcl~;reldcl/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"reldcl~;reldcl\",\"-I\"] */
                          SELECT DISTINCT isect0.`reldcl` AS src, isect0.`reldcl1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"reldcl~\",\"reldcl\"] */
                                 
                                 SELECT DISTINCT ECps0.`reldcl`, ECps1.`reldcl` AS `reldcl1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Relation`, `reldcl`
                                        FROM `Relation`
                                        WHERE `Relation` IS NOT NULL AND `reldcl` IS NOT NULL
                                      ) AS ECps0,
                                      `Relation` AS ECps1
                                 WHERE ECps0.`Relation`=ECps1.`Relation`
                               ) AS isect0
                          WHERE isect0.`reldcl` <> isect0.`reldcl1` AND isect0.`reldcl` IS NOT NULL AND isect0.`reldcl1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot reldcl' =>
        array ( 'name' => 'tot reldcl'
              , 'ruleAdl' => 'I |- reldcl;reldcl~'
              , 'origin' => 'line 295, file "AST.adl"'
              , 'meaning' => 'reldcl[Relation\\*Declaration] is totaal'
              , 'message' => 'reldcl[Relation\\*Declaration] is niet totaal'
              , 'srcConcept' => 'Relation'
              , 'tgtConcept' => 'Relation'
              // Normalization steps:
              //     -(-I \\/ reldcl;reldcl~)
              // <=> { De Morgan }
              //     I/\\-(reldcl;reldcl~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(reldcl;reldcl~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(reldcl;reldcl~)\"] */
                          SELECT DISTINCT isect0.`Relation` AS src, isect0.`Relation` AS tgt
                          FROM `Relation` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"reldcl\",\"reldcl~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Relation`, ECps1.`Relation` AS `Relation1`
                                             FROM `Relation` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Relation`, `reldcl`
                                                    FROM `Relation`
                                                    WHERE `Relation` IS NOT NULL AND `reldcl` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`reldcl`=ECps1.`reldcl`
                                           ) AS cp
                                      WHERE isect0.`Relation`=cp.`Relation` AND isect0.`Relation`=cp.`Relation1`) AND isect0.`Relation` IS NOT NULL AND isect0.`Relation` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj rrnm' =>
        array ( 'name' => 'inj rrnm'
              , 'ruleAdl' => 'rrnm;rrnm~ |- I'
              , 'origin' => 'line 324, file "AST.adl"'
              , 'meaning' => 'rrnm[Rule\\*ADLid] is injectief'
              , 'message' => 'rrnm[Rule\\*ADLid] is niet injectief'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Rule'
              // Normalization steps:
              //     -(-(rrnm;rrnm~) \\/ I)
              // <=> { De Morgan }
              //     rrnm;rrnm~/\\-I
              // 
              // Normalized complement (== violationsSQL): rrnm;rrnm~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrnm;rrnm~\",\"-I\"] */
                          SELECT DISTINCT isect0.`rrnm` AS src, isect0.`rrnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrnm\",\"rrnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`rrnm`, ECps1.`rrnm` AS `rrnm1`
                                 FROM `ADLid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `rrnm`, `ADLid`
                                        FROM `ADLid`
                                        WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`ADLid`=ECps1.`ADLid`
                               ) AS isect0
                          WHERE isect0.`rrnm` <> isect0.`rrnm1` AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni rrnm' =>
        array ( 'name' => 'uni rrnm'
              , 'ruleAdl' => 'rrnm~;rrnm |- I'
              , 'origin' => 'line 324, file "AST.adl"'
              , 'meaning' => 'rrnm[Rule\\*ADLid] is univalent'
              , 'message' => 'rrnm[Rule\\*ADLid] is niet univalent'
              , 'srcConcept' => 'ADLid'
              , 'tgtConcept' => 'ADLid'
              // Normalization steps:
              //     -(-(rrnm~;rrnm) \\/ I)
              // <=> { De Morgan }
              //     rrnm~;rrnm/\\-I
              // 
              // Normalized complement (== violationsSQL): rrnm~;rrnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrnm~;rrnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`ADLid` AS src, isect0.`ADLid1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrnm~\",\"rrnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`ADLid`, ECps1.`ADLid` AS `ADLid1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `rrnm`, `ADLid`
                                        FROM `ADLid`
                                        WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL
                                      ) AS ECps0,
                                      `ADLid` AS ECps1
                                 WHERE ECps0.`rrnm`=ECps1.`rrnm`
                               ) AS isect0
                          WHERE isect0.`ADLid` <> isect0.`ADLid1` AND isect0.`ADLid` IS NOT NULL AND isect0.`ADLid1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot rrnm' =>
        array ( 'name' => 'tot rrnm'
              , 'ruleAdl' => 'I |- rrnm;rrnm~'
              , 'origin' => 'line 324, file "AST.adl"'
              , 'meaning' => 'rrnm[Rule\\*ADLid] is totaal'
              , 'message' => 'rrnm[Rule\\*ADLid] is niet totaal'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Rule'
              // Normalization steps:
              //     -(-I \\/ rrnm;rrnm~)
              // <=> { De Morgan }
              //     I/\\-(rrnm;rrnm~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(rrnm;rrnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(rrnm;rrnm~)\"] */
                          SELECT DISTINCT isect0.`rrnm` AS src, isect0.`rrnm` AS tgt
                          FROM `ADLid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"rrnm\",\"rrnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`rrnm`, ECps1.`rrnm` AS `rrnm1`
                                             FROM `ADLid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `rrnm`, `ADLid`
                                                    FROM `ADLid`
                                                    WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`ADLid`=ECps1.`ADLid`
                                           ) AS cp
                                      WHERE isect0.`rrnm`=cp.`rrnm` AND isect0.`rrnm`=cp.`rrnm1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni rrexp' =>
        array ( 'name' => 'uni rrexp'
              , 'ruleAdl' => 'rrexp~;rrexp |- I'
              , 'origin' => 'line 326, file "AST.adl"'
              , 'meaning' => 'rrexp[Rule\\*ExpressionID] is univalent'
              , 'message' => 'rrexp[Rule\\*ExpressionID] is niet univalent'
              , 'srcConcept' => 'ExpressionID'
              , 'tgtConcept' => 'ExpressionID'
              // Normalization steps:
              //     -(-(rrexp~;rrexp) \\/ I)
              // <=> { De Morgan }
              //     rrexp~;rrexp/\\-I
              // 
              // Normalized complement (== violationsSQL): rrexp~;rrexp/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrexp~;rrexp\",\"-I\"] */
                          SELECT DISTINCT isect0.`rrexp` AS src, isect0.`rrexp1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrexp~\",\"rrexp\"] */
                                 
                                 SELECT DISTINCT ECps0.`rrexp`, ECps1.`rrexp` AS `rrexp1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `rrnm`, `rrexp`
                                        FROM `ADLid`
                                        WHERE `rrnm` IS NOT NULL AND `rrexp` IS NOT NULL
                                      ) AS ECps0,
                                      `ADLid` AS ECps1
                                 WHERE ECps0.`rrnm`=ECps1.`rrnm`
                               ) AS isect0
                          WHERE isect0.`rrexp` <> isect0.`rrexp1` AND isect0.`rrexp` IS NOT NULL AND isect0.`rrexp1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot rrexp' =>
        array ( 'name' => 'tot rrexp'
              , 'ruleAdl' => 'I |- rrexp;rrexp~'
              , 'origin' => 'line 326, file "AST.adl"'
              , 'meaning' => 'rrexp[Rule\\*ExpressionID] is totaal'
              , 'message' => 'rrexp[Rule\\*ExpressionID] is niet totaal'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Rule'
              // Normalization steps:
              //     -(-I \\/ rrexp;rrexp~)
              // <=> { De Morgan }
              //     I/\\-(rrexp;rrexp~)
              // 
              // Normalized complement (== violationsSQL): I/\\-(rrexp;rrexp~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(rrexp;rrexp~)\"] */
                          SELECT DISTINCT isect0.`rrnm` AS src, isect0.`rrnm` AS tgt
                          FROM `ADLid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"rrexp\",\"rrexp~\"] */
                                             
                                             SELECT DISTINCT ECps0.`rrnm`, ECps1.`rrnm` AS `rrnm1`
                                             FROM `ADLid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `rrnm`, `rrexp`
                                                    FROM `ADLid`
                                                    WHERE `rrnm` IS NOT NULL AND `rrexp` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`rrexp`=ECps1.`rrexp`
                                           ) AS cp
                                      WHERE isect0.`rrnm`=cp.`rrnm` AND isect0.`rrnm`=cp.`rrnm1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    );

$invariantRuleNames = array ('uni compilererror', 'uni filename', 'tot filename', 'uni filepath', 'uni sourcefile', 'tot sourcefile', 'uni applyto', 'tot applyto', 'uni functionname', 'tot functionname', 'uni operation', 'tot operation', 'uni newfile', 'tot newfile', 'uni savepopulation', 'tot savepopulation', 'uni savecontext', 'tot savecontext', 'uni AdlFile', 'tot AdlFile', 'inj AdlFile', 'uni NewAdlFile', 'tot NewAdlFile', 'inj NewAdlFile', 'uni SavePopFile', 'tot SavePopFile', 'inj SavePopFile', 'uni SaveAdlFile', 'tot SaveAdlFile', 'inj SaveAdlFile', 'uni countrules', 'uni countdecls', 'uni countcpts', 'uni ptpic', 'uni cptpic', 'uni rrpic', 'uni Violation', 'tot Violation', 'inj Violation', 'inj ctxnm', 'uni ctxnm', 'tot ctxnm', 'inj ptnm', 'uni ptnm', 'tot ptnm', 'uni gengen', 'tot gengen', 'uni genspc', 'tot genspc', 'inj cptnm', 'uni cptnm', 'tot cptnm', 'inj cptos', 'uni atomvalue', 'tot atomvalue', 'uni src', 'tot src', 'uni trg', 'tot trg', 'uni pairvalue', 'tot pairvalue', 'uni left', 'tot left', 'uni right', 'tot right', 'uni decnm', 'tot decnm', 'uni decsgn', 'tot decsgn', 'inj decprps', 'tot declaredthrough', 'uni decprL', 'uni decprM', 'uni decprR', 'uni PropertyRule', 'tot PropertyRule', 'inj PropertyRule', 'uni exprvalue', 'tot exprvalue', 'uni relnm', 'tot relnm', 'uni relsgn', 'tot relsgn', 'uni reldcl', 'tot reldcl', 'inj rrnm', 'uni rrnm', 'tot rrnm', 'uni rrexp', 'tot rrexp', 'uniek path/filename', 'key gen', 'key pair', 'key decl', 'property enum', 'typed domain', 'typed codomain', 'rel name is decl name');

$allRoles =
  array
    ( array ( 'name' => 'Student'
            , 'ruleNames' => array ('conceptwijzigingen2', 'relatiewijzigingen', 'parseoftypefout', 'specgenatoom', 'overtredingen')
            )
    , array ( 'name' => 'Admin'
            , 'ruleNames' => array ('dummy')
            )
    );

$allKeys =
  array
    (   array ( 'label' => 'Image'
              , 'concept' => 'Image'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<img src=\'')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: imageurl
                            , 'expSQL' =>
                                'SELECT DISTINCT `Image` AS src, `URL` AS tgt
                                 FROM `imageurl`
                                 WHERE `Image` IS NOT NULL AND `URL` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    )
            )
    ,   array ( 'label' => 'File'
              , 'concept' => 'File'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php?file=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: filepath
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `filepath` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL' )
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: filename
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: filename
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'G'
              , 'concept' => 'G'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php?operation=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: operation
                            , 'expSQL' =>
                                'SELECT DISTINCT `G` AS src, `operation` AS tgt
                                 FROM `G`
                                 WHERE `G` IS NOT NULL AND `operation` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '&file=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '4' // key exp: applyto;filepath
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"applyto\",\"filepath\"] */
                                 
                                 SELECT DISTINCT ECps0.`G` AS src, ECps1.`filepath` AS tgt
                                 FROM `G` AS ECps0,
                                      `File` AS ECps1
                                 WHERE ECps0.`applyto`=ECps1.`File`' )
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: applyto;filename
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"applyto\",\"filename\"] */
                                 
                                 SELECT DISTINCT ECps0.`G` AS src, ECps1.`filename` AS tgt
                                 FROM `G` AS ECps0,
                                      `File` AS ECps1
                                 WHERE ECps0.`applyto`=ECps1.`File`' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '7' // key exp: functionname
                            , 'expSQL' =>
                                'SELECT DISTINCT `G` AS src, `functionname` AS tgt
                                 FROM `G`
                                 WHERE `G` IS NOT NULL AND `functionname` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'NewAdlFile'
              , 'concept' => 'NewAdlFile'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: filename[NewAdlFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'SavePopFile'
              , 'concept' => 'SavePopFile'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php?operation=4&file=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: filepath[SavePopFile*FilePath]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filepath\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filepath` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL' )
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: filename[SavePopFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: filename[SavePopFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'SaveAdlFile'
              , 'concept' => 'SaveAdlFile'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php?operation=2&file=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: filepath[SaveAdlFile*FilePath]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filepath\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filepath` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL' )
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: filename[SaveAdlFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: filename[SaveAdlFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `File`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'Context'
              , 'concept' => 'Context'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: ctxnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `ctxnm` AS src, `Conid` AS tgt
                                 FROM `Conid`
                                 WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Pattern'
              , 'concept' => 'Pattern'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: ptnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `ptnm` AS src, `Conid` AS tgt
                                 FROM `Conid`
                                 WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Gen'
              , 'concept' => 'Gen'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'SPEC ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: genspc;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"genspc\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Gen` AS src, ECps1.`Conid` AS tgt
                                 FROM `Gen` AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`genspc`=ECps1.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' ISA ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '4' // key exp: gengen;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"gengen\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Gen` AS src, ECps1.`Conid` AS tgt
                                 FROM `Gen` AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`gengen`=ECps1.`cptnm`' )
                    )
            )
    ,   array ( 'label' => 'Concept'
              , 'concept' => 'Concept'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: cptnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `cptnm` AS src, `Conid` AS tgt
                                 FROM `Conid`
                                 WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'AtomID'
              , 'concept' => 'AtomID'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: atomvalue
                            , 'expSQL' =>
                                'SELECT DISTINCT `AtomID` AS src, `atomvalue` AS tgt
                                 FROM `AtomID`
                                 WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' :: ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: cptos~;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptos~\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`AtomID` AS src, ECps1.`Conid` AS tgt
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptos`, `AtomID`
                                        FROM `AtomID`
                                        WHERE `cptos` IS NOT NULL AND `AtomID` IS NOT NULL
                                      ) AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`cptos`=ECps1.`cptnm`' )
                    )
            )
    ,   array ( 'label' => 'Sign'
              , 'concept' => 'Sign'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: src;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"src\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Sign` AS src, ECps1.`Conid` AS tgt
                                 FROM `Sign` AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`src`=ECps1.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' * ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: trg;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"trg\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Sign` AS src, ECps1.`Conid` AS tgt
                                 FROM `Sign` AS ECps0,
                                      `Conid` AS ECps1
                                 WHERE ECps0.`trg`=ECps1.`cptnm`' )
                    )
            )
    ,   array ( 'label' => 'PairID'
              , 'concept' => 'PairID'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: pairvalue;left;atomvalue
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"pairvalue\",\"left\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`PairID` AS src, ECps2.`atomvalue` AS tgt
                                 FROM `PairID` AS ECps0,
                                      `Pair` AS ECps1,
                                      `AtomID` AS ECps2
                                 WHERE ECps0.`pairvalue`=ECps1.`Pair`
                                   AND ECps1.`left`=ECps2.`AtomID`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' * ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: pairvalue;right;atomvalue
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"pairvalue\",\"right\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`PairID` AS src, ECps2.`atomvalue` AS tgt
                                 FROM `PairID` AS ECps0,
                                      `Pair` AS ECps1,
                                      `AtomID` AS ECps2
                                 WHERE ECps0.`pairvalue`=ECps1.`Pair`
                                   AND ECps1.`right`=ECps2.`AtomID`' )
                    )
            )
    ,   array ( 'label' => 'Pair'
              , 'concept' => 'Pair'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: left;atomvalue
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"left\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`Pair` AS src, ECps1.`atomvalue` AS tgt
                                 FROM `Pair` AS ECps0,
                                      `AtomID` AS ECps1
                                 WHERE ECps0.`left`=ECps1.`AtomID`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' * ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: right;atomvalue
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"right\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`Pair` AS src, ECps1.`atomvalue` AS tgt
                                 FROM `Pair` AS ECps0,
                                      `AtomID` AS ECps1
                                 WHERE ECps0.`right`=ECps1.`AtomID`' )
                    )
            )
    ,   array ( 'label' => 'Declaration'
              , 'concept' => 'Declaration'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: decnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `Declaration` AS src, `decnm` AS tgt
                                 FROM `Declaration`
                                 WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' :: ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: decsgn;src;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"src\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration` AS src, ECps2.`Conid` AS tgt
                                 FROM `Declaration` AS ECps0,
                                      `Sign` AS ECps1,
                                      `Conid` AS ECps2
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`
                                   AND ECps1.`src`=ECps2.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' * ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: decsgn;trg;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"trg\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration` AS src, ECps2.`Conid` AS tgt
                                 FROM `Declaration` AS ECps0,
                                      `Sign` AS ECps1,
                                      `Conid` AS ECps2
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`
                                   AND ECps1.`trg`=ECps2.`cptnm`' )
                    )
            )
    ,   array ( 'label' => 'PropertyRule'
              , 'concept' => 'PropertyRule'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: rrnm[PropertyRule*ADLid]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"rrnm\" ) _ */
                                 SELECT DISTINCT `rrnm` AS src, `ADLid` AS tgt
                                 FROM `ADLid`
                                 WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'ExpressionID'
              , 'concept' => 'ExpressionID'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: exprvalue
                            , 'expSQL' =>
                                'SELECT DISTINCT `ExpressionID` AS src, `exprvalue` AS tgt
                                 FROM `ExpressionID`
                                 WHERE `ExpressionID` IS NOT NULL AND `exprvalue` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Relation'
              , 'concept' => 'Relation'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: relnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `Relation` AS src, `relnm` AS tgt
                                 FROM `Relation`
                                 WHERE `Relation` IS NOT NULL AND `relnm` IS NOT NULL' )
                    , array ( 'segmentType' => 'Text', 'Text' => '[')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: relsgn;src;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"relsgn\",\"src\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Relation` AS src, ECps2.`Conid` AS tgt
                                 FROM `Relation` AS ECps0,
                                      `Sign` AS ECps1,
                                      `Conid` AS ECps2
                                 WHERE ECps0.`relsgn`=ECps1.`Sign`
                                   AND ECps1.`src`=ECps2.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => '*')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: relsgn;trg;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"relsgn\",\"trg\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Relation` AS src, ECps2.`Conid` AS tgt
                                 FROM `Relation` AS ECps0,
                                      `Sign` AS ECps1,
                                      `Conid` AS ECps2
                                 WHERE ECps0.`relsgn`=ECps1.`Sign`
                                   AND ECps1.`trg`=ECps2.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ']')
                    )
            )
    ,   array ( 'label' => 'Rule'
              , 'concept' => 'Rule'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: rrnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `rrnm` AS src, `ADLid` AS tgt
                                 FROM `ADLid`
                                 WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL' )
                    )
            )
    );

$allInterfaceObjects =
  array
    ( // Top-level interface Atlas for role Student:
      'Atlas' => 
      array ( 'name' => 'Atlas'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'context'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Context'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Context]\" ] */
                                                SELECT DISTINCT 1 AS src, `Context`.`ctxnm` AS tgt
                                                FROM `Conid` AS `Context`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'naam'
                                        // Normalized interface expression (== expressionSQL): ctxnm
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Conid'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `Conid` AS tgt
                                                              FROM `Conid`
                                                              WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'aantal regels'
                                        // Normalized interface expression (== expressionSQL): countrules
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Int'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countrules` AS tgt
                                                              FROM `Conid`
                                                              WHERE `ctxnm` IS NOT NULL AND `countrules` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'aantal relaties'
                                        // Normalized interface expression (== expressionSQL): countdecls
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Int'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countdecls` AS tgt
                                                              FROM `Conid`
                                                              WHERE `ctxnm` IS NOT NULL AND `countdecls` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'aantal concepten'
                                        // Normalized interface expression (== expressionSQL): countcpts
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Int'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countcpts` AS tgt
                                                              FROM `Conid`
                                                              WHERE `ctxnm` IS NOT NULL AND `countcpts` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'patterns'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxpats
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxpats\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`Pattern` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `Conid` AS `Context`
                                                     ) AS ECps0,
                                                     `ctxpats` AS ECps1
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'regels'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxpats;ptrls
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Rule'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxpats\",\"ptrls\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`Rule` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `Conid` AS `Context`
                                                     ) AS ECps0,
                                                     `ctxpats` AS ECps1,
                                                     `ptrls` AS ECps2
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`
                                                  AND ECps1.`Pattern`=ECps2.`Pattern`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'relaties'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxpats;ptdcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Declaration'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxpats\",\"ptdcs\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`Declaration` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `Conid` AS `Context`
                                                     ) AS ECps0,
                                                     `ctxpats` AS ECps1,
                                                     `ptdcs` AS ECps2
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`
                                                  AND ECps1.`Pattern`=ECps2.`Pattern`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'isa-relaties'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxpats;ptgns
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Gen'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxpats\",\"ptgns\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`Gen` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `Conid` AS `Context`
                                                     ) AS ECps0,
                                                     `ctxpats` AS ECps1,
                                                     `ptgns` AS ECps2
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`
                                                  AND ECps1.`Pattern`=ECps2.`Pattern`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'concepten'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxcs\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`Concept` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `Conid` AS `Context`
                                                     ) AS ECps0,
                                                     `ctxcs` AS ECps1
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Atlasbewerkingen effectueren for role Student:
      'Atlasbewerkingen effectueren' => 
      array ( 'name' => 'Atlasbewerkingen effectueren'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ('FileName')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Atlasbewerkingen opslaan in...'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Context'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Context]\" ] */
                                                SELECT DISTINCT 1 AS src, `Context`.`ctxnm` AS tgt
                                                FROM `Conid` AS `Context`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'savecontext'
                                        // Normalized interface expression (== expressionSQL): savecontext
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'SaveAdlFile'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `savecontext` AS tgt
                                                              FROM `Conid`
                                                              WHERE `ctxnm` IS NOT NULL AND `savecontext` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'volgende versie van bronbestand (automatisch laden)'
                                                      // Normalized interface expression (== expressionSQL): I[SaveAdlFile]
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'SaveAdlFile'
                                                      , 'tgtConcept' => 'SaveAdlFile'
                                                      , 'expressionSQL' => '/* case: ETyp x _
                                                                               ETyp ( \"I\" ) _ */
                                                                            SELECT DISTINCT `SaveAdlFile` AS src, `SaveAdlFile` AS tgt
                                                                            FROM `File`
                                                                            WHERE `SaveAdlFile` IS NOT NULL AND `SaveAdlFile` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'savepopulatie'
                                        // Normalized interface expression (== expressionSQL): savepopulation
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'SavePopFile'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `savepopulation` AS tgt
                                                              FROM `Conid`
                                                              WHERE `ctxnm` IS NOT NULL AND `savepopulation` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'populatiebestand (alleen INCLUDE)'
                                                      // Normalized interface expression (== expressionSQL): I[SavePopFile]
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'SavePopFile'
                                                      , 'tgtConcept' => 'SavePopFile'
                                                      , 'expressionSQL' => '/* case: ETyp x _
                                                                               ETyp ( \"I\" ) _ */
                                                                            SELECT DISTINCT `SavePopFile` AS src, `SavePopFile` AS tgt
                                                                            FROM `File`
                                                                            WHERE `SavePopFile` IS NOT NULL AND `SavePopFile` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'wijzig populatiebestandsnaam'
                                                      // Normalized interface expression (== expressionSQL): filename
                                                      , 'relation' => 'filename'
                                                      , 'relationIsFlipped' => false
                                                      , 'min' => 'One'
                                                      , 'max' => 'One'
                                                      , 'srcConcept' => 'File'
                                                      , 'tgtConcept' => 'FileName'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `filename` AS tgt
                                                                            FROM `File`
                                                                            WHERE `File` IS NOT NULL AND `filename` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Contextbestanden be- of verwerken for role Student:
      'Contextbestanden be- of verwerken' => 
      array ( 'name' => 'Contextbestanden be- of verwerken'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'geladen in Atlas'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Context'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Context]\" ] */
                                                SELECT DISTINCT 1 AS src, `Context`.`ctxnm` AS tgt
                                                FROM `Conid` AS `Context`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'context'
                                        // Normalized interface expression (== expressionSQL): I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Context'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `ctxnm` AS tgt
                                                              FROM `Conid`
                                                              WHERE `ctxnm` IS NOT NULL AND `ctxnm` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'bronbestand'
                                        // Normalized interface expression (== expressionSQL): sourcefile \\/ includes
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'File'
                                        , 'expressionSQL' => '/* case: EUni es
                                                                 EUni [\"sourcefile\",\"includes\"] */
                                                              (SELECT DISTINCT `ctxnm` AS src, `sourcefile` AS tgt
                                                                  FROM `Conid`
                                                                  WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL
                                                              ) UNION (SELECT DISTINCT `Context` AS src, `File` AS tgt
                                                                  FROM `includes`
                                                                  WHERE `Context` IS NOT NULL AND `File` IS NOT NULL
                                                              
                                                              )'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'acties op bestand'
                                        // Normalized interface expression (== expressionSQL): sourcefile;applyto~
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'G'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"sourcefile\",\"applyto~\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`ctxnm` AS src, ECps1.`G` AS tgt
                                                              FROM `Conid` AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `G`, `applyto`
                                                                     FROM `G`
                                                                     WHERE `G` IS NOT NULL AND `applyto` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`sourcefile`=ECps1.`applyto`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'bestandsoverzicht'
                          // Normalized interface expression (== expressionSQL): V[ONE*User]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'User'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*User]\" ] */
                                                SELECT DISTINCT 1 AS src, `User`.`User` AS tgt
                                                FROM `User` AS `User`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'open nieuw bronbestand'
                                        // Normalized interface expression (== expressionSQL): newfile
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'User'
                                        , 'tgtConcept' => 'NewAdlFile'
                                        , 'expressionSQL' => 'SELECT DISTINCT `User` AS src, `newfile` AS tgt
                                                              FROM `User`
                                                              WHERE `User` IS NOT NULL AND `newfile` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'ge-uploade of bewaarde bronbestanden'
                                        // Normalized interface expression (== expressionSQL): uploaded
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'User'
                                        , 'tgtConcept' => 'File'
                                        , 'expressionSQL' => 'SELECT DISTINCT `User` AS src, `File` AS tgt
                                                              FROM `uploaded`
                                                              WHERE `User` IS NOT NULL AND `File` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'bestandsnaam'
                                                      // Normalized interface expression (== expressionSQL): I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'File'
                                                      , 'tgtConcept' => 'File'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `File` AS tgt
                                                                            FROM `File`
                                                                            WHERE `File` IS NOT NULL AND `File` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'acties op bestand'
                                                      // Normalized interface expression (== expressionSQL): applyto~
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'AdlFile'
                                                      , 'tgtConcept' => 'G'
                                                      , 'expressionSQL' => '/* case: EFlp x. */
                                                                            SELECT DISTINCT `G` AS tgt, `applyto` AS src
                                                                            FROM `G`
                                                                            WHERE `G` IS NOT NULL AND `applyto` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Context for role Student:
      'Context' => 
      array ( 'name' => 'Context'
            // Normalized interface expression (== expressionSQL): I[Context]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Context'
            , 'tgtConcept' => 'Context'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `ctxnm` AS src, `ctxnm` AS tgt
                                  FROM `Conid`
                                  WHERE `ctxnm` IS NOT NULL AND `ctxnm` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'naam'
                          // Normalized interface expression (== expressionSQL): ctxnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Conid'
                          , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `Conid` AS tgt
                                                FROM `Conid`
                                                WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'patterns'
                          // Normalized interface expression (== expressionSQL): ctxpats
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => 'SELECT DISTINCT `Context` AS src, `Pattern` AS tgt
                                                FROM `ctxpats`
                                                WHERE `Context` IS NOT NULL AND `Pattern` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'regels'
                          // Normalized interface expression (== expressionSQL): ctxpats;ptrls
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Rule'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"ctxpats\",\"ptrls\"] */
                                                
                                                SELECT DISTINCT ECps0.`Context` AS src, ECps1.`Rule` AS tgt
                                                FROM `ctxpats` AS ECps0,
                                                     `ptrls` AS ECps1
                                                WHERE ECps0.`Pattern`=ECps1.`Pattern`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'relaties'
                          // Normalized interface expression (== expressionSQL): ctxpats;ptdcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Declaration'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"ctxpats\",\"ptdcs\"] */
                                                
                                                SELECT DISTINCT ECps0.`Context` AS src, ECps1.`Declaration` AS tgt
                                                FROM `ctxpats` AS ECps0,
                                                     `ptdcs` AS ECps1
                                                WHERE ECps0.`Pattern`=ECps1.`Pattern`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'isa-relaties'
                          // Normalized interface expression (== expressionSQL): ctxpats;ptgns
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Gen'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"ctxpats\",\"ptgns\"] */
                                                
                                                SELECT DISTINCT ECps0.`Context` AS src, ECps1.`Gen` AS tgt
                                                FROM `ctxpats` AS ECps0,
                                                     `ptgns` AS ECps1
                                                WHERE ECps0.`Pattern`=ECps1.`Pattern`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'concepten'
                          // Normalized interface expression (== expressionSQL): ctxcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => 'SELECT DISTINCT `Context` AS src, `Concept` AS tgt
                                                FROM `ctxcs`
                                                WHERE `Context` IS NOT NULL AND `Concept` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Pattern for role Student:
      'Pattern' => 
      array ( 'name' => 'Pattern'
            // Normalized interface expression (== expressionSQL): I[Pattern]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Pattern'
            , 'tgtConcept' => 'Pattern'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `ptnm` AS src, `ptnm` AS tgt
                                  FROM `Conid`
                                  WHERE `ptnm` IS NOT NULL AND `ptnm` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'bedoeling'
                          // Normalized interface expression (== expressionSQL): ptxps
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Pattern` AS src, `Blob` AS tgt
                                                FROM `ptxps`
                                                WHERE `Pattern` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'naam'
                          // Normalized interface expression (== expressionSQL): ptnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Conid'
                          , 'expressionSQL' => 'SELECT DISTINCT `ptnm` AS src, `Conid` AS tgt
                                                FROM `Conid`
                                                WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'regels'
                          // Normalized interface expression (== expressionSQL): ptrls
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Rule'
                          , 'expressionSQL' => 'SELECT DISTINCT `Pattern` AS src, `Rule` AS tgt
                                                FROM `ptrls`
                                                WHERE `Pattern` IS NOT NULL AND `Rule` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'relaties'
                          // Normalized interface expression (== expressionSQL): ptdcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Declaration'
                          , 'expressionSQL' => 'SELECT DISTINCT `Pattern` AS src, `Declaration` AS tgt
                                                FROM `ptdcs`
                                                WHERE `Pattern` IS NOT NULL AND `Declaration` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'isa-relaties'
                          // Normalized interface expression (== expressionSQL): ptgns
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Gen'
                          , 'expressionSQL' => 'SELECT DISTINCT `Pattern` AS src, `Gen` AS tgt
                                                FROM `ptgns`
                                                WHERE `Pattern` IS NOT NULL AND `Gen` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'diagram'
                          // Normalized interface expression (== expressionSQL): ptpic
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Image'
                          , 'expressionSQL' => 'SELECT DISTINCT `ptnm` AS src, `ptpic` AS tgt
                                                FROM `Conid`
                                                WHERE `ptnm` IS NOT NULL AND `ptpic` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Isa-relatie for role Student:
      'Isa-relatie' => 
      array ( 'name' => 'Isa-relatie'
            // Normalized interface expression (== expressionSQL): I[Gen]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Gen'
            , 'tgtConcept' => 'Gen'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Gen` AS src, `Gen` AS tgt
                                  FROM `Gen`
                                  WHERE `Gen` IS NOT NULL AND `Gen` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'specifiek concept'
                          // Normalized interface expression (== expressionSQL): genspc
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Gen'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => 'SELECT DISTINCT `Gen` AS src, `genspc` AS tgt
                                                FROM `Gen`
                                                WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'generiek concept'
                          // Normalized interface expression (== expressionSQL): gengen
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Gen'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => 'SELECT DISTINCT `Gen` AS src, `gengen` AS tgt
                                                FROM `Gen`
                                                WHERE `Gen` IS NOT NULL AND `gengen` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'gedeclareerd in pattern'
                          // Normalized interface expression (== expressionSQL): ptgns~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Gen'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Pattern` AS tgt, `Gen` AS src
                                                FROM `ptgns`
                                                WHERE `Pattern` IS NOT NULL AND `Gen` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Concept for role Student:
      'Concept' => 
      array ( 'name' => 'Concept'
            // Normalized interface expression (== expressionSQL): I[Concept]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ('AtomID', 'Atom')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Concept'
            , 'tgtConcept' => 'Concept'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `cptnm` AS src, `cptnm` AS tgt
                                  FROM `Conid`
                                  WHERE `cptnm` IS NOT NULL AND `cptnm` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'bedoeling'
                          // Normalized interface expression (== expressionSQL): cptpurpose
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Concept` AS src, `Blob` AS tgt
                                                FROM `cptpurpose`
                                                WHERE `Concept` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'definitie'
                          // Normalized interface expression (== expressionSQL): cptdf
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Concept` AS src, `Blob` AS tgt
                                                FROM `cptdf`
                                                WHERE `Concept` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'naam'
                          // Normalized interface expression (== expressionSQL): cptnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Conid'
                          , 'expressionSQL' => 'SELECT DISTINCT `cptnm` AS src, `Conid` AS tgt
                                                FROM `Conid`
                                                WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'specifieker type'
                          // Normalized interface expression (== expressionSQL): (genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                /* case: EUni es
                                                   EUni [\"genspc~;gengen\",\"genspc~;gengen;genspc~;gengen\",\"genspc~;gengen;genspc~;gengen;genspc~;gengen\"] */
                                                (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS tgt, ECps1.`gengen` AS src
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `Gen` AS ECps1
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS tgt, ECps3.`gengen` AS src
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `Gen` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps2,
                                                         `Gen` AS ECps3
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                      AND ECps1.`gengen`=ECps2.`genspc`
                                                      AND ECps2.`Gen`=ECps3.`Gen`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS tgt, ECps5.`gengen` AS src
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `Gen` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps2,
                                                         `Gen` AS ECps3,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps4,
                                                         `Gen` AS ECps5
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                      AND ECps1.`gengen`=ECps2.`genspc`
                                                      AND ECps2.`Gen`=ECps3.`Gen`
                                                      AND ECps3.`gengen`=ECps4.`genspc`
                                                      AND ECps4.`Gen`=ECps5.`Gen`
                                                
                                                
                                                )'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'generieker type'
                          // Normalized interface expression (== expressionSQL): genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => '/* case: EUni es
                                                   EUni [\"genspc~;gengen\",\"genspc~;gengen;genspc~;gengen\",\"genspc~;gengen;genspc~;gengen;genspc~;gengen\"] */
                                                (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS src, ECps1.`gengen` AS tgt
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `Gen` AS ECps1
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS src, ECps3.`gengen` AS tgt
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `Gen` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps2,
                                                         `Gen` AS ECps3
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                      AND ECps1.`gengen`=ECps2.`genspc`
                                                      AND ECps2.`Gen`=ECps3.`Gen`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS src, ECps5.`gengen` AS tgt
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `Gen` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps2,
                                                         `Gen` AS ECps3,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `Gen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps4,
                                                         `Gen` AS ECps5
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                      AND ECps1.`gengen`=ECps2.`genspc`
                                                      AND ECps2.`Gen`=ECps3.`Gen`
                                                      AND ECps3.`gengen`=ECps4.`genspc`
                                                      AND ECps4.`Gen`=ECps5.`Gen`
                                                
                                                
                                                )'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'populatie'
                          // Normalized interface expression (== expressionSQL): cptos
                          , 'relation' => 'cptos'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'AtomID'
                          , 'expressionSQL' => 'SELECT DISTINCT `cptos` AS src, `AtomID` AS tgt
                                                FROM `AtomID`
                                                WHERE `cptos` IS NOT NULL AND `AtomID` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'atoom'
                                        // Normalized interface expression (== expressionSQL): atomvalue
                                        , 'relation' => 'atomvalue'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'AtomID'
                                        , 'tgtConcept' => 'Atom'
                                        , 'expressionSQL' => 'SELECT DISTINCT `AtomID` AS src, `atomvalue` AS tgt
                                                              FROM `AtomID`
                                                              WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'populatie (van specifieker)'
                          // Normalized interface expression (== expressionSQL): (genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~;cptos
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'AtomID'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"(genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~\",\"cptos\"] */
                                                
                                                SELECT DISTINCT ECps0.`gengen` AS src, ECps1.`AtomID` AS tgt
                                                FROM 
                                                     ( /* case: EFlp x. */
                                                       /* case: EUni es
                                                          EUni [\"genspc~;gengen\",\"genspc~;gengen;genspc~;gengen\",\"genspc~;gengen;genspc~;gengen;genspc~;gengen\"] */
                                                       (/* case: (ECps es), with two or more elements in es.
                                                              ECps [\"genspc~\",\"gengen\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`genspc`, ECps1.`gengen`
                                                           FROM 
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Gen`, `genspc`
                                                                  FROM `Gen`
                                                                  WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                                ) AS ECps0,
                                                                `Gen` AS ECps1
                                                           WHERE ECps0.`Gen`=ECps1.`Gen`
                                                       ) UNION (/* case: (ECps es), with two or more elements in es.
                                                              ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`genspc`, ECps3.`gengen`
                                                           FROM 
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Gen`, `genspc`
                                                                  FROM `Gen`
                                                                  WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                                ) AS ECps0,
                                                                `Gen` AS ECps1,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Gen`, `genspc`
                                                                  FROM `Gen`
                                                                  WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                                ) AS ECps2,
                                                                `Gen` AS ECps3
                                                           WHERE ECps0.`Gen`=ECps1.`Gen`
                                                             AND ECps1.`gengen`=ECps2.`genspc`
                                                             AND ECps2.`Gen`=ECps3.`Gen`
                                                       ) UNION (/* case: (ECps es), with two or more elements in es.
                                                              ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`genspc`, ECps5.`gengen`
                                                           FROM 
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Gen`, `genspc`
                                                                  FROM `Gen`
                                                                  WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                                ) AS ECps0,
                                                                `Gen` AS ECps1,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Gen`, `genspc`
                                                                  FROM `Gen`
                                                                  WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                                ) AS ECps2,
                                                                `Gen` AS ECps3,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Gen`, `genspc`
                                                                  FROM `Gen`
                                                                  WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                                ) AS ECps4,
                                                                `Gen` AS ECps5
                                                           WHERE ECps0.`Gen`=ECps1.`Gen`
                                                             AND ECps1.`gengen`=ECps2.`genspc`
                                                             AND ECps2.`Gen`=ECps3.`Gen`
                                                             AND ECps3.`gengen`=ECps4.`genspc`
                                                             AND ECps4.`Gen`=ECps5.`Gen`
                                                       
                                                       
                                                       )
                                                     ) AS ECps0,
                                                     `AtomID` AS ECps1
                                                WHERE ECps0.`genspc`=ECps1.`cptos`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'toepassing in relaties'
                          // Normalized interface expression (== expressionSQL): (decsgn;(src \\/ trg))~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Declaration'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                /* case: (ECps es), with two or more elements in es.
                                                   ECps [\"decsgn\",\"src \\\\/ trg\"] */
                                                
                                                SELECT DISTINCT ECps0.`Declaration` AS tgt, ECps1.`src`
                                                FROM `Declaration` AS ECps0,
                                                     
                                                     ( /* case: EUni es
                                                          EUni [\"src\",\"trg\"] */
                                                       (SELECT DISTINCT `Sign`, `src`
                                                           FROM `Sign`
                                                           WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL
                                                       ) UNION (SELECT DISTINCT `Sign`, `trg` AS `src`
                                                           FROM `Sign`
                                                           WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL
                                                       
                                                       )
                                                     ) AS ECps1
                                                WHERE ECps0.`decsgn`=ECps1.`Sign`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'relatie'
                                        // Normalized interface expression (== expressionSQL): I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Declaration'
                                        , 'tgtConcept' => 'Declaration'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `Declaration` AS tgt
                                                              FROM `Declaration`
                                                              WHERE `Declaration` IS NOT NULL AND `Declaration` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'met eigenschappen'
                                        // Normalized interface expression (== expressionSQL): decprps;declaredthrough
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Declaration'
                                        , 'tgtConcept' => 'Property'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"decprps\",\"declaredthrough\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`decprps` AS src, ECps1.`Property` AS tgt
                                                              FROM `ADLid` AS ECps0,
                                                                   `declaredthrough` AS ECps1
                                                              WHERE ECps0.`PropertyRule`=ECps1.`PropertyRule`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'toepassing in expressie'
                          // Normalized interface expression (== expressionSQL): (relsgn;(src \\/ trg))~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Relation'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                /* case: (ECps es), with two or more elements in es.
                                                   ECps [\"relsgn\",\"src \\\\/ trg\"] */
                                                
                                                SELECT DISTINCT ECps0.`Relation` AS tgt, ECps1.`src`
                                                FROM `Relation` AS ECps0,
                                                     
                                                     ( /* case: EUni es
                                                          EUni [\"src\",\"trg\"] */
                                                       (SELECT DISTINCT `Sign`, `src`
                                                           FROM `Sign`
                                                           WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL
                                                       ) UNION (SELECT DISTINCT `Sign`, `trg` AS `src`
                                                           FROM `Sign`
                                                           WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL
                                                       
                                                       )
                                                     ) AS ECps1
                                                WHERE ECps0.`relsgn`=ECps1.`Sign`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'relatieterm'
                                        // Normalized interface expression (== expressionSQL): I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Relation'
                                        , 'tgtConcept' => 'Relation'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Relation` AS src, `Relation` AS tgt
                                                              FROM `Relation`
                                                              WHERE `Relation` IS NOT NULL AND `Relation` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'in regel'
                                        // Normalized interface expression (== expressionSQL): (rrexp;rels)~
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Relation'
                                        , 'tgtConcept' => 'Rule'
                                        , 'expressionSQL' => '/* case: EFlp x. */
                                                              /* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"rrexp\",\"rels\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`rrnm` AS tgt, ECps1.`Relation` AS src
                                                              FROM `ADLid` AS ECps0,
                                                                   `rels` AS ECps1
                                                              WHERE ECps0.`rrexp`=ECps1.`ExpressionID`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'diagram'
                          // Normalized interface expression (== expressionSQL): cptpic
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Image'
                          , 'expressionSQL' => 'SELECT DISTINCT `cptnm` AS src, `cptpic` AS tgt
                                                FROM `Conid`
                                                WHERE `cptnm` IS NOT NULL AND `cptpic` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Relatie for role Student:
      'Relatie' => 
      array ( 'name' => 'Relatie'
            // Normalized interface expression (== expressionSQL): I[Declaration]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ('PairID', 'Pair', 'AtomID', 'AtomID')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Declaration'
            , 'tgtConcept' => 'Declaration'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Declaration` AS src, `Declaration` AS tgt
                                  FROM `Declaration`
                                  WHERE `Declaration` IS NOT NULL AND `Declaration` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'bedoeling'
                          // Normalized interface expression (== expressionSQL): decpurpose
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `Blob` AS tgt
                                                FROM `decpurpose`
                                                WHERE `Declaration` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'betekenis'
                          // Normalized interface expression (== expressionSQL): decmean
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `Blob` AS tgt
                                                FROM `decmean`
                                                WHERE `Declaration` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'naam'
                          // Normalized interface expression (== expressionSQL): decnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Varid'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `decnm` AS tgt
                                                FROM `Declaration`
                                                WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'type'
                          // Normalized interface expression (== expressionSQL): decsgn
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Sign'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `decsgn` AS tgt
                                                FROM `Declaration`
                                                WHERE `Declaration` IS NOT NULL AND `decsgn` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'source'
                                        // Normalized interface expression (== expressionSQL): src
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Sign'
                                        , 'tgtConcept' => 'Concept'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Sign` AS src, `src` AS tgt
                                                              FROM `Sign`
                                                              WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'target'
                                        // Normalized interface expression (== expressionSQL): trg
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Sign'
                                        , 'tgtConcept' => 'Concept'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Sign` AS src, `trg` AS tgt
                                                              FROM `Sign`
                                                              WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'eigenschappen'
                          // Normalized interface expression (== expressionSQL): decprps
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'PropertyRule'
                          , 'expressionSQL' => 'SELECT DISTINCT `decprps` AS src, `PropertyRule` AS tgt
                                                FROM `ADLid`
                                                WHERE `decprps` IS NOT NULL AND `PropertyRule` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'eigenschap'
                                        // Normalized interface expression (== expressionSQL): declaredthrough
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'PropertyRule'
                                        , 'tgtConcept' => 'Property'
                                        , 'expressionSQL' => 'SELECT DISTINCT `PropertyRule` AS src, `Property` AS tgt
                                                              FROM `declaredthrough`
                                                              WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'pragma1'
                          // Normalized interface expression (== expressionSQL): decprL
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'String'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `decprL` AS tgt
                                                FROM `Declaration`
                                                WHERE `Declaration` IS NOT NULL AND `decprL` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'pragma2'
                          // Normalized interface expression (== expressionSQL): decprM
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'String'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `decprM` AS tgt
                                                FROM `Declaration`
                                                WHERE `Declaration` IS NOT NULL AND `decprM` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'pragma3'
                          // Normalized interface expression (== expressionSQL): decprR
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'String'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `decprR` AS tgt
                                                FROM `Declaration`
                                                WHERE `Declaration` IS NOT NULL AND `decprR` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'gedeclareerd in pattern'
                          // Normalized interface expression (== expressionSQL): ptdcs~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Pattern` AS tgt, `Declaration` AS src
                                                FROM `ptdcs`
                                                WHERE `Pattern` IS NOT NULL AND `Declaration` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'populatie'
                          // Normalized interface expression (== expressionSQL): decpopu
                          , 'relation' => 'decpopu'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'PairID'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `PairID` AS tgt
                                                FROM `decpopu`
                                                WHERE `Declaration` IS NOT NULL AND `PairID` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'paar'
                                        // Normalized interface expression (== expressionSQL): pairvalue
                                        , 'relation' => 'pairvalue'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'PairID'
                                        , 'tgtConcept' => 'Pair'
                                        , 'expressionSQL' => 'SELECT DISTINCT `PairID` AS src, `pairvalue` AS tgt
                                                              FROM `PairID`
                                                              WHERE `PairID` IS NOT NULL AND `pairvalue` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'links'
                                                      // Normalized interface expression (== expressionSQL): left
                                                      , 'relation' => 'left'
                                                      , 'relationIsFlipped' => false
                                                      , 'min' => 'One'
                                                      , 'max' => 'One'
                                                      , 'srcConcept' => 'Pair'
                                                      , 'tgtConcept' => 'AtomID'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Pair` AS src, `left` AS tgt
                                                                            FROM `Pair`
                                                                            WHERE `Pair` IS NOT NULL AND `left` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'rechts'
                                                      // Normalized interface expression (== expressionSQL): right
                                                      , 'relation' => 'right'
                                                      , 'relationIsFlipped' => false
                                                      , 'min' => 'One'
                                                      , 'max' => 'One'
                                                      , 'srcConcept' => 'Pair'
                                                      , 'tgtConcept' => 'AtomID'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Pair` AS src, `right` AS tgt
                                                                            FROM `Pair`
                                                                            WHERE `Pair` IS NOT NULL AND `right` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'toepassing in regels'
                          // Normalized interface expression (== expressionSQL): (rrexp;rels;reldcl)~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Rule'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                /* case: (ECps es), with two or more elements in es.
                                                   ECps [\"rrexp\",\"rels\",\"reldcl\"] */
                                                
                                                SELECT DISTINCT ECps0.`rrnm` AS tgt, ECps2.`reldcl` AS src
                                                FROM `ADLid` AS ECps0,
                                                     `rels` AS ECps1,
                                                     `Relation` AS ECps2
                                                WHERE ECps0.`rrexp`=ECps1.`ExpressionID`
                                                  AND ECps1.`Relation`=ECps2.`Relation`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Regel for role Student:
      'Regel' => 
      array ( 'name' => 'Regel'
            // Normalized interface expression (== expressionSQL): I[Rule]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Rule'
            , 'tgtConcept' => 'Rule'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `rrnm` AS src, `rrnm` AS tgt
                                  FROM `ADLid`
                                  WHERE `rrnm` IS NOT NULL AND `rrnm` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'bedoeling'
                          // Normalized interface expression (== expressionSQL): rrpurpose
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Rule` AS src, `Blob` AS tgt
                                                FROM `rrpurpose`
                                                WHERE `Rule` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'betekenis'
                          // Normalized interface expression (== expressionSQL): rrmean
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Rule` AS src, `Blob` AS tgt
                                                FROM `rrmean`
                                                WHERE `Rule` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'naam'
                          // Normalized interface expression (== expressionSQL): rrnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'ADLid'
                          , 'expressionSQL' => 'SELECT DISTINCT `rrnm` AS src, `ADLid` AS tgt
                                                FROM `ADLid`
                                                WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'expressie'
                          // Normalized interface expression (== expressionSQL): rrexp
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'ExpressionID'
                          , 'expressionSQL' => 'SELECT DISTINCT `rrnm` AS src, `rrexp` AS tgt
                                                FROM `ADLid`
                                                WHERE `rrnm` IS NOT NULL AND `rrexp` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'relatietermen'
                          // Normalized interface expression (== expressionSQL): rrexp;rels
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Relation'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"rrexp\",\"rels\"] */
                                                
                                                SELECT DISTINCT ECps0.`rrnm` AS src, ECps1.`Relation` AS tgt
                                                FROM `ADLid` AS ECps0,
                                                     `rels` AS ECps1
                                                WHERE ECps0.`rrexp`=ECps1.`ExpressionID`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'relatie'
                                        // Normalized interface expression (== expressionSQL): reldcl
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Relation'
                                        , 'tgtConcept' => 'Declaration'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Relation` AS src, `reldcl` AS tgt
                                                              FROM `Relation`
                                                              WHERE `Relation` IS NOT NULL AND `reldcl` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'source'
                                        // Normalized interface expression (== expressionSQL): relsgn;src
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Relation'
                                        , 'tgtConcept' => 'Concept'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"relsgn\",\"src\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Relation` AS src, ECps1.`src` AS tgt
                                                              FROM `Relation` AS ECps0,
                                                                   `Sign` AS ECps1
                                                              WHERE ECps0.`relsgn`=ECps1.`Sign`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'target'
                                        // Normalized interface expression (== expressionSQL): relsgn;trg
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Relation'
                                        , 'tgtConcept' => 'Concept'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"relsgn\",\"trg\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Relation` AS src, ECps1.`trg` AS tgt
                                                              FROM `Relation` AS ECps0,
                                                                   `Sign` AS ECps1
                                                              WHERE ECps0.`relsgn`=ECps1.`Sign`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'pattern'
                          // Normalized interface expression (== expressionSQL): ptrls~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Pattern` AS tgt, `Rule` AS src
                                                FROM `ptrls`
                                                WHERE `Pattern` IS NOT NULL AND `Rule` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'diagram'
                          // Normalized interface expression (== expressionSQL): rrpic
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Image'
                          , 'expressionSQL' => 'SELECT DISTINCT `rrnm` AS src, `rrpic` AS tgt
                                                FROM `ADLid`
                                                WHERE `rrnm` IS NOT NULL AND `rrpic` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Files for role Admin:
      'Files' => 
      array ( 'name' => 'Files'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Admin')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'loaded files'
                          // Normalization steps:
                          //     V[ONE*File];(sourcefile~;sourcefile \\/ compilererror;compilererror~)
                          // <=> { distr \\/ over ; }
                          //     V[ONE*File];sourcefile~;sourcefile \\/ V[ONE*File];compilererror;compilererror~
                          //
                          // Normalized interface expression (== expressionSQL): V[ONE*File];sourcefile~;sourcefile \\/ V[ONE*File];compilererror;compilererror~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'File'
                          , 'expressionSQL' => '/* case: EUni es
                                                   EUni [\"V[ONE*File];sourcefile~;sourcefile\",\"V[ONE*File];compilererror;compilererror~\"] */
                                                (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"V[ONE*File]\",\"sourcefile~\",\"sourcefile\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`sourcefile` AS tgt
                                                    FROM 
                                                         ( /* case: ETyp x _
                                                              ETyp ( \"V\" ) _ */
                                                           /* case: (ERel (V (Sign s t)))
                                                              ERel [ \"V[ONE*File]\" ] */
                                                           SELECT DISTINCT 1 AS `I[ONE]`, `File`.`File`
                                                           FROM `File` AS `File`
                                                         ) AS ECps0,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `ctxnm`, `sourcefile`
                                                           FROM `Conid`
                                                           WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL
                                                         ) AS ECps1,
                                                         `Conid` AS ECps2
                                                    WHERE ECps0.`File`=ECps1.`sourcefile`
                                                      AND ECps1.`ctxnm`=ECps2.`ctxnm`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"V[ONE*File]\",\"compilererror\",\"compilererror~\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`File` AS tgt
                                                    FROM 
                                                         ( /* case: ETyp x _
                                                              ETyp ( \"V\" ) _ */
                                                           /* case: (ERel (V (Sign s t)))
                                                              ERel [ \"V[ONE*File]\" ] */
                                                           SELECT DISTINCT 1 AS `I[ONE]`, `File`.`File`
                                                           FROM `File` AS `File`
                                                         ) AS ECps0,
                                                         `File` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `File`, `compilererror`
                                                           FROM `File`
                                                           WHERE `File` IS NOT NULL AND `compilererror` IS NOT NULL
                                                         ) AS ECps2
                                                    WHERE ECps0.`File`=ECps1.`File`
                                                      AND ECps1.`compilererror`=ECps2.`compilererror`
                                                
                                                )'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'name'
                                        // Normalized interface expression (== expressionSQL): filename
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'FileName'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `filename` AS tgt
                                                              FROM `File`
                                                              WHERE `File` IS NOT NULL AND `filename` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'dir'
                                        // Normalized interface expression (== expressionSQL): filepath
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'FilePath'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `filepath` AS tgt
                                                              FROM `File`
                                                              WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'type or syntax error'
                                        // Normalized interface expression (== expressionSQL): compilererror
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'ErrorMessage'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `compilererror` AS tgt
                                                              FROM `File`
                                                              WHERE `File` IS NOT NULL AND `compilererror` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'context'
                                        // Normalized interface expression (== expressionSQL): sourcefile~
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'AdlFile'
                                        , 'tgtConcept' => 'Context'
                                        , 'expressionSQL' => '/* case: EFlp x. */
                                                              SELECT DISTINCT `ctxnm` AS tgt, `sourcefile` AS src
                                                              FROM `Conid`
                                                              WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'name'
                                                      // Normalized interface expression (== expressionSQL): ctxnm
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'Conid'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `Conid` AS tgt
                                                                            FROM `Conid`
                                                                            WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'source files'
                                                      // Normalization steps:
                                                      //     (sourcefile \\/ includes);filename
                                                      // <=> { distribute \\/ over ; }
                                                      //     sourcefile;filename \\/ includes;filename
                                                      //
                                                      // Normalized interface expression (== expressionSQL): sourcefile;filename \\/ includes;filename
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'FileName'
                                                      , 'expressionSQL' => '/* case: EUni es
                                                                               EUni [\"sourcefile;filename\",\"includes;filename\"] */
                                                                            (/* case: (ECps es), with two or more elements in es.
                                                                                   ECps [\"sourcefile\",\"filename\"] */
                                                                                
                                                                                SELECT DISTINCT ECps0.`ctxnm` AS src, ECps1.`filename` AS tgt
                                                                                FROM `Conid` AS ECps0,
                                                                                     `File` AS ECps1
                                                                                WHERE ECps0.`sourcefile`=ECps1.`File`
                                                                            ) UNION (/* case: (ECps es), with two or more elements in es.
                                                                                   ECps [\"includes\",\"filename\"] */
                                                                                
                                                                                SELECT DISTINCT ECps0.`Context` AS src, ECps1.`filename` AS tgt
                                                                                FROM `includes` AS ECps0,
                                                                                     `File` AS ECps1
                                                                                WHERE ECps0.`File`=ECps1.`File`
                                                                            
                                                                            )'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'number of rules'
                                                      // Normalized interface expression (== expressionSQL): countrules
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'Int'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countrules` AS tgt
                                                                            FROM `Conid`
                                                                            WHERE `ctxnm` IS NOT NULL AND `countrules` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'number of declarations'
                                                      // Normalized interface expression (== expressionSQL): countdecls
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'Int'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countdecls` AS tgt
                                                                            FROM `Conid`
                                                                            WHERE `ctxnm` IS NOT NULL AND `countdecls` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'number of concepts'
                                                      // Normalized interface expression (== expressionSQL): countcpts
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'Int'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countcpts` AS tgt
                                                                            FROM `Conid`
                                                                            WHERE `ctxnm` IS NOT NULL AND `countcpts` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  )
            )
    );
?>
