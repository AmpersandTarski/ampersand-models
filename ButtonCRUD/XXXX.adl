CONTEXT "XXXX" IN ENGLISH 

--[XXXX Definition]
xxxID   :: XXXX * XXID [UNI]
xxxName :: XXXX * XXName [UNI]
xxxText :: XXXX * XXText [UNI]
xxxProp :: XXXX * XXXX [PROP]

REPRESENT XXID, XXName, XXText TYPE ALPHANUMERIC

--[XXXX Test population]
-- Populating `xxxIsClean` prevents that XXs are deleted before `xxxIsClean` is computed
POPULATION xxxIsClean CONTAINS [ ("xx1", "xx1") ]  
POPULATION xxxID   CONTAINS [ ("xx1", "ID-1") ]  
POPULATION xxxName CONTAINS [ ("xx1", "Name-1") ]
POPULATION xxxText CONTAINS [ ("xx1", "Text-1") ]
POPULATION xxxProp CONTAINS [ ("xx1", "xx1") ]

POPULATION xxxIsClean CONTAINS [ ("xx2", "xx2") ]  
POPULATION xxxID   CONTAINS [ ("xx2", "ID-2") ]  
POPULATION xxxName CONTAINS [ ("xx2", "Name-2") ]
POPULATION xxxText CONTAINS [ ("xx2", "Text-2") ]

POPULATION xxxIsClean CONTAINS [ ("xx3", "xx3") ]  
POPULATION xxxID   CONTAINS [ ("xx3", "ID-3") ]  
POPULATION xxxName CONTAINS [ ("xx3", "Name-3") ]
POPULATION xxxText CONTAINS [ ("xx3", "Text-3") ]
POPULATION xxxProp CONTAINS [ ("xx3", "xx3") ]

POPULATION xxxIsClean CONTAINS [ ("xx4", "xx4") ]  
POPULATION xxxID   CONTAINS [ ("xx4", "ID-4") ]  
POPULATION xxxName CONTAINS [ ("xx4", "Name-4") ]
POPULATION xxxText CONTAINS [ ("xx4", "Text-4") ]

--**From here onward, we just follow the instructions in the top of file "XXXX_ButtonCRUD.adl"**

--[XXXX_ButtonCRUD - Prerequisites]
-- 0. The working of ButtonCRUD is based on the idea that a SESSION is the users working context.
--    As a result, most interfaces take a SESSION as their source atom. One of the consequences of this is
--    that such interfaces show up in the NavBar, which has a very polluting effect. If you want to prevent
--    this from happening, you must copy the following code to your main script:

RELATION isVisible[PF_NavMenuItem*PF_NavMenuItem] [PROP] -- Defined in SystemContext.adl
RELATION isInvisible[PF_NavMenuItem*PF_NavMenuItem] [PROP]
ROLE ExecEngine MAINTAINS "DelPair `isInvisible`"
RULE "DelPair `isInvisible`": isInvisible |- I-isVisible
VIOLATION (TXT "{EX} DelPair;isVisible;PF_NavMenuItem;", SRC I, TXT ";PF_NavMenuItem;", TGT I)
ROLE ExecEngine MAINTAINS "InsPair `isInvisible`"
RULE "InsPair `isInvisible`": I-isInvisible |- isVisible
VIOLATION (TXT "{EX} InsPair;isVisible;PF_NavMenuItem;", SRC I, TXT ";PF_NavMenuItem;", TGT I)

--[XXXX_ButtonCRUD - Making the XXXX_ButtonCRUD available]
-- 1. Copy this file and do some renaming:
--    - copy this file to your project, and rename it appropriately.
--    - rename `XXXX` into `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `xxx` into whatever few characters you use to name relations whose SRC is `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `XX` into `ShortName` that you use as an abbreviation for `ThePossiblyLengthyNameOfTheConceptIUse`
--      but of course, if `ThePossiblyLengthyNameOfTheConceptIUse` is short, then it can be the same as `ShortName`.
--    - INCLUDE this file into your script, and apply any conditional-compiler variables that you might need, e.g. as follows

INCLUDE "XXXX_ButtonCRUD.adl" -- --# [ "No<interfacename>Ifc", "NoXXXXHeaderBar", "NoEditingOfXXXXs" ]

--[XXXX_ButtonCRUD - Rules that maintain required populations]
-- 2a. You MUST create rules that maintain the population of (the equivalents of)
--    - `xxxIsClean`          :: XXXX    * XXXX    [PROP] -- Property that allows XXXX to be accepted/registered in the database
--    Here is some example-code that you can use if you replace **expression4xxxIsClean** with what you think is appropriate

xxxIsClean :: XXXX * XXXX [PROP] -- define relation xxxIsClean as shorthand for I /\ xxxName;xxxName~
ROLE ExecEngine MAINTAINS "Equivalence - InsPair xxxIsClean"
RULE "Equivalence - InsPair xxxIsClean": I /\ xxxID;xxxID~ /\ xxxName;xxxName~ /\ xxxText;xxxText~ |- xxxIsClean
VIOLATION (TXT "{EX} InsPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)
ROLE ExecEngine MAINTAINS "Equivalence - DelPair xxxIsClean"
RULE "Equivalence - DelPair xxxIsClean": xxxIsClean |- I /\ xxxID;xxxID~ /\ xxxName;xxxName~ /\ xxxText;xxxText~
VIOLATION (TXT "{EX} DelPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)

-- 2b. You MUST create one or more rules that maintain the population of (the equivalents of)
--    - `sfCreateXXIsAllowed` :: SESSION * SESSION [PROP] -- User is allowed to create a new XX in the session
--    - `sfAllowSelectOnXX`    :: SESSION * XXXX           -- User is allowed to select (view) the XX in the session
--    - `sfAllowUpdateOnXX`   :: SESSION * XXXX           -- User is allowed to update (edit) the XX in the session
--    - `sfAllowDeleteOnXX`   :: SESSION * XXXX           -- User is allowed to delete the XX in the session
--    and/or make sure that you have INTERFACEs by which this population can be maintained. 
--    If you want everyone to be able to do everything with XXs, you can use the following example code:

--**We don't use the below, because `ButtonCRUD.adl` has interfaces that (de)populate these relations
-- ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to create a XXXX"
-- RULE "XXXX_ButtonCRUD allows all users to create a XXXX": I |- sfCreateXXIsAllowed
-- VIOLATION (TXT "InsPair;sfCreateXXIsAllowed;SESSION;", SRC I, TXT ";SESSION;", TGT I)

-- ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX"
-- RULE "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX": V |- sfAllowSelectOnXX /\ sfAllowUpdateOnXX /\ sfAllowDeleteOnXX
-- VIOLATION (TXT "InsPair;sfAllowSelectOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
--           ,TXT "InsPair;sfAllowUpdateOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
--           ,TXT "InsPair;sfAllowDeleteOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
--           )

--[XXXX_ButtonCRUD - Create a VIEW for XXXX]
-- 3. You must define a VIEW called `XXXXSummary`. In the code provided below, change `I` to something more appropriate

POPULATION XXXName CONTAINS [ "(not initialized)" ]
VIEW XXXXSummary : XXXX
{ "Summary": xxxIsInitialized;xxxID \/ (I-xxxIsInitialized);V;"(not initialized)" 
, " (": TXT " (", "Name": xxxName, ")": TXT ")"
} ENDVIEW

--[XXXX_ButtonCRUD - Interfaces]
-- 4a. The code in this template file has several predefined interfaces that need to be integrated with your application.
--    One way to do that is to copy them into your own code and adapt them there 
--    (you can prevent them being compiled in this file by specifying conditional-compilation variable `No<interfacename>Ifc`)
--    Alternatively, you can use them (i.e.: refer to them from your application script).
--    In that case, you still must define some interfaces, specifically the following:
--    - `INTERFACE "ShowXX": I[XXXX]` (etc.) -- This interface must allow the user to see details of the XXXX
--    - `INTERFACE "InitXX": I[XXXX]` (etc.) -- This interface must allow the user to make a just created XXXX 'clean'
--    - `INTERFACE "EditXX": I[XXXX]` (etc.) -- This interface must allow the user to edit the XXXX

INTERFACE "ShowXX": I[XXXX] cRud BOX
   [ "ID" : xxxID cRud
   , "Name" : xxxName cRud
   , "Text" : xxxText cRud
   , "Prop" : xxxProp cRud
   ]

INTERFACE "InitXX": I[XXXX] cRud BOX
   [ "ID" : xxxID cRUd
   , "Name" : xxxName cRUd
   , "Text" : xxxText cRUd
   ]

INTERFACE "EditXX": I[XXXX] cRud BOX 
   [ "Summary": I cRud <XXXXSummary>
   , "Text" : xxxText cRUd
   , "Prop" : xxxProp cRUd
   ]

-- 4b. If you want to use the interfaces provided in this file, you must also provide
--    - An interface that allows the user to see an overview of the XXXXs that he is allowed to work with, using
--      `INTERFACE "OverviewXX": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~`
--    - An interface that allows the user to select one of the XXXXs to start working with it, using
--      `INTERFACE "SelectXX": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~`
--    If you do not have special requirements, you can use the following code to provide these interfaces:

POPULATION isInvisible CONTAINS [ ("OverviewXX","OverviewXX") ]
INTERFACE "OverviewXX": sfAllowSelectOnXX cRud BOX <HCOLS>
   [ "ID" : xxxID cRud
   , "Name" : xxxName cRud
   , "Text" : xxxText cRud
   , "Prop" : xxxProp cRud
   ]

POPULATION isInvisible CONTAINS [ ("SelectXX","SelectXX") ]
INTERFACE "SelectXX": I[SESSION] INTERFACE "XXXXSelect"

--[XXXX_ButtonCRUD - Navigation]
-- 5. ButtonCRUD uses events (clicking a button) to compute the state of affairs.
--    Every such state typically has its own interface associated with it. 
--    In order to get a smooth user experience, changes of state should be accompanied with switching of interfaces.
--    In order to be flexible and give application developers the control they need,
--    every change in state will navigate to an interface with a predefined name, as listed below
--    You can easily define these interfaces as in instance of an existing interface, as exemplified in the code below.
--    The `INTERFACE XXXXPortal` has been designed in such a way that it is suitable for every state.
--    Thus, you can use it as the generic interface to navigate to.
--    Note that `INTERFACE XXXXPortal` has been made invisible, because in practice it will be called from
--    the application's portal. Conversely: be sure that you create a portal from which to call it if needed.

POPULATION isInvisible CONTAINS [ ("AfterEventCreateXXXX","AfterEventCreateXXXX") ]
INTERFACE "AfterEventCreateXXXX":      I[SESSION] INTERFACE "XXXXPortal" -- New XXXX has been created (ready to edit)
POPULATION isInvisible CONTAINS [ ("AfterEventUpdateXXXX","AfterEventUpdateXXXX") ]
INTERFACE "AfterEventUpdateXXXX":      I[SESSION] INTERFACE "XXXXPortal" -- Updating has started (ready to edit)
POPULATION isInvisible CONTAINS [ ("AfterEventCommitXXXX","AfterEventCommitXXXX") ]
INTERFACE "AfterEventCommitXXXX":      I[SESSION] INTERFACE "XXXXPortal" -- Updating has terminated (done editing)
POPULATION isInvisible CONTAINS [ ("AfterEventStartSelectXXXX","AfterEventStartSelectXXXX") ]
INTERFACE "AfterEventStartSelectXXXX": I[SESSION] INTERFACE "XXXXPortal" -- Selecting XXXX has started (interface needs to do the selection)
POPULATION isInvisible CONTAINS [ ("AfterEventEndSelectXXXX","AfterEventEndSelectXXXX") ]
INTERFACE "AfterEventEndSelectXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- Selecting XXXX has ended (go to where you can continue after selection)
POPULATION isInvisible CONTAINS [ ("AfterEventDeselectXXXX","AfterEventDeselectXXXX") ]
INTERFACE "AfterEventDeselectXXXX":    I[SESSION] INTERFACE "XXXXPortal" -- XXXX has been deleted (so go to some overview)
POPULATION isInvisible CONTAINS [ ("AfterEventDeleteXXXX","AfterEventDeleteXXXX") ]
INTERFACE "AfterEventDeleteXXXX":      I[SESSION] INTERFACE "XXXXPortal" -- XXXX has been deleted (so go to some overview)

--[XXXX_ButtonCRUD - Switching between different portals]
-- 6. If you choose to use `INTERFACE XXXXPortal`, you must either
--    - you must use the conditional-compilation variable `NoXXXXHeaderBar`
--      which ensures that this interface will not be called/used.
--    - or you must create `INTERFACE "XXXXHeaderBar"`
--      This interface must provide a header/buttonbar for global navigation purposes.
--      It is particularly useful to populate this header/buttonbar with buttons 
--      that allow the user to switch between XXXXPortal, YYYYPortal, ZZZZPortal, etc.
--      Note that this file specifies `INTERFACE "GoToXXXXPortalButton"`, that contains a
--      single button that, when clicked, navigates the user to `INTERFACE XXXXPortal`.
--      Here is some example code for you to use and adapt in your application script:

--**This test stuff currently does not test portal switching. So we leave it commented** 
-- POPULATION isInvisible CONTAINS [ ("UserHome", "UserHome") ]
-- INTERFACE "UserHome" FOR User: "_SESSION"[SESSION] INTERFACE "XXXXPortal"

-- POPULATION isInvisible CONTAINS [ ("XXXXHeaderBar", "XXXXHeaderBar") ]
-- INTERFACE XXXXHeaderBar FOR User: "_SESSION"[SESSION] cRud BOX <CDIV>
--    [ "User": I cRud BOX <CDIV>
--       [ "User": sessionAccount;accPersonRef cRud
--       , "Logout": I cRud BOX <PROPBUTTON> [ property : sessionLogoutReq cRUd ]
--       ]
--    , "Portal Switch buttons": I[SESSION] cRud BOX <CDIV>
--       [ "XXXXs" : I INTERFACE "GoToXXXXPortalButton"
--       , "YYYYs" : I INTERFACE "GoToYYYYPortalButton"
--       , "ZZZZs" : I INTERFACE "GoToZZZZPortalButton"
--       ]
--    ]

ENDCONTEXT