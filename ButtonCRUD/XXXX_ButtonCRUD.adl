CONTEXT "XXXX_ButtonCRUD" IN ENGLISH
{- This file serves as a template for creating, selecting, editing/updating, and deleting objects of type XXXX
This is done in a 'button-driven' fashion, i.e. providing  user-interfaces that initialize such functionalities.
These interfaces assume they work on (atoms in) the concept XXXX;
It provides templates for various generic interface-types, e.g. an XXXX-portal, button bars, etc.
Also, it provides the ExecEngine rules that implement the CRUD functionalities for XXXX-objects.

This template is designed such that you are not required to change anything
apart from the strings `XXXX`, `xxx` and `XX` (see point 1 below).
However, you do need to add some stuff in your own project.
Here are the steps that show you how to make it work:

--[XXXX_ButtonCRUD - Prerequisites]
-- 0. The working of ButtonCRUD is based on the idea that a SESSION is the users working context.
--    As a result, most interfaces take a SESSION as their source atom. One of the consequences of this is
--    that such interfaces show up in the NavBar, which has a very polluting effect. If you want to prevent
--    this from happening, you must copy the following code to your main script:

RELATION isVisible[PF_NavMenuItem*PF_NavMenuItem] [PROP] -- Defined in SystemContext.adl
RELATION isInvisible[PF_NavMenuItem*PF_NavMenuItem] [PROP]
ROLE ExecEngine MAINTAINS "DelPair `isInvisible`"
RULE "DelPair `isInvisible`": isInvisible |- I-isVisible
VIOLATION (TXT "{EX} DelPair;isVisible;PF_NavMenuItem;", SRC I, TXT ";PF_NavMenuItem;", TGT I)
ROLE ExecEngine MAINTAINS "InsPair `isInvisible`"
RULE "InsPair `isInvisible`": I-isInvisible |- isVisible
VIOLATION (TXT "{EX} InsPair;isVisible;PF_NavMenuItem;", SRC I, TXT ";PF_NavMenuItem;", TGT I)

--[XXXX_ButtonCRUD - Making the XXXX_ButtonCRUD available]
-- 1. Copy this file and do some renaming:
--    - copy this file to your project, and rename it appropriately.
--    - rename `XXXX` into `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `xxx` into whatever few characters you use to name relations whose SRC is `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `XX` into `ShortName` that you use as an abbreviation for `ThePossiblyLengthyNameOfTheConceptIUse`
--      but of course, if `ThePossiblyLengthyNameOfTheConceptIUse` is short, then it can be the same as `ShortName`.
--    - INCLUDE this file into your script, and apply any conditional-compiler variables that you might need, e.g. as follows

INCLUDE "XXXX_ButtonCRUD.adl" -- --# [ "No<interfacename>Ifc", "ApplicationDefinesAllXXInterfaces", "NoEditingOfXXXXs" ]

--[XXXX_ButtonCRUD - Rules that maintain required populations]
-- 2a. You MUST create rules that maintain the population of (the equivalents of)
--    - `xxxIsClean` :: XXXX * XXXX [PROP] -- Property that allows XXXX to be accepted/registered in the database
--    Here is some example-code that you can use if you replace **expression4xxxIsClean** with what you think is appropriate

xxxIsClean :: XXXX * XXXX [PROP] -- define relation xxxIsClean as shorthand for I /\ expression4xxxIsClean
ROLE ExecEngine MAINTAINS "Equivalence - InsPair xxxIsClean"
RULE "Equivalence - InsPair xxxIsClean": expression4xxxIsClean |- xxxIsClean
VIOLATION (TXT "{EX} InsPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)
ROLE ExecEngine MAINTAINS "Equivalence - DelPair xxxIsClean"
RULE "Equivalence - DelPair xxxIsClean": xxxIsClean |- I /\ expression4xxxIsClean
VIOLATION (TXT "{EX} DelPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)

-- 2b. You MUST create one or more rules that maintain the population of (the equivalents of)
--    - `sfCreateXXIsAllowed` :: SESSION * SESSION [PROP] -- User is allowed to create a new XX in the session
--    - `sfAllowSelectOnXX`   :: SESSION * XXXX           -- User is allowed to select (view) the XX in the session
--    - `sfAllowUpdateOnXX`   :: SESSION * XXXX           -- User is allowed to update (edit) the XX in the session
--    - `sfAllowDeleteOnXX`   :: SESSION * XXXX           -- User is allowed to delete the XX in the session
--    and/or make sure that you have INTERFACEs by which this population can be maintained. 
--    If you want everyone to be able to do everything with XXs, you can use the following example code:

ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to create a XXXX"
RULE "XXXX_ButtonCRUD allows all users to create a XXXX": I |- sfCreateXXIsAllowed
VIOLATION (TXT "InsPair;sfCreateXXIsAllowed;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX"
RULE "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX": V |- sfAllowSelectOnXX /\ sfAllowUpdateOnXX /\ sfAllowDeleteOnXX
VIOLATION (TXT "InsPair;sfAllowSelectOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "InsPair;sfAllowUpdateOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "InsPair;sfAllowDeleteOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          )

--[XXXX_ButtonCRUD - Create a VIEW for XXXX]
-- 3. You must define a VIEW called `XXXXSummary`. In the code provided below, change `I` to something more appropriate

VIEW XXXXSummary: XXXX { "Summary": I } ENDVIEW

--[XXXX_ButtonCRUD - Interfaces]
-- 4a. The code in this template file has several predefined interfaces that need to be integrated with your application.
--    One way to do that is to copy them into your own code and adapt them there 
--    (you can prevent them being compiled in this file by specifying conditional-compilation variable `No<interfacename>Ifc`)
--    Alternatively, you can use them (i.e.: refer to them from your application script).
--    In that case, you still must define some interfaces, specifically the following:
--    - `INTERFACE "ShowXX": I[XXXX]` (etc.) -- This interface must allow the user to see details of the XXXX
--    - `INTERFACE "InitXX": I[XXXX]` (etc.) -- This interface must allow the user to make a just created XXXX 'clean'
--    - `INTERFACE "EditXX": I[XXXX]` (etc.) -- This interface must allow the user to edit the XXXX
--    N.B.: Define the interfaces such that they do not show when there is nothing to do.
--          This means that the toplevel should be <DIV>, <CDIV>, <HROWS>, <HCOLS> or such.

-- 4b. If you want to use the interfaces provided in this file, you must also provide
--    - An interface that allows the user to see an overview of the XXXXs that he is allowed to work with, using
--      `INTERFACE "OverviewXX": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~`
--    - An interface that allows the user to select one of the XXXXs to start working with it, using
--      `INTERFACE "SelectXX": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~`
--    If you do not have special requirements, you can use the following code to provide these interfaces:

POPULATION isInvisible CONTAINS [ ("OverviewXX","OverviewXX"), ("SelectXX","SelectXX") ]
INTERFACE "OverviewXX": I[SESSION] INTERFACE "XXXXOverview"
INTERFACE "SelectXX":   I[SESSION] INTERFACE "XXXXSelect"

--[XXXX_ButtonCRUD - Navigation]
-- 5. ButtonCRUD uses events (clicking a button) to compute the state of affairs.
--    Every such state typically has its own interface associated with it. 
--    In order to get a smooth user experience, changes of state should be accompanied with switching of interfaces.
--    In order to be flexible and give application developers the control they need,
--    every change in state will navigate to an interface with a predefined name, as listed below
--    You can easily define these interfaces as in instance of an existing interface, as exemplified in the code below.
--    The `INTERFACE XXXXPortal` has been designed in such a way that it is suitable for every state.
--    Thus, you can use it as the generic interface to navigate to.
--    Note that `INTERFACE XXXXPortal` has been made invisible, because in practice it will be called from
--    the application's portal. Conversely: be sure that you create a portal from which to call it if needed.

INTERFACE "AfterEventCreateXXXX":      I[SESSION] INTERFACE "XXXXPortal" -- New XXXX has been created (ready to edit)
INTERFACE "AfterEventUpdateXXXX":      I[SESSION] INTERFACE "XXXXPortal" -- Updating has started (ready to edit)
INTERFACE "AfterEventCommitXXXX":      I[SESSION] INTERFACE "XXXXPortal" -- Updating has terminated (done editing)
INTERFACE "AfterEventStartSelectXXXX": I[SESSION] INTERFACE "XXXXPortal" -- Selecting XXXX has started (interface needs to do the selection)
INTERFACE "AfterEventEndSelectXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- Selecting XXXX has ended (go to where you can continue after selection)
INTERFACE "AfterEventDeselectXXXX":    I[SESSION] INTERFACE "XXXXPortal" -- XXXX has been deleted (so go to some overview)
INTERFACE "AfterEventDeleteXXXX":      I[SESSION] INTERFACE "XXXXPortal" -- XXXX has been deleted (so go to some overview)

--[XXXX_ButtonCRUD - Switching between different portals]
-- 6. If you choose to use `INTERFACE XXXXPortal`, you must create `INTERFACE "XXXXHeaderBar"`
--    You may want this interface to provide a breadcrumb and/or buttons for navigation purposes.
--    Notes:
--    - this file specifies `INTERFACE "GoToXXXXPortalButton"`, that contains a single button that
--      when clicked, navigates the user to `INTERFACE XXXXPortal`.
--      You can use this as part of the headerbar navigation buttons.
--    - make sure you properly initialize the switching between portals, e.g. by checking whether
--      `sfCurrentPortalIfc` is populated, and if not, create a request to do so. 
--    Here is some example code for you to use and adapt in your application script:

ROLE ExecEngine MAINTAINS "Initialize sfCurrentPortalIfc"
RULE "Initialize sfCurrentPortalIfc": I - sfCurrentPortalIfc;sfCurrentPortalIfc~ |- sfChangeToPortalForXXReq
VIOLATION (TXT "{EX} InsPair;sfChangeToPortalForXXReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

POPULATION isInvisible CONTAINS [ ("XXXXHeaderBar", "XXXXHeaderBar") ]
INTERFACE XXXXHeaderBar FOR User: "_SESSION"[SESSION] cRud BOX <CDIV>
   [ "User": I cRud BOX <CDIV>
      [ "User": sessionAccount;accPersonRef cRud
      , "Logout": I cRud BOX <PROPBUTTON> [ property : sessionLogoutReq cRUd ]
      ]
   , "Portal Switch buttons": I[SESSION] cRud BOX <CDIV>
      [ "XXXXs" : I INTERFACE "GoToXXXXPortalButton"
      , "YYYYs" : I INTERFACE "GoToYYYYPortalButton"
      , "ZZZZs" : I INTERFACE "GoToZZZZPortalButton"
      ]
   ]
-}

--[Basics - Initialization, Being Clean, and (Auto)Deleting XXs]
xxxIsPersistent  :: XXXX * XXXX [PROP] -- Property, stating that XX should not be deleted by ButtonCRUD functionality
xxxIsClean       :: XXXX * XXXX [PROP] -- Property, stating that XX fulfills the minimum requirements for being registered
xxxIsInitialized :: XXXX * XXXX [PROP] -- Property, stating that XX has at some point in time been clean

RULE "Please make XXXX 'clean', or delete it": 
   xxxIsInitialized |- xxxIsPersistent \/ xxxIsClean \/ sfUpdateXX~;sfUpdateXX

ROLE ExecEngine MAINTAINS "InsPair `xxxIsInitialized`" -- This rule prevents inadvertent deletion of XX atoms when DB is inited
RULE "InsPair `xxxIsInitialized`": xxxIsClean |- xxxIsInitialized
VIOLATION (TXT "{EX} InsPair;xxxIsInitialized;XXXX;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Delete XX if it is not persistent and created imcomplete"
RULE "Delete XX if it is not persistent and created imcomplete": 
   I-xxxIsPersistent |- xxxIsClean \/ sfUpdateXX~;sfUpdateXX
VIOLATION (TXT "{EX} DelAtom;XXXX;", SRC I)

--[Basics - Selecting and Being Selected]
-- Selecting is the process in which the user is selecting an XX to put his focus on.
-- The user can choose to start/stop this process by (de)populating `sfXXIsSelecting`
-- Also, the selection process is terminated when an XX is selected (see further down).
sfXXIsSelecting :: SESSION * SESSION [PROP] -- Status, where the user is in the process of selecting the XX to focus on
ROLE ExecEngine MAINTAINS "Auto DelPair `sfXXIsSelecting`"
RULE "Auto DelPair `sfXXIsSelecting`": sfXXIsSelecting |- sfAllowSelectOnXX;sfAllowSelectOnXX~
VIOLATION (TXT "{EX} DelPair;sfXXIsSelecting;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Auto start XXXX selection process" -- N.B.: a single selectable XX will automatically be selected.
RULE "Auto start XXXX selection process": (I-sfSelectedXX;sfSelectedXX~) /\ sfAllowSelectOnXX;sfAllowSelectOnXX~ |- sfXXIsSelecting
VIOLATION (TXT "{EX} InsPair;sfXXIsSelecting;SESSION;", SRC I, TXT ";SESSION;", SRC I)

-- Being focused in a session means that there is an XX that the user has selected so that it can be focused on
sfSelectedXX :: SESSION * XXXX [UNI] -- the XXXX-atom that is selected in/focussed on by the session
sfAllowSelectOnXX :: SESSION * XXXX -- Permission, where the user is allowed to select (view) the XX
RULE "An XXXX can only be selected if that is allowed": sfSelectedXX |- sfAllowSelectOnXX

ROLE ExecEngine MAINTAINS "Auto DelPair `sfSelectedXX`"
RULE "Auto DelPair `sfSelectedXX`": sfSelectedXX |- sfAllowSelectOnXX
VIOLATION (TXT "{EX} DelPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I)

-- Sometimes we need to know whether or not an XX is focused on. Therefore, we define properties that we can use for this
sfHasXXSelected :: SESSION * SESSION [PROP] -- Status/Property, where the session has an XX that the user focuses on
sfNoXXSelected :: SESSION * SESSION [PROP] -- Status/Property, where the session does not have an XX that the user can focus on
ROLE ExecEngine MAINTAINS "InsPair sfHasXXSelected/DelPair xfXXIsUnSelected"
RULE "InsPair sfHasXXSelected/DelPair xfXXIsUnSelected": I /\ sfSelectedXX;sfSelectedXX~ |- sfHasXXSelected-sfNoXXSelected
VIOLATION (TXT "{EX} InsPair;sfHasXXSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} DelPair;sfNoXXSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          )
ROLE ExecEngine MAINTAINS "DelPair sfHasXXSelected/InsPair xfXXIsUnSelected"
RULE "DelPair sfHasXXSelected/InsPair xfXXIsUnSelected": I - sfSelectedXX;sfSelectedXX~ |- sfNoXXSelected-sfHasXXSelected
VIOLATION (TXT "{EX} InsPair;sfNoXXSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} DelPair;sfHasXXSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          )

--[Basics - Updating and Being Updated]
-- Updating or edition an XX means that the session user wants to change attributes/relations of this XX
-- This can only be done while the user is not in the process of selection on some XX.
sfUpdateXX :: SESSION * XXXX [UNI] -- the XXXX-atom that is being updated/edited in the session (and hence must have been selected)
sfAllowUpdateOnXX :: SESSION * XXXX -- Permission, where the user is allowed to update (edit) the specified XX
RULE "In order to be UPDATEing, the user must be permitted to update the selected XXXX":  sfXXIsUpdating |- sfSelectedXX;sfAllowUpdateOnXX~
RULE "An XXXX can only be updated/edited if that is allowed": sfUpdateXX |- sfAllowUpdateOnXX
RULE "Cannot update XXXX because it is being updated in another session": sfUpdateXX |- sfSelectedXX - (sfUpdateXX;-I)

sfXXIsUpdating :: SESSION * SESSION [PROP] -- Status, where the user is in the process of updating (editing) the XX that is focused on
RULE "Updating and Selecting on a XX is mutually exclusive": sfXXIsUpdating /\ sfXXIsSelecting |- -I

ROLE ExecEngine MAINTAINS "Equivalence - InsPair sfXXIsUpdating"
RULE "Equivalence - InsPair sfXXIsUpdating": (I-sfXXIsSelecting) /\ sfUpdateXX;sfUpdateXX~ |- sfXXIsUpdating
VIOLATION (TXT "{EX} InsPair;sfXXIsUpdating;SESSION;", SRC I, TXT ";SESSION;", TGT I)
ROLE ExecEngine MAINTAINS "Equivalence - DelPair sfXXIsUpdating"
RULE "Equivalence - DelPair sfXXIsUpdating": sfXXIsUpdating |- (I-sfXXIsSelecting) /\ sfUpdateXX;sfUpdateXX~
VIOLATION (TXT "{EX} DelPair;sfXXIsUpdating;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} DelPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", SRC sfUpdateXX
          )
ROLE ExecEngine MAINTAINS "Auto DelPair `sfUpdateXX`"
RULE "Auto DelPair `sfUpdateXX`": sfUpdateXX |- sfSelectedXX
VIOLATION (TXT "{EX} DelPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", TGT I)

--[Service: Create XX]
-- An XX is created when `sfXXCreateReq` is populated, and `sfCreateXXIsAllowed` is set (permits the creation)
-- When an XX is created, it is usually not clean, so we take it to be updated after creation.
-- Because of this, we do not allow for the creation of an XX when an XX is being updated.
sfCreateXXIsAllowed :: SESSION * SESSION [PROP] -- Permission, where the user is allowed to request the creation of a new XX
sfXXCreateReq       :: SESSION * SESSION [PROP] -- Event, where the user requests to create a new XX

ROLE ExecEngine MAINTAINS "Decline/Prevent sfXXCreateReq" -- i.e. if there is no permission, or an XX is being updated in this session.
RULE "Decline/Prevent sfXXCreateReq": sfXXCreateReq |- sfCreateXXIsAllowed - sfXXIsUpdating
VIOLATION (TXT "{EX} DelPair;sfXXCreateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Service sfXXCreateReq" -- Create an XX if there is no XX being edited, and creation is allowed
RULE "Service sfXXCreateReq": sfXXCreateReq /\ sfCreateXXIsAllowed |- sfXXIsUpdating
VIOLATION (TXT "{EX} InsAtom;XXXX"
          ,TXT "{EX} InsPair;sfAllowSelectOnXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfAllowUpdateOnXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfAllowDeleteOnXX;SESSION;", SRC I, TXT ";XXXX;_NEW"

          ,TXT "{EX} InsPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} DelPair;sfXXIsSelecting;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} InsPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfXXIsUpdating;SESSION;", SRC I, TXT ";SESSION;", TGT I

          ,TXT "{EX} DelPair;sfXXCreateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventCreateXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventCreateXXXX", "AfterEventCreateXXXX") ]

--[Service: Update XX - Start editing process]
sfXXUpdateReq :: SESSION * SESSION [PROP] -- Event, where the user requests to update (edit) the selected XX

RULE "A session that can update an XX must be able to focus on that XX": sfAllowUpdateOnXX |- sfAllowSelectOnXX
-- We do not provide ExecEngine solutions here so that errors in the population of `sfAllowUpdateOnXX` do not go unnoticed
-- ROLE ExecEngine MAINTAINS "DelPair `sfAllowUpdateOnXX`"
-- RULE "DelPair `sfAllowUpdateOnXX`": sfAllowUpdateOnXX |- sfAllowSelectOnXX
-- VIOLATION (TXT "{EX} DelPair;sfAllowUpdateOnXX;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Decline sfXXUpdateReq"
RULE "Decline sfXXUpdateReq": sfXXUpdateReq |- sfAllowUpdateOnXX;sfSelectedXX~
VIOLATION (TXT "{EX} DelPair;sfXXUpdateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Prevent sfXXUpdateReq" -- this is when XX is being edited in another session
RULE "Prevent sfXXUpdateReq": sfXXUpdateReq;(sfSelectedXX /\ sfAllowUpdateOnXX) |- -(-I;sfUpdateXX)
VIOLATION (TXT "{EX} DelPair;sfXXUpdateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Service sfXXUpdateReq" -- i.e.: Start the updating/editing of XX
RULE "Service sfXXUpdateReq": sfXXUpdateReq;(sfSelectedXX /\ sfAllowUpdateOnXX) |- sfUpdateXX
VIOLATION (TXT "{EX} InsPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXUpdateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventUpdateXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventUpdateXXXX", "AfterEventUpdateXXXX") ]

--[Service: Update XX - Terminate editing process]
sfXXCommitReq :: SESSION * SESSION [PROP] -- Event, where the user requests to commit to the changes for XX

ROLE ExecEngine MAINTAINS "Decline sfXXCommitReq" -- e.g. in sessions other than that where XX is edited
RULE "Decline sfXXCommitReq": sfXXCommitReq |- sfUpdateXX;sfAllowUpdateOnXX~
VIOLATION (TXT "{EX} DelPair;sfXXUpdateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Service sfXXCommitReq by deleting XX"
RULE "Service sfXXCommitReq by deleting XX": sfXXCommitReq;sfUpdateXX |- sfAllowUpdateOnXX;xxxIsClean
VIOLATION (TXT "{EX} DelAtom;XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXCommitReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventCommitXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventCommitXXXX", "AfterEventCommitXXXX") ]

ROLE ExecEngine MAINTAINS "Service sfXXCommitReq by retaining XX"
RULE "Service sfXXCommitReq by retaining XX": sfUpdateXX;xxxIsClean |- (I-sfXXCommitReq);sfAllowUpdateOnXX
VIOLATION (TXT "{EX} DelPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXCommitReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventCommitXXXX"
          )

--[Service: Select XX - Start selection process]
sfXXSelectReq     :: SESSION * SESSION [PROP] -- Event, where the user requests to start selecting the XX to focus on

ROLE ExecEngine MAINTAINS "Decline sfXXSelectReq" -- e.g. in sessions other than that where XX is edited
RULE "Decline sfXXSelectReq": sfXXSelectReq |- I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~
VIOLATION (TXT "{EX} DelPair;sfXXSelectReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Service sfXXSelectReq" -- Service sfXXSelectReq and NavTo interface where the selection is to be made.
RULE "Service sfXXSelectReq": sfXXSelectReq /\ sfAllowSelectOnXX;sfAllowSelectOnXX~ |- sfXXIsSelecting
VIOLATION (TXT "{EX} InsPair;sfXXIsSelecting;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} DelPair;sfXXSelectReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventStartSelectXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventStartSelectXXXX", "AfterEventStartSelectXXXX") ]

--[Service: Select XX - Terminate selection process]
xxxSelectReq :: XXXX * XXXX [PROP] -- Event, where User requests to select this XX to focus on

ROLE ExecEngine MAINTAINS "Decline xxxSelectReq" -- Decline xxxSelectReq when selecting XXXX is not allowed
RULE "Decline xxxSelectReq": xxxSelectReq |- sfAllowSelectOnXX~;sfXXIsSelecting;sfAllowSelectOnXX
VIOLATION (TXT "{EX} DelPair;xxxSelectReq;XXXX;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Service xxxSelectReq" -- Service xxxSelectReq when set, and NavTo interface that ends editing.
RULE "Service xxxSelectReq": sfXXIsSelecting;sfAllowSelectOnXX;xxxSelectReq |- sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXIsSelecting;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} DelPair;xxxSelectReq;XXXX;", TGT I, TXT ";XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventEndSelectXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventEndSelectXXXX", "AfterEventEndSelectXXXX") ]

--[Service: Select XX - Automated selections]

ROLE ExecEngine MAINTAINS "Auto Service sfXXSelectReq - there is only one choice" -- If there's only one choice, then take it.
RULE "Auto Service sfXXSelectReq - there is only one choice":
   sfXXSelectReq;(sfAllowSelectOnXX - sfAllowSelectOnXX;-I) |- sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXSelectReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventEndSelectXXXX"
          )

ROLE ExecEngine MAINTAINS "Auto Service sfXXSelectReq - there is only one choice apart from the current focus" -- If there are only two choices and one is focused on, we can swap them.
RULE "Auto Service sfXXSelectReq - there is only one choice apart from the current focus":
   sfXXSelectReq;((sfAllowSelectOnXX-sfSelectedXX) - (sfAllowSelectOnXX-sfSelectedXX);-I ) |- sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXSelectReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventEndSelectXXXX"
          )

--[Service: Deselect]
sfXXDeselectReq :: SESSION * SESSION [PROP]
ROLE ExecEngine MAINTAINS "Decline sfXXDeselectReq" 
RULE "Decline sfXXDeselectReq": sfXXDeselectReq |- sfHasXXSelected
VIOLATION (TXT "{EX} DelPair;sfXXDeselectReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfXXDeselectReq" 
RULE "Service sfXXDeselectReq": sfXXDeselectReq;sfSelectedXX |- -V
VIOLATION (TXT "{EX} DelPair;sfXXDeselectReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} DelPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXIsSelecting;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDeselectXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventDeselectXXXX", "AfterEventDeselectXXXX") ]

--[Service: Delete XX ]
sfAllowDeleteOnXX :: SESSION * XXXX -- Permission, where the user is allowed to delete the XX
sfXXDeleteReq :: SESSION * SESSION [PROP] -- Event, where the user requests the XX to be (completely) deleted

RULE "A session that can delete an XX must be able to focus on that XX": sfAllowDeleteOnXX |- sfAllowSelectOnXX
-- We do not provide ExecEngine solutions here so that errors in the population of `sfAllowDeleteOnXX` do not go unnoticed
-- ROLE ExecEngine MAINTAINS "DelPair `sfAllowDeleteOnXX`"
-- RULE "DelPair `sfAllowDeleteOnXX`": sfAllowDeleteOnXX |- sfAllowSelectOnXX
-- VIOLATION (TXT "{EX} DelPair;sfAllowDeleteOnXX;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Decline sfXXDeleteReq"
RULE "Decline sfXXDeleteReq": sfXXDeleteReq |- sfSelectedXX;sfAllowDeleteOnXX~
VIOLATION (TXT "{EX} DelPair;sfXXDeleteReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfXXDeleteReq"
RULE "Service sfXXDeleteReq": sfXXDeleteReq;(sfSelectedXX /\ sfAllowDeleteOnXX) |- -V
VIOLATION (TXT "{EX} DelAtom;XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDeleteXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventDeleteXXXX", "AfterEventDeleteXXXX") ]

--[Switching between XXXXPortal and other portals (e.g. YYYYPortal or ZZZZPortal)]
-- The purpose of the following code is to allow applications to switch between the XXXXPortal (as defined below)
-- and other portals, e.g. a YYYYPortal or a ZZZZPortal that are defined elsewhere in the application.
--#IFNOT NoGoToXXXXPortalButton
sfCurrentPortalIfc :: SESSION * IfcName [UNI]    REPRESENT IfcName TYPE ALPHANUMERIC
sfChangeToPortalForXXReq :: SESSION * SESSION [PROP] -- Event, where the user requests to focus on a XX
ROLE ExecEngine MAINTAINS "Service sfChangeToPortalForXXReq"
RULE "Service sfChangeToPortalForXXReq": sfChangeToPortalForXXReq |- -I
VIOLATION (TXT "{EX} DelPair;sfChangeToPortalForXXReq;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} InsPair;sfCurrentPortalIfc;SESSION;", SRC I, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/XXXXPortal"
          )
-- The below interface can be called e.g. from `INTERFACE XXXXHeaderBar` to navigate to the XXXXPortal
POPULATION isInvisible CONTAINS [ ("GoToXXXXPortalButton", "GoToXXXXPortalButton") ]
INTERFACE "GoToXXXXPortalButton": I cRud BOX <DIV>
   [  "XXXXs": (I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~) \/ sfCreateXXIsAllowed cRud BOX <PROPBUTTON>
      [ property: sfChangeToPortalForXXReq cRUd
      , disabled: I /\ sfCurrentPortalIfc;"/XXXXPortal";sfCurrentPortalIfc~ cRud
      ]
   ]
--#ENDIF

--[INTERFACES]
--#IFNOT ApplicationDefinesAllXXInterfaces
-- Every interface defined here can optionally be left out by setting `No<interfacename>Ifc` when including this file.

--Navigation interfaces do not show up in the menu bar:
POPULATION isInvisible CONTAINS [ ("AfterEventCreateXXXX","AfterEventCreateXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventUpdateXXXX","AfterEventUpdateXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventCommitXXXX","AfterEventCommitXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventStartSelectXXXX","AfterEventStartSelectXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventEndSelectXXXX","AfterEventEndSelectXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventDeselectXXXX","AfterEventDeselectXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventDeleteXXXX","AfterEventDeleteXXXX") ]

--#IFNOT NoXXXXPortalIfc
POPULATION isInvisible CONTAINS [ ("XXXXPortal", "XXXXPortal")]
INTERFACE "XXXXPortal": sfCreateXXIsAllowed \/ sfAllowSelectOnXX;sfAllowSelectOnXX~ cRud BOX <DIV>
   [ "XXXXHeaderBar":  I INTERFACE "XXXXHeaderBar", -- Breadcrumbs, global navigation buttons
     "XXXXButtonBar":  I INTERFACE "XXXXPortalButtonBar", -- Navigation within XXXXs
     "XXXXWorkArea":   I INTERFACE "XXXXWorkArea"
   ]
--#ENDIF

--#IFNOT NoXXXXWorkAreaIfc -- This allows users to define their own WorkArea interface
POPULATION isInvisible CONTAINS [ ("XXXXWorkArea", "XXXXWorkArea") ]
INTERFACE "XXXXWorkArea": I[SESSION] cRud BOX <DIV>
   [ "Selecting": sfXXIsSelecting INTERFACE "SelectXX"
   , "Listing": (I-sfXXIsSelecting)-sfHasXXSelected INTERFACE "OverviewXX"
   --#IF NoEditingOfXXXXs
   , "Showing": (I-sfXXIsSelecting);sfSelectedXX INTERFACE "ShowXX"
   --#ELSE
   , "Initing": (I-sfXXIsSelecting);sfUpdateXX;(I-xxxIsInitialized) INTERFACE "InitXX"
   , "Showing": (I-sfXXIsSelecting);(sfSelectedXX-sfUpdateXX) INTERFACE "ShowXX"
   , "Updating": (I-sfXXIsSelecting);sfUpdateXX;xxxIsInitialized INTERFACE "EditXX"
   , "Updatebar": (I-sfXXIsSelecting) /\ sfXXIsUpdating INTERFACE "ButtonBarEditXX"
   --#ENDIF
   ]
--#ENDIF

--[Example INTERFACEs for portal construction]

INTERFACE "ShowXXAndSelectButton": I[XXXX] cRud BOX <CDIV>
   [ "XX": I, " ": I INTERFACE "XXSelectButton" ]

INTERFACE "XXSelectButton": I cRud BOX <PROPBUTTON>
   [ property: xxxSelectReq cRUd 
   , disabled: I - sfAllowSelectOnXX~;sfAllowSelectOnXX cRud
   ]

--#IFNOT NoXXXXSelectIfc -- This allows users to define their own selection interface
POPULATION IfcText CONTAINS [ "There is nothing to show" ]
POPULATION isInvisible CONTAINS [ ("XXXXSelect", "XXXXSelect") ]
INTERFACE "XXXXSelect": sfXXIsSelecting cRud BOX <DIV>
   [ "Nothing to do": (I - sfAllowSelectOnXX;sfAllowSelectOnXX~);V;"There is nothing to show"[IfcText] <STRONG>
   , "Selecting XXs": sfAllowSelectOnXX cRud BOX <CDIV>
      [ "XXXX": I[XXXX] cRud <XXXXSummary>
      , "Select": I cRud BOX <PROPBUTTON> [ property: xxxSelectReq cRUd ]
      ]
   ]
--#ENDIF

--#IFNOT NoXXXXOverviewIfc -- This allows users to define their own Overview interface
POPULATION IfcText CONTAINS [ "There is nothing to show" ]
POPULATION isInvisible CONTAINS [ ("XXXXOverview", "XXXXOverview") ]
INTERFACE "XXXXOverview": I cRud BOX <DIV>
   [ "Nothing to do": (I - sfAllowSelectOnXX;sfAllowSelectOnXX~);V;"There is nothing to show"[IfcText] <STRONG>
   , "Listing XXs": sfAllowSelectOnXX cRud <XXXXSummary>
   ]
--#ENDIF

--[INTERFACEs - Button bars]
-- Button bars can be used in Interfaces for (re)setting events for the purpose of CRUDing XXXX's

--#IFNOT NoXXXXPortalButtonBarIfc
-- The following buttonbar is designed for the general context in which a user wants to work with XX's
POPULATION IfcText CONTAINS [ "There is no current XX." ]
POPULATION IfcText CONTAINS [ "Please contact your system administrator." ]
POPULATION IfcText CONTAINS [ "You may create one." ]
POPULATION IfcText CONTAINS [ "Please select one." ]
POPULATION IfcText CONTAINS [ "Please select or create one." ]
POPULATION IfcText CONTAINS [ "Current XX: " ]
POPULATION IfcText CONTAINS [ "unknown" ]

POPULATION isInvisible CONTAINS [ ("XXXXPortalButtonBar", "XXXXPortalButtonBar")]
INTERFACE "XXXXPortalButtonBar": "_SESSION"[SESSION] cRud BOX <CDIV>
   [ "No XX selected": sfNoXXSelected cRud BOX <CDIV>
      [ "just for vertical alignment": I cRud BOX <CDIV>
         [  "MSG: No current XX": V;"There is no current XX."[IfcText] cRud <STRONG>
         ]
      , "No XX selectable": I-sfAllowSelectOnXX;sfAllowSelectOnXX~ BOX <CDIV>
         [ "MSG: Get help": (I-sfCreateXXIsAllowed);V;"Please contact your system administrator."[IfcText] cRud <STRONG>
         , "MSG: Create XX": sfCreateXXIsAllowed;V;"You may create one."[IfcText] cRud <STRONG>
         ]
      , "XX can be selected": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~ cRud BOX <CDIV>
         [ "MSG: Select an XX": (sfXXIsSelecting-sfCreateXXIsAllowed);V;"Please select one."[IfcText] cRud <STRONG>
         , "MSG: Select or create an XX": (sfXXIsSelecting/\sfCreateXXIsAllowed);V;"Please select or create one."[IfcText] cRud <STRONG>
         ] 
      , "Select": (I-sfXXIsSelecting) /\ sfAllowSelectOnXX;sfAllowSelectOnXX~ cRud BOX <PROPBUTTON> [ property: sfXXSelectReq cRUd ]
      , "New": sfCreateXXIsAllowed cRud BOX <PROPBUTTON> [ property: sfXXCreateReq cRUd ]
      ]
   , "XX is selected, NOT editing": sfHasXXSelected - sfXXIsUpdating  cRud BOX <CDIV>
      [ "MSG: Current XX": V;"Current XX: "[IfcText] cRud <STRONG>
      , "XX name": sfSelectedXX cRud <XXXXSummary>
      , "Change": I /\ sfSelectedXX;-I;sfAllowSelectOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXSelectReq cRUd
         , disabled: sfXXIsSelecting cRud
         ]
      , "Edit": I /\ sfSelectedXX;sfAllowUpdateOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXUpdateReq cRUd
         , disabled: I /\ sfUpdateXX;sfAllowUpdateOnXX~ cRud
         ]
      , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXDeleteReq cRUd
   --    , disabled: I cRud
         ]
      , "New": sfCreateXXIsAllowed cRud BOX <PROPBUTTON>
         [ property: sfXXCreateReq cRUd
         , disabled: I /\ sfSelectedXX;sfUpdateXX~ cRud -- because that interferes with the updating of XX
         ]
      , "Overview": sfHasXXSelected cRud BOX <PROPBUTTON> -- This is deselecting the current XX
         [ property: sfXXDeselectReq cRUd
   --    , disabled: sfXXIsSelecting cRud
         ]
      ]
--#IFNOT NoEditingOfXXXXs
   , "XX is (selected, AND) editing": sfHasXXSelected /\ sfXXIsUpdating cRud BOX <CDIV>
      [ "MSG: Current XX": V;"Current XX: "[IfcText] cRud <STRONG>
      , "unknown": sfSelectedXX;(I-xxxIsInitialized);V;"unknown"[IfcText] cRud
      , "XX name": sfSelectedXX;xxxIsInitialized cRud <XXXXSummary>
      , "Change": I /\ sfSelectedXX;-I;sfAllowSelectOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXSelectReq cRUd
         , disabled: sfXXIsSelecting cRud
         ]
      , "Edit": I /\ sfSelectedXX;sfAllowUpdateOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXUpdateReq cRUd
         , disabled: I /\ sfUpdateXX;sfAllowUpdateOnXX~ cRud
         ]
      , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXDeleteReq cRUd
   --    , disabled: I cRud
         ]
      , "New": sfCreateXXIsAllowed cRud BOX <PROPBUTTON> 
         [ property: sfXXCreateReq cRUd
         , disabled: I /\ sfSelectedXX;sfUpdateXX~ cRud -- because that interferes with the updating of XX
         ]
      , "Overview": sfHasXXSelected cRud BOX <PROPBUTTON> -- This is deselecting the current XX
         [ property: sfXXDeselectReq cRUd
   --    , disabled: sfXXIsSelecting cRud
         ]
      ]
--#ENDIF
   ]
--#ENDIF

--#IFNOT NoButtonBarEditXXIfc
-- The following buttonbar is designed for the context in which the user is updating (editing) a specific XX
POPULATION isInvisible CONTAINS [ ("ButtonBarEditXX", "ButtonBarEditXX")]
INTERFACE "ButtonBarEditXX": "_SESSION"[SESSION] cRud BOX <CDIV>
   [ "OK": sfXXIsUpdating cRud BOX <PROPBUTTON>
      [ property: sfXXCommitReq cRUd
      , disabled: I /\ sfUpdateXX;(I-xxxIsClean);sfUpdateXX~ cRud
      ]
   , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
      [ property: sfXXDeleteReq cRUd
--    , disabled: I cRud
      ]
   ]
--#ENDIF
--#ENDIF

ENDCONTEXT