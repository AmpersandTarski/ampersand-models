CONTEXT "XXXX_ButtonCRUD" IN ENGLISH
{- This file serves as a template for creating, selecting, editing/updating, and deleting objects of type XXXX, where
   - the data (the XXXX that are worked on, i.e. the scope) is given by session variables
   - the relations that signal events/changes are also mostly session-related (some are XXXX-related)
   - ExecEngine rules that implement the CRUD functionalities for XXXX-objects.
   - INTERFACEs are provided conditionally (i.e. when you include this file, you can specify to leave them out so you can have your own)
   If you don't use them, they may still serve as templates foryour own.

This file is designed such that you are not required to change anything
apart from the strings `XXXX`, `xxx` and `XX` (see point 1 below).
However, you do need to add some stuff in your own project.

Here are the steps you need to follow in order to use this file as a template for ButtonCRUDding your own Objects:

--[XXXX_ButtonCRUD - Prerequisites]
-- 0. The working of ButtonCRUD is based on the idea that a SESSION is the users working context.
--    As a result, most interfaces take a SESSION as their source atom. One of the consequences of this is
--    that such interfaces show up in the NavBar, which has a very polluting effect. If you want to prevent
--    this from happening, you must copy the following code to your main script:

RELATION isVisible[PF_NavMenuItem*PF_NavMenuItem] [PROP] -- Defined in SystemContext.adl
RELATION isInvisible[PF_NavMenuItem*PF_NavMenuItem] [PROP]
ROLE ExecEngine MAINTAINS "DelPair `isVisible`"
RULE "DelPair `isVisible`": isInvisible |- I-isVisible
VIOLATION (TXT "{EX} DelPair;isVisible;PF_NavMenuItem;", SRC I, TXT ";PF_NavMenuItem;", TGT I)
ROLE ExecEngine MAINTAINS "InsPair `isInvisible`"
RULE "InsPair `isInvisible`": I-isInvisible |- isVisible
VIOLATION (TXT "{EX} InsPair;isVisible;PF_NavMenuItem;", SRC I, TXT ";PF_NavMenuItem;", TGT I)

--[XXXX_ButtonCRUD - Making the XXXX_ButtonCRUD available]
-- 1. Copy this file and do some renaming:
--    - copy this file to your project, and rename it as you find appropriate.
--    - rename `XXXX` into `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `xxx` into whatever few characters you use to name relations whose SRC is `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `XX` into `ShortName` that you use as an abbreviation for `ThePossiblyLengthyNameOfTheConceptIUse`
--      but of course, if `ThePossiblyLengthyNameOfTheConceptIUse` is short, then it can be the same as `ShortName`.
--    - INCLUDE this file into your script, and apply any conditional-compiler variables that you might need, e.g. as follows

INCLUDE "XXXX_ButtonCRUD.adl" -- --# [ "No<interfacename>Ifc", "ApplicationDefinesAllXXInterfaces", "NoEditingOfXXXXs" ]

--[XXXX_ButtonCRUD - Rules that maintain required populations]
-- 2a. You _MUST_ create rules that maintain the population of (the equivalents of)
--    - `xxxIsClean` :: XXXX * XXXX [PROP] -- Property that allows XXXX to be accepted/registered in the database
--    Here is some example-code that you can use if you replace **expression4xxxIsClean** with what you think is appropriate

xxxIsClean :: XXXX * XXXX [PROP] -- define relation xxxIsClean as shorthand for I /\ expression4xxxIsClean
ROLE ExecEngine MAINTAINS "Equivalence - InsPair xxxIsClean"
RULE "Equivalence - InsPair xxxIsClean": I /\ expression4xxxIsClean |- xxxIsClean
VIOLATION (TXT "{EX} InsPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)
ROLE ExecEngine MAINTAINS "Equivalence - DelPair xxxIsClean"
RULE "Equivalence - DelPair xxxIsClean": xxxIsClean |- I /\ expression4xxxIsClean
VIOLATION (TXT "{EX} DelPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)

-- 2b. You _MUST_ create one or more rules that maintain the population of (the equivalents of)
--    - `sfCreateXXIsAllowed` :: SESSION * SESSION [PROP] -- User is allowed to create a new XX in the session
--    - `sfAllowSelectOnXX`   :: SESSION * XXXX           -- User is allowed to select (view) the XX in the session
--    - `sfAllowUpdateOnXX`   :: SESSION * XXXX           -- User is allowed to update (edit) the XX in the session
--    - `sfAllowDeleteOnXX`   :: SESSION * XXXX           -- User is allowed to delete the XX in the session
--    and/or make sure that you have INTERFACEs by which this population can be maintained. 
--    If you want everyone to be able to do everything with XXs, you can use the following example code:

ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to create a XXXX"
RULE "XXXX_ButtonCRUD allows all users to create a XXXX": I |- sfCreateXXIsAllowed
VIOLATION (TXT "InsPair;sfCreateXXIsAllowed;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX"
RULE "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX": V |- sfAllowSelectOnXX /\ sfAllowUpdateOnXX /\ sfAllowDeleteOnXX
VIOLATION (TXT "InsPair;sfAllowSelectOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "InsPair;sfAllowUpdateOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "InsPair;sfAllowDeleteOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          )

--[XXXX_ButtonCRUD - Define VIEWs to summarize what XXXX is about, for several purposes]
-- 3a. You _MUST_ define a VIEW called `XXSelectionSummary`, which is used in the selection dropdown box
-- 3b. You _MUST_ define a VIEW called `XXOverviewSummary`, which is used in the default Overview view
--    In the code provided below, change `I` to something more appropriate

VIEW XXSelectionSummary: XXXX { "Summary": I } ENDVIEW
VIEW XXOverviewSummary:  XXXX { "Summary": I } ENDVIEW

--[XXXX_ButtonCRUD - Interfaces]
-- 4a. The code in this template file has several predefined interfaces that need to be integrated with your application.
--    One way to do that is to copy them into your own code and adapt them there 
--    (you can prevent them being compiled in this file by specifying conditional-compilation variable `No<interfacename>Ifc`)
--    Alternatively, you can use them (i.e.: refer to them from your application script).
--    In that case, you still must define some interfaces, specifically the following:
--    - `INTERFACE "ShowXX": I[XXXX]` (etc.) -- This interface must allow the user to see the details of the XXXX
--    - `INTERFACE "InitXX": I[XXXX]` (etc.) -- This interface must allow the user to make a just created XXXX 'clean'
--    - `INTERFACE "EditXX": I[XXXX]` (etc.) -- This interface must allow the user to edit the XXXX
--    N.B.: Define the interfaces such that they do not show when there is nothing to do.
--          This means that the toplevel should be <DIV>, <CDIV>, <HROWS>, <HCOLS> or such.

-- 4b. If you want to use the interfaces provided in this file, you must also provide
--    - An interface that allows the user to see an overview of the XXXXs that he is allowed to work with, using
--      `INTERFACE "OverviewXX": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~`
--    If you do not have special requirements, you can use the following code to provide these interfaces:

POPULATION isInvisible CONTAINS [ ("OverviewXX","OverviewXX") ]
INTERFACE "OverviewXX": I[SESSION] INTERFACE "XXXXOverview"

--[XXXX_ButtonCRUD - Navigation]
-- 5. ButtonCRUD uses events (clicking a button) to compute the state of affairs.
--    Every such state typically has its own interface associated with it. 
--    In order to get a smooth user experience, changes of state should be accompanied with switching of interfaces.
--    In order to be flexible and give application developers the control they need,
--    every change in state will navigate to an interface with a predefined name, as listed below
--    You can easily define these interfaces as in instance of an existing interface, as exemplified in the code below.
--    The `INTERFACE "XXXXPortal"` has been designed to accommodate every state.
--    Thus, you can use it as the generic interface to navigate to.
--    Note that `INTERFACE "XXXXPortal"` has been made invisible, because in practice it will be called from the application's portal.
--    Conversely: be sure that you create a portal from which to call it if needed.

INTERFACE "AfterEventSelectXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- Another XXXX has been selected (to further focus on)
INTERFACE "AfterEventDeselectXXXX": I[SESSION] INTERFACE "XXXXPortal" -- Currently selected XXXX has been deselected (so go to some overview)
INTERFACE "AfterEventUpdateXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- Updating has started (ready to edit)
INTERFACE "AfterEventDoneUpdXXXX":  I[SESSION] INTERFACE "XXXXPortal" -- Updating has terminated (done editing)
INTERFACE "AfterEventDeleteXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- XXXX has been deleted (so go to some overview)

--[XXXX_ButtonCRUD - Switching between different portals]
-- 6. If you choose to use `INTERFACE "XXXXPortal"` that is provided by this code
--    you then _MUST_ create `INTERFACE "XXXXHeaderBar"`
--    You may want this interface to provide a breadcrumb and/or buttons for navigation purposes.
--    Notes:
--    - this file specifies `INTERFACE "GoToXXXXPortalButton"`, that contains a single button that
--      when clicked, navigates the user to `INTERFACE "XXXXPortal"`.
--      You can use this as part of the headerbar navigation buttons.
--    - make sure you properly initialize the switching between portals, e.g. by checking whether
--      `sfCurrentPortalIfc` is populated, and if not, create a request to do so. 
--    Here is some example code for you to use and adapt in your application script:

ROLE ExecEngine MAINTAINS "Initialize sfCurrentPortalIfc"
RULE "Initialize sfCurrentPortalIfc": I - sfCurrentPortalIfc;sfCurrentPortalIfc~ |- sfChangeToPortalForXXReq
VIOLATION (TXT "{EX} InsPair;sfChangeToPortalForXXReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

POPULATION isInvisible CONTAINS [ ("XXXXHeaderBar", "XXXXHeaderBar") ]
INTERFACE "XXXXHeaderBar" FOR User: "_SESSION"[SESSION] cRud BOX <CDIV>
   [ "User": I cRud BOX <CDIV>
      [ "User": sessionAccount;accPersonRef cRud
      , "Logout": I cRud BOX <PROPBUTTON> [ property : sessionLogoutReq cRUd ]
      ]
   , "Portal Switch buttons": I[SESSION] cRud BOX <CDIV>
      [ "XXXXs" : I INTERFACE "GoToXXXXPortalButton"
      , "YYYYs" : I INTERFACE "GoToYYYYPortalButton"
      , "ZZZZs" : I INTERFACE "GoToZZZZPortalButton"
      ]
   ]
-}

--[Basics - Initialization, Being Clean, and (Auto)Deleting XXs]
xxxIsPersistent  :: XXXX * XXXX [PROP] -- Property, stating that XX should not be deleted by ButtonCRUD functionality
xxxIsClean       :: XXXX * XXXX [PROP] -- Property, stating that XX fulfills the minimum requirements for being registered
xxxIsInitialized :: XXXX * XXXX [PROP] -- Property, stating that XX has at some point in time been clean

RULE "Please make XXXX 'clean', or delete it": 
   xxxIsInitialized |- xxxIsPersistent \/ xxxIsClean \/ sfUpdatingXX~;sfUpdatingXX

ROLE ExecEngine MAINTAINS "InsPair `xxxIsInitialized`" -- This rule prevents inadvertent deletion of XX atoms when DB is inited
RULE "InsPair `xxxIsInitialized`": xxxIsClean |- xxxIsInitialized
VIOLATION (TXT "{EX} InsPair;xxxIsInitialized;XXXX;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Delete XX if it is not persistent and created imcomplete"
RULE "Delete XX if it is not persistent and created imcomplete": 
   I-xxxIsPersistent |- xxxIsClean \/ sfUpdatingXX~;sfUpdatingXX \/ sfUpdReqForXX~;sfUpdReqForXX
VIOLATION (TXT "{EX} DelAtom;XXXX;", SRC I)

--[XXXX Selection - Basics]
-- Selecting is done using `BOX <OBJECTDROPDOWN>`, which populates `sfSelReqForXX`
-- Selecting a new XXXX terminates any editing/updating functions.
sfAllowSelectOnXX :: SESSION * XXXX -- Permission, where the user is allowed to select (view) the XX
sfSelectedXX :: SESSION * XXXX [UNI] -- the XXXX-atom that is selected in/focussed on by the session

RULE "An XXXX can only be selected if that is allowed": sfSelectedXX |- sfAllowSelectOnXX

sfSelReqForXX :: SESSION * XXXX [UNI] -- Event, that requests XXXX to be selected

ROLE ExecEngine MAINTAINS "Decline `sfSelReqForXX`"
RULE "Decline `sfSelReqForXX`": sfSelReqForXX |- sfAllowSelectOnXX
VIOLATION (TXT "{EX} DelPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Service `sfSelReqForXX`"
RULE "Service `sfSelReqForXX`": sfSelReqForXX /\ sfAllowSelectOnXX |- sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventSelectXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventSelectXXXX", "AfterEventSelectXXXX") ]

{-- In cases where a new XXXX is selected, we may need to refresh the (entire) web page.
-- However `SetNavToOnCommit` does not do that, so we need a work-around, that consists of
-- us alternatingly navigating to two different interfaces that will refer to the one we need.
-- To do this, we use two slighly different ways of servicing a `sfSelReqForXX`.
-- The alternating nature of this is implemented using `sfXXSelSwitchProp`.
sfXXSelSwitchProp :: SESSION * SESSION [PROP]
ROLE ExecEngine MAINTAINS "Service `sfSelReqForXX`"
RULE "Service `sfSelReqForXX`": sfSelReqForXX /\ sfSelectedXX;sfAllowSelectOnXX~ |- sfXXSelSwitchProp
VIOLATION (TXT "{EX} DelPair;sfSelReqForXX;SESSION;", SRC I, TXT ";SESSION;", TGT I
      --  ,TXT "{EX} DelPair;sfUpdatingXX;SESSION;", SRC I, TXT ";XXXX;", TGT sfUpdatingXX
          ,TXT "{EX} InsPair;sfXXSelSwitchProp;SESSION;", SRC I, TXT ";SESSION;", TGT I -- The next time, rule `AlternativeService sfSelReqForXX` will fire
          ,TXT "{EX} SetNavToOnCommit;/AfterEventSelectXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventSelectXXXX", "AfterEventSelectXXXX") ]

ROLE ExecEngine MAINTAINS "AlternativeService `sfSelReqForXX`"
RULE "AlternativeService `sfSelReqForXX`": sfSelReqForXX /\ sfSelectedXX;sfAllowSelectOnXX~ |- -sfXXSelSwitchProp
VIOLATION (TXT "{EX} DelPair;sfSelReqForXX;SESSION;", SRC I, TXT ";SESSION;", TGT I
      --  ,TXT "{EX} DelPair;sfUpdatingXX;SESSION;", SRC I, TXT ";XXXX;", TGT sfUpdatingXX
          ,TXT "{EX} DelPair;sfXXSelSwitchProp;SESSION;", SRC I, TXT ";SESSION;", TGT I -- The next time, rule `Service sfSelReqForXX` will fire
          ,TXT "{EX} SetNavToOnCommit;/AfterEventSelectXXXXAlternate"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventSelectXXXXAlternate", "AfterEventSelectXXXXAlternate") ]
INTERFACE AfterEventSelectXXXXAlternate: I[SESSION] INTERFACE AfterEventSelectXXXX --}

--[XXXX Selection - Properties that flag (No)Selection]
-- Sometimes we need to know whether or not an XX is focused on. Therefore, we define properties that we can use for this
sfXXIsSelected    :: SESSION * SESSION [PROP] -- Status/Property, where the session has an XX that the user focuses on
sfXXIsNotSelected :: SESSION * SESSION [PROP] -- Status/Property, where the session does not have an XX that the user can focus on
ROLE ExecEngine MAINTAINS "InsPair sfXXIsSelected/DelPair xfXXIsUnSelected"
RULE "InsPair sfXXIsSelected/DelPair xfXXIsUnSelected": I /\ sfSelectedXX;sfSelectedXX~ |- sfXXIsSelected-sfXXIsNotSelected
VIOLATION (TXT "{EX} InsPair;sfXXIsSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} DelPair;sfXXIsNotSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          )
ROLE ExecEngine MAINTAINS "DelPair sfXXIsSelected/InsPair xfXXIsUnSelected"
RULE "DelPair sfXXIsSelected/InsPair xfXXIsUnSelected": I - sfSelectedXX;sfSelectedXX~ |- sfXXIsNotSelected-sfXXIsSelected
VIOLATION (TXT "{EX} InsPair;sfXXIsNotSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} DelPair;sfXXIsSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          )

--[XXXX Selection - Selecting a specific XXXX]
xxxSelectReq :: XXXX * XXXX [PROP] -- Event, that requests to select the XXXX (to further focus on) if not already selected
ROLE ExecEngine MAINTAINS "Decline xxxSelectReq"
RULE "Decline xxxSelectReq": xxxSelectReq |- sfAllowSelectOnXX~;"_SESSION";sfAllowSelectOnXX
VIOLATION (TXT "{EX} DelPair;xxxSelectReq;XXXX;", SRC I, TXT ";XXXX;", TGT I
          )
ROLE ExecEngine MAINTAINS "Service xxxSelectReq"
RULE "Service xxxSelectReq": "_SESSION";sfAllowSelectOnXX;xxxSelectReq |- -V
VIOLATION (TXT "{EX} DelPair;xxxSelectReq;XXXX;", TGT I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          )

--[XXXX Selection - Automated selections]
ROLE ExecEngine MAINTAINS "Auto Service sfXXSelectReq - there is only one choice" -- If there's only one choice, then take it.
RULE "Auto Service sfXXSelectReq - there is only one choice": sfAllowSelectOnXX - sfAllowSelectOnXX;-I |- sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I)

--[XXXX Selection - Deselecting the selected XXXX]
sfXXDeselectReq :: SESSION * SESSION [PROP] -- Event, that requests to deselect the selected XXXX
ROLE ExecEngine MAINTAINS "Decline sfXXDeselectReq" -- Decline servicing sfXXDeselectReq
RULE "Decline sfXXDeselectReq": sfXXDeselectReq |- sfSelectedXX;sfSelectedXX~
VIOLATION (TXT "{EX} DelPair;sfXXDeselectReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfXXDeselectReq" -- Service sfXXDeselectReq when set
RULE "Service sfXXDeselectReq": sfXXDeselectReq;sfSelectedXX |- -V
VIOLATION (TXT "{EX} DelPair;sfXXDeselectReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} DelPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDeselectXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventDeselectXXXX", "AfterEventDeselectXXXX") ]

--[XXXX Updating - Basics]
-- Updating is done using `BOX <OBJECTDROPDOWN>`, which populates `sfUpdReqForXX`
-- Updating ensures that the updated XX becomes and remains the selected XXXX for at least as long as it is being updated.
-- Note that when one XX is being updated and at that time another one is being selected another XXXX while 
sfAllowUpdateOnXX :: SESSION * XXXX -- Permission, where the user is allowed to update (edit) the XX
sfUpdatingXX :: SESSION * XXXX [UNI] -- the XXXX-atom that is selected in/focussed on by the session

RULE "An XXXX can only be updated if that is allowed": sfUpdatingXX |- sfAllowUpdateOnXX
RULE "A session that is allowed to UPDATE an XX must also be allowed to SELECT an XX": sfAllowUpdateOnXX |- sfAllowSelectOnXX
-- We do not provide ExecEngine solutions here so that errors in the population of `sfAllowUpdateOnXX` do not go unnoticed

ROLE ExecEngine MAINTAINS "Auto depopulate sfUpdatingXX"
RULE "Auto depopulate sfUpdatingXX": sfUpdatingXX |- sfSelectedXX
VIOLATION (TXT "{EX} DelPair;sfUpdatingXX;SESSION;", SRC I, TXT ";XXXX;", TGT I)

sfUpdReqForXX :: SESSION * XXXX [UNI] -- Event, that requests XXXX to be updated

ROLE ExecEngine MAINTAINS "Decline `sfUpdReqForXX`"
RULE "Decline `sfUpdReqForXX`": sfUpdReqForXX |- sfAllowUpdateOnXX
VIOLATION (TXT "{EX} DelPair;sfUpdReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Service `sfUpdReqForXX`"
RULE "Service `sfUpdReqForXX`": sfUpdReqForXX /\ sfAllowUpdateOnXX |- sfUpdatingXX /\ sfSelReqForXX /\ sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfUpdatingXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventUpdateXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventUpdateXXXX", "AfterEventUpdateXXXX") ]

--[XXXX Updating - Properties that flag (No)Updation]
-- Sometimes we need to know whether or not an XX is focused on. Therefore, we define properties that we can use for this
sfXXIsUpdating :: SESSION * SESSION [PROP] -- Status/Property, where the session has an XX that the user focuses on for updating/editing
ROLE ExecEngine MAINTAINS "InsPair sfXXIsUpdating"
RULE "InsPair sfXXIsUpdating": I /\ sfUpdatingXX;sfUpdatingXX~ |- sfXXIsUpdating
VIOLATION (TXT "{EX} InsPair;sfXXIsUpdating;SESSION;", SRC I, TXT ";SESSION;", TGT I)
ROLE ExecEngine MAINTAINS "DelPair sfXXIsUpdating"
RULE "DelPair sfXXIsUpdating": sfXXIsUpdating |- I /\ sfUpdatingXX;sfUpdatingXX~
VIOLATION (TXT "{EX} DelPair;sfXXIsUpdating;SESSION;", SRC I, TXT ";SESSION;", TGT I)

--[XXXX Updating - Updating a specified XXXX (that may not have been selected)]
xxxUpdateReq :: XXXX * XXXX [PROP] -- Event, that requests to select the XXXX (to further focus on) if not already selected
ROLE ExecEngine MAINTAINS "Decline xxxUpdateReq"
RULE "Decline xxxUpdateReq": xxxUpdateReq |- sfAllowUpdateOnXX~;"_SESSION";sfAllowUpdateOnXX
VIOLATION (TXT "{EX} DelPair;xxxUpdateReq;XXXX;", SRC I, TXT ";XXXX;", TGT I
          )
ROLE ExecEngine MAINTAINS "Service xxxUpdateReq"
RULE "Service xxxUpdateReq": "_SESSION";sfAllowUpdateOnXX;xxxUpdateReq |- -V
VIOLATION (TXT "{EX} DelPair;xxxUpdateReq;XXXX;", TGT I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfUpdReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          )

--[XXXX Updating - Updating the already selected XXXX]
sfEditSelectedXXReq :: SESSION * SESSION [PROP]
ROLE ExecEngine MAINTAINS "Decline sfEditSelectedXXReq"
RULE "Decline sfEditSelectedXXReq": sfEditSelectedXXReq |- sfSelectedXX;sfAllowUpdateOnXX~
VIOLATION (TXT "{EX} DelPair;sfEditSelectedXXReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfEditSelectedXXReq"
RULE "Service sfEditSelectedXXReq": sfEditSelectedXXReq;(sfSelectedXX /\ sfAllowUpdateOnXX) |- sfUpdatingXX
VIOLATION (TXT "{EX} DelPair;sfEditSelectedXXReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} InsPair;sfUpdReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          )

--[XXXX Updating - Terminate updating of XXXX]
sfXXDoneUpdReq :: SESSION * SESSION [PROP] -- Event, that requests updating/editing of XXXX to terminate
ROLE ExecEngine MAINTAINS "Decline sfXXDoneUpdReq" -- Service sfXXDoneUpdReq when set
RULE "Decline sfXXDoneUpdReq": sfXXDoneUpdReq |- sfUpdatingXX;sfUpdatingXX~
VIOLATION (TXT "{EX} DelPair;sfXXDoneUpdReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfXXDoneUpdReq" -- Service sfXXDoneUpdReq when set
RULE "Service sfXXDoneUpdReq": sfXXDoneUpdReq;sfUpdatingXX |- -V
VIOLATION (TXT "{EX} DelPair;sfXXDoneUpdReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} DelPair;sfUpdReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfUpdatingXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDoneUpdXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventDoneUpdXXXX", "AfterEventDoneUpdXXXX") ]

--[XXXX Creation - and automatically starting to update]
-- An XX is created when `sfXXCreateReq` is populated, and `sfCreateXXIsAllowed` is set (permits the creation)
-- When an XX is created, it is usually not clean, so we take it to be updated after creation.
-- Because of this, we do not allow for the creation of an XX when an XX is being updated.
sfCreateXXIsAllowed :: SESSION * SESSION [PROP] -- Permission, where the user is allowed to request the creation of a new XX
sfXXCreateReq       :: SESSION * SESSION [PROP] -- Event, where the user requests to create a new XX

ROLE ExecEngine MAINTAINS "Decline/Prevent sfXXCreateReq" -- i.e. if there is no permission, or an XX is being updated in this session.
RULE "Decline/Prevent sfXXCreateReq": sfXXCreateReq |- sfCreateXXIsAllowed - sfXXIsUpdating
VIOLATION (TXT "{EX} DelPair;sfXXCreateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Service sfXXCreateReq" -- Create an XX if there is no XX being edited, and creation is allowed
RULE "Service sfXXCreateReq": sfXXCreateReq /\ sfCreateXXIsAllowed |- sfXXIsUpdating
VIOLATION (TXT "{EX} InsAtom;XXXX"
          ,TXT "{EX} InsPair;sfAllowSelectOnXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfAllowUpdateOnXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfAllowDeleteOnXX;SESSION;", SRC I, TXT ";XXXX;_NEW"

          ,TXT "{EX} InsPair;sfUpdReqForXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} DelPair;sfXXCreateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          )

--[XXXX Deleting - Basics ]
sfAllowDeleteOnXX :: SESSION * XXXX -- Permission, where the user is allowed to delete the XX
RULE "A session that is allowed to DELETE an XX must also be allowed to SELECT that XX": sfAllowDeleteOnXX |- sfAllowSelectOnXX
-- We do not provide ExecEngine solutions here so that errors in the population of `sfAllowDeleteOnXX` do not go unnoticed

sfXXDeleteReq :: SESSION * SESSION [PROP] -- Event, where the user requests the XX to be (completely) deleted

ROLE ExecEngine MAINTAINS "Decline sfXXDeleteReq"
RULE "Decline sfXXDeleteReq": sfXXDeleteReq |- sfSelectedXX;sfAllowDeleteOnXX~
VIOLATION (TXT "{EX} DelPair;sfXXDeleteReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfXXDeleteReq"
RULE "Service sfXXDeleteReq": sfXXDeleteReq;(sfSelectedXX /\ sfAllowDeleteOnXX) |- -V
VIOLATION (TXT "{EX} DelAtom;XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDeleteXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventDeleteXXXX", "AfterEventDeleteXXXX") ]

--[Switching between XXXXPortal and other portals (e.g. YYYYPortal or ZZZZPortal)]
-- The purpose of the following code is to allow applications to switch between the XXXXPortal (as defined below)
-- and other portals, e.g. a YYYYPortal or a ZZZZPortal that may be defined elsewhere in the application.
--#IFNOT NoGoToXXXXPortalButton
sfCurrentPortalIfc :: SESSION * IfcName [UNI]    REPRESENT IfcName TYPE ALPHANUMERIC
sfChangeToPortalForXXReq :: SESSION * SESSION [PROP] -- Event, where the user requests to focus on a XX
ROLE ExecEngine MAINTAINS "Service sfChangeToPortalForXXReq"
RULE "Service sfChangeToPortalForXXReq": sfChangeToPortalForXXReq |- -I
VIOLATION (TXT "{EX} DelPair;sfChangeToPortalForXXReq;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} InsPair;sfCurrentPortalIfc;SESSION;", SRC I, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/XXXXPortal"
          )
-- The below interface can be called e.g. from `INTERFACE "XXXXHeaderBar"` to navigate to the XXXXPortal
POPULATION isInvisible CONTAINS [ ("GoToXXXXPortalButton", "GoToXXXXPortalButton") ]
INTERFACE "GoToXXXXPortalButton": I[SESSION] cRud BOX <DIV>
   [  "XXXXs": (I[SESSION] /\ sfAllowSelectOnXX;sfAllowSelectOnXX~) \/ sfCreateXXIsAllowed cRud BOX <PROPBUTTON>
      [ property: sfChangeToPortalForXXReq cRUd
      , disabled: I /\ sfCurrentPortalIfc;"/XXXXPortal";sfCurrentPortalIfc~ cRud
      ]
   ]
--#ENDIF NoGoToXXXXPortalButton

--[INTERFACES]
--#IFNOT ApplicationDefinesAllXXInterfaces
-- Every interface defined here can optionally be left out by setting `No<interfacename>Ifc` when including this file.

--#IFNOT NoXXXXPortalIfc
POPULATION isInvisible CONTAINS [ ("XXXXPortal", "XXXXPortal")]
INTERFACE "XXXXPortal": (I[SESSION] /\ sfAllowSelectOnXX;sfAllowSelectOnXX~) \/ sfCreateXXIsAllowed cRud BOX <DIV>
   [ "XXXXHeaderBar":  I INTERFACE "XXXXHeaderBar", -- Breadcrumbs, global navigation buttons
     "XXXXButtonBar":  I INTERFACE "XXXXPortalButtonBar", -- Navigation within XXXXs
     "XXXXWorkArea":   I INTERFACE "XXXXWorkArea"
   ]
--#ENDIF NoXXXXPortalIfc

--#IFNOT NoXXXXWorkAreaIfc -- This allows users to define their own WorkArea interface
POPULATION isInvisible CONTAINS [ ("XXXXWorkArea", "XXXXWorkArea") ]
INTERFACE "XXXXWorkArea": I[SESSION] cRud BOX <DIV>
   [ "Listing XX": I-sfXXIsSelected INTERFACE "OverviewXX"
   --#IF NoEditingOfXXXXs
   , "Showing XX": sfSelectedXX INTERFACE "ShowXX"
   --#ELSE
   , "Showing XX": sfSelectedXX-sfUpdatingXX INTERFACE "ShowXX"
   , "Initing XX": sfUpdatingXX;(I-xxxIsInitialized) INTERFACE "InitXX"
   , "Updating XX": sfUpdatingXX;xxxIsInitialized INTERFACE "EditXX"
      --#IF ButtonBarEditXXIfc
      , "Updatebar XX": sfXXIsUpdating INTERFACE "ButtonBarEditXX"
      --#ENDIF ButtonBarEditXXIfc
   --#ENDIF NoEditingOfXXXXs
   ]
--#ENDIF NoXXXXWorkAreaIfc

--[Example INTERFACEs for portal construction]

--#IFNOT NoXXXXSelectIfc -- This allows users to define their own selection interface
POPULATION isInvisible CONTAINS [ ("XXXXSelect", "XXXXSelect") ]
INTERFACE "XXXXSelect": "_SESSION"[SESSION] cRud BOX <DIV>
   [ "Non-editing mode": I-sfXXIsUpdating cRud BOX <OBJECTDROPDOWN>
      [ "selectfrom": sfAllowSelectOnXX cRud <XXSelectionSummary>
      , "setrelation": sfSelReqForXX cRUd
--    , "selectflag":  cRUd
      ]
   , "Editing mode": sfXXIsUpdating cRud BOX <OBJECTDROPDOWN>
      [ "selectfrom": sfUpdatingXX cRud <XXSelectionSummary>
      , "setrelation": sfUpdReqForXX cRUd
--    , "selectflag":  cRUd
      ]
   ]
--#ENDIF NoXXXXSelectIfc

--#IFNOT NoXXXXOverviewIfc -- This allows users to define their own Overview interface
POPULATION IfcText CONTAINS [ "There is nothing to show" ]
POPULATION isInvisible CONTAINS [ ("XXXXOverview", "XXXXOverview") ]
INTERFACE "XXXXOverview": I cRud BOX <DIV>
   [ "Nothing to do": (I - sfAllowSelectOnXX;sfAllowSelectOnXX~);V;"There is nothing to show"[IfcText] <STRONG>
   , "Listing XXs": sfAllowSelectOnXX cRud <XXOverviewSummary>
   ]
--#ENDIF NoXXXXOverviewIfc

--[INTERFACEs - Button bars]
-- Button bars can be used in Interfaces for (re)setting events for the purpose of CRUDing XXXX's

--#IFNOT NoXXXXPortalButtonBarIfc
-- The following buttonbar is designed for the general context in which a user wants to work with XX's
POPULATION IfcText CONTAINS [ "There is no current XX." ]
POPULATION IfcText CONTAINS [ "Please contact your system administrator." ]
POPULATION IfcText CONTAINS [ "You may create a XXXX." ]
POPULATION IfcText CONTAINS [ "Please select one." ]
POPULATION IfcText CONTAINS [ "Please select or create one." ]
POPULATION IfcText CONTAINS [ "Current XX: " ]
POPULATION IfcText CONTAINS [ "Select XX: " ]
POPULATION IfcText CONTAINS [ "Editing XX: " ]
POPULATION IfcText CONTAINS [ "unknown" ]

POPULATION isInvisible CONTAINS [ ("XXXXPortalButtonBar", "XXXXPortalButtonBar")]
INTERFACE "XXXXPortalButtonBar": "_SESSION"[SESSION] cRud BOX <CDIV>
   [ "No XX selected": sfXXIsNotSelected cRud BOX <CDIV>
      [ "No XX selectable": I-sfAllowSelectOnXX;sfAllowSelectOnXX~ BOX <CDIV>
         [ "MSG: Get help": (I-sfCreateXXIsAllowed);V;"Please contact your system administrator."[IfcText] cRud <STRONG>
         , "MSG: Create XX": sfCreateXXIsAllowed;V;"You may create a XXXX."[IfcText] cRud <STRONG>
         ]
      , "XX can be selected": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~ BOX <CDIV>
         [ "MSG: Select XX": V;"Select XX: "[IfcText] cRud <STRONG>
         , "Select XX": I INTERFACE "XXXXSelect"
         ] 
      , "New": sfCreateXXIsAllowed cRud BOX <PROPBUTTON> [ property: sfXXCreateReq cRUd ]
      ]
   , "XX is selected, NOT editing": sfXXIsSelected - sfXXIsUpdating  cRud BOX <CDIV>
      [ "MSG: Current XX": V;"Current XX: "[IfcText] cRud <STRONG>
      , "Current XX": I INTERFACE "XXXXSelect"
   --#IFNOT NoEditingOfXXXXs
      , "Edit": I /\ sfSelectedXX;sfAllowUpdateOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfEditSelectedXXReq cRUd
         , disabled: I /\ sfUpdatingXX;sfAllowUpdateOnXX~ cRud
         ]
   --#ENDIF NoEditingOfXXXXs
      , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXDeleteReq cRUd
   --    , disabled: I cRud
         ]
      , "New": sfCreateXXIsAllowed cRud BOX <PROPBUTTON>
         [ property: sfXXCreateReq cRUd
         , disabled: I /\ sfSelectedXX;sfUpdatingXX~ cRud -- because that interferes with the updating of XX
         ]
      , "Overview": sfXXIsSelected cRud BOX <PROPBUTTON> -- This is deselecting the current XX
         [ property: sfXXDeselectReq cRUd
         , disabled: I - sfAllowSelectOnXX;-I;sfAllowSelectOnXX~ cRud
         ]
      ]
   --#IFNOT NoEditingOfXXXXs
   , "XX is (selected, AND) editing": sfXXIsSelected /\ sfXXIsUpdating cRud BOX <CDIV>
      [ "MSG: Editing XX": V;"Editing XX: "[IfcText] cRud <STRONG>
      , "Editing XX": I INTERFACE "XXXXSelect"
      , "OK": sfXXIsUpdating cRud BOX <PROPBUTTON>
         [ property: sfXXDoneUpdReq cRUd
         , disabled: I /\ sfUpdatingXX;(I-xxxIsClean);sfUpdatingXX~ cRud
         ]
      , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXDeleteReq cRUd
   --    , disabled: I cRud
         ]
      , "Overview": sfXXIsSelected cRud BOX <PROPBUTTON> -- This is deselecting the current XX
         [ property: sfXXDeselectReq cRUd
   --    , disabled: sfXXIsSelecting cRud
         ]
      ]
   --#ENDIF NoEditingOfXXXXs
   ]
--#ENDIF NoXXXXPortalButtonBarIfc

--#IF ButtonBarEditXXIfc
-- The following buttonbar is designed for the context in which the user is updating (editing) a specific XX
POPULATION isInvisible CONTAINS [ ("ButtonBarEditXX", "ButtonBarEditXX")]
INTERFACE "ButtonBarEditXX": "_SESSION"[SESSION] cRud BOX <CDIV>
   [ "OK": sfXXIsUpdating cRud BOX <PROPBUTTON>
      [ property: sfXXCommitReq cRUd
      , disabled: I /\ sfUpdatingXX;(I-xxxIsClean);sfUpdatingXX~ cRud
      ]
   , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
      [ property: sfXXDeleteReq cRUd
--    , disabled: I cRud
      ]
   ]
--#ENDIF ButtonBarEditXXIfc

--#ENDIF ApplicationDefinesAllXXInterfaces
ENDCONTEXT