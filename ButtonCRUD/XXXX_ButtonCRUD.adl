CONTEXT "XXXX_ButtonCRUD" IN ENGLISH
{- This file serves as a template for creating, selecting, editing/updating, and deleting objects of type XXXX, where
   - the data (the XXXX that are worked on, i.e. the scope) is given by session variables
   - the relations that signal events/changes are also mostly session-related (some are XXXX-related)
   - ExecEngine rules that implement the CRUD functionalities for XXXX-objects.
   - INTERFACEs are provided conditionally (i.e. when you include this file, you can specify to leave them out so you can have your own)
   If you don't use them, they may still serve as templates foryour own.

This file is designed such that you are not required to change anything
apart from the strings `XXXX`, `xxx` and `XX` (see point 1 below).
However, you do need to add some stuff in your own project.

Here are the steps you need to follow in order to use this file as a template for ButtonCRUDding your own Objects:

--[XXXX_ButtonCRUD - Making the XXXX_ButtonCRUD available]
-- 1. Copy this file and do some renaming:
--    - copy this file to your project, and rename it as you find appropriate.
--    - rename `XXXX` into `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `xxx` into whatever few characters you use to name relations whose SRC is `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `XX` into `ShortName` that you use as an abbreviation for `ThePossiblyLengthyNameOfTheConceptIUse`
--      but of course, if `ThePossiblyLengthyNameOfTheConceptIUse` is short, then it can be the same as `ShortName`.
--    - INCLUDE this file into your script, and apply any conditional-compiler variables that you might need, e.g. as follows

INCLUDE "XXXX_ButtonCRUD.adl" -- --# [ "No<interfacename>Ifc", "ApplicationDefinesAllXXInterfaces", "NoEditingOfXXXXs" ]

--[XXXX_ButtonCRUD - Rules that maintain required populations]
-- 2a. You _MUST_ create rules that maintain the population of (the equivalents of)
--    - `xxxIsClean` :: XXXX * XXXX [PROP] -- Property that allows XXXX to be accepted/registered in the database
--    - `sfAppAllowsXXSelReq`:: XXContext * XXContext [PROP] -- Event, that signals that the application has processed whatever was needed before `sfSelReqForXX` could be processed
--    Here is some example-code that you can use if you replace **expression4xxxIsClean** with what you think is appropriate

ROLE ExecEngine MAINTAINS "Equivalence - InsPair xxxIsClean"
RULE "Equivalence - InsPair xxxIsClean": I /\ expression4xxxIsClean |- xxxIsClean
VIOLATION (TXT "{EX} InsPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)
ROLE ExecEngine MAINTAINS "Equivalence - DelPair xxxIsClean"
RULE "Equivalence - DelPair xxxIsClean": xxxIsClean |- I /\ expression4xxxIsClean
VIOLATION (TXT "{EX} DelPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "InsPair sfAppAllowsXXSelReq"
RULE "InsPair sfAppAllowsXXSelReq": sfSelReqForXX-sfSelectedXX |- sfAppAllowsXXSelReq;sfSelReqForXX
VIOLATION (TXT "{EX} InsPair;sfAppAllowsXXSelReq;XXContext;", SRC I, TXT ";XXContext;", SRC I
--        ,TXT "{EX} DelPair;sfSelectedYY;YYContext;", SRC sessionXXContext~;sessionYYContext, TXT ";YYYY;", SRC sessionXXContext~;sessionYYContext;sfSelectedYY
--        ,TXT "{EX} DelPair;sfSelectedZZ;ZZContext;", SRC sessionXXContext~;sessionZZContext, TXT ";ZZZZ;", SRC sessionXXContext~;sessionZZContext;sfSelectedZZ
          )

-- 2b. You _MUST_ create one or more rules that maintain the population of (the equivalents of)
--    - `sfCreateXXIsAllowed` :: XXContext * XXContext [PROP] -- User is allowed to create a new XX in the session
--    - `sfAllowSelectOnXX`   :: XXContext * XXXX           -- User is allowed to select (view) the XX in the session
--    - `sfAllowUpdateOnXX`   :: XXContext * XXXX           -- User is allowed to update (edit) the XX in the session
--    - `sfAllowDeleteOnXX`   :: XXContext * XXXX           -- User is allowed to delete the XX in the session
--    and/or make sure that you have INTERFACEs by which this population can be maintained. 
--    If you want everyone to be able to do everything with XXs, you can use the following example code:

ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to create a XXXX"
RULE "XXXX_ButtonCRUD allows all users to create a XXXX": I |- sfCreateXXIsAllowed
VIOLATION (TXT "{EX} InsPair;sfCreateXXIsAllowed;XXContext;", SRC I, TXT ";XXContext;", TGT I)
-- If you change the above rule, make sure you also do the associated `DelPair;sfCreateXXIsAllowed`

ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX"
RULE "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX": V |- sfAllowSelectOnXX /\ sfAllowUpdateOnXX /\ sfAllowDeleteOnXX
VIOLATION (TXT "{EX} InsPair;sfAllowSelectOnXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfAllowUpdateOnXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfAllowDeleteOnXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          )
-- If you change the above rule, make sure you also do the associated `DelPair` rules.

--[XXXX_ButtonCRUD - Define VIEWs to summarize what XXXX is about, for several purposes]
-- 3a. You _MUST_ define a VIEW called `XXSelectionSummary`, which is used in the selection dropdown box
-- 3b. You _MUST_ define a VIEW called `XXOverviewSummary`, which is used in the default Overview view
--    In the code provided below, change `I` to something more appropriate

VIEW XXSelectionSummary: XXXX { "Summary": I } ENDVIEW
VIEW XXOverviewSummary:  XXXX { "Summary": I } ENDVIEW

--[XXXX_ButtonCRUD - Interfaces]
-- 4a. The code in this template file has several predefined interfaces that need to be integrated with your application.
--    One way to do that is to copy them into your own code and adapt them there 
--    (you can prevent them being compiled in this file by specifying conditional-compilation variable `No<interfacename>Ifc`)
--    Alternatively, you can use them (i.e.: refer to them from your application script).
--    In that case, you still must define some interfaces, specifically the following:
--    - `INTERFACE "ShowXX": I[XXXX]` (etc.) -- This interface must allow the user to see the details of the XXXX
--    - `INTERFACE "InitXX": I[XXXX]` (etc.) -- This interface must allow the user to make a just created XXXX 'clean'
--    - `INTERFACE "EditXX": I[XXXX]` (etc.) -- This interface must allow the user to edit the XXXX
--    N.B.: Define the interfaces such that they do not show when there is nothing to do.
--          This means that the toplevel should be <DIV>, <CDIV>, <HROWS>, <HCOLS> or such.

-- 4b. If you want to use the interfaces provided in this file, you must also provide
--    - An interface that allows the user to see an overview of the XXXXs that he is allowed to work with, using
--      `INTERFACE "OverviewXX": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~`
--    - An interface that allows the user to select one of the XXXXs to start working with it, using
--      `INTERFACE "SelectXX": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~`
--    If you do not have special requirements, you can use the following code to provide these interfaces:

INTERFACE "OverviewXX": I[XXContext] INTERFACE "XXXXOverview"
INTERFACE "SelectXX":   I[XXContext] INTERFACE "XXXXSelect"

--[XXXX_ButtonCRUD - Navigation]
-- 5. ButtonCRUD uses events (clicking a button) to compute the state of affairs.
--    Every such state typically has its own interface associated with it. 
--    In order to get a smooth user experience, changes of state should be accompanied with switching of interfaces.
--    In order to be flexible and give application developers the control they need,
--    every change in state will navigate to an interface with a predefined name, as listed below
--    You can easily define these interfaces as in instance of an existing interface, as exemplified in the code below.
--    The `INTERFACE "XXXXPortal"` has been designed to accommodate every state.
--    Thus, you can use it as the generic interface to navigate to.
--    Note that `INTERFACE "XXXXPortal"` has been made invisible, because in practice it will be called from the application's portal.
--    Conversely: be sure that you create a portal from which to call it if needed.

INTERFACE "AfterEventSelectXXXX":   I[XXContext] INTERFACE "XXXXPortal" -- Another XXXX has been selected (to further focus on)
INTERFACE "AfterEventDeselectXXXX": I[XXContext] INTERFACE "XXXXPortal" -- Currently selected XXXX has been deselected (so go to some overview)
INTERFACE "AfterEventUpdateXXXX":   I[XXContext] INTERFACE "XXXXPortal" -- Updating has started (ready to edit)
INTERFACE "AfterEventDoneUpdXXXX":  I[XXContext] INTERFACE "XXXXPortal" -- Updating has terminated (done editing)
INTERFACE "AfterEventDeleteXXXX":   I[XXContext] INTERFACE "XXXXPortal" -- XXXX has been deleted (so go to some overview)

--[XXXX_ButtonCRUD - Switching between different portals]
-- 6. If you choose to use `INTERFACE "XXXXPortal"` that is provided by this code
--    you then _MUST_ create `INTERFACE "XXXXHeaderBar"`
--    You may want this interface to provide a breadcrumb and/or buttons for navigation purposes.
--    Notes:
--    - this file specifies `INTERFACE "GoToXXXXPortalButton"`, that contains a single button that
--      when clicked, navigates the user to `INTERFACE "XXXXPortal"`.
--      You can use this as part of the headerbar navigation buttons.
--    - make sure you properly initialize the switching between portals, e.g. by checking whether
--      `sessionCurrentPortalIfc` is populated, and if not, create a request to do so. 
--    Here is some example code for you to use and adapt in your application script:

-- Initialization of the Home portal must be done in the Main Application file, e.g. as follows:
ROLE ExecEngine MAINTAINS "Initialize sessionCurrentPortalIfc as XXXXPortal"
RULE "Initialize sessionCurrentPortalIfc as XXXXPortal": 
   (I-sessionCurrentPortalIfc;sessionCurrentPortalIfc~);sessionXXContext |- sessionXXContext;sfChangePortalToXXReq
VIOLATION (TXT "{EX} InsPair;sfChangePortalToXXReq;XXContext;", TGT I, TXT ";XXContext;", TGT I)

INTERFACE "XXXXHeaderBar" FOR User: I[XXContext] cRud BOX <CDIV>
   [ "User": sessionXXContext~ cRud BOX <CDIV>
      [ "User": sessionAccount;accPersonRef cRud
      , "Logout": I cRud BOX <PROPBUTTON> [ property : sessionLogoutReq cRUd ]
      ]
   , "Portal Switch buttons": sessionXXContext~ cRud BOX <CDIV>
      [ "XXXXs" : sessionXXContext INTERFACE "GoToXXXXPortalButton"
      , "YYYYs" : sessionYYContext INTERFACE "GoToYYYYPortalButton"
      , "ZZZZs" : sessionZZContext INTERFACE "GoToZZZZPortalButton"
      ]
   ]
-}

--[Basics - XXSessions (Contexts)]
-- Normally, all context-related stuff should be related to the (current) SESSION. 
-- However, when using the ButtonCRUD template for multiple objects, this can easily draw too great a wissel 
-- on the storage available for the SESSION table. Therefore, provide XXXX with its own context object.
CONCEPT XXContext "context within which XXXXs are being treated"

sessionXXContext :: SESSION * XXContext [UNI,TOT,INJ,SUR] -- define bijection between SESSION and XXSESSION
ROLE ExecEngine MAINTAINS "Create XXContext"
RULE "Create XXContext": I[SESSION] |- sessionXXContext;sessionXXContext~
VIOLATION (TXT "{EX} InsAtom;XXContext"
          ,TXT "{EX} InsPair;sessionXXContext;SESSION;", SRC I, TXT ";XXContext;_NEW"
          )
ROLE ExecEngine MAINTAINS "Delete XXContext"
RULE "Delete XXContext": sessionXXContext;sessionXXContext~ |- I[SESSION]
VIOLATION (TXT "{EX} DelAtom;XXContext")

--[Basics - Initialization, Being Clean, and (Auto)Deleting XXs]
xxxIsPersistent  :: XXXX * XXXX [PROP] -- Property, stating that XX should not be deleted by ButtonCRUD functionality
xxxIsClean       :: XXXX * XXXX [PROP] -- Property, stating that XX fulfills the minimum requirements for being registered
xxxIsInitialized :: XXXX * XXXX [PROP] -- Property, stating that XX has at some point in time been clean

RULE "Please make XXXX 'clean', or delete it": 
   xxxIsInitialized |- xxxIsPersistent \/ xxxIsClean \/ sfUpdatingXX~;sfUpdatingXX

ROLE ExecEngine MAINTAINS "InsPair `xxxIsInitialized`" -- This rule prevents inadvertent deletion of XX atoms when DB is inited
RULE "InsPair `xxxIsInitialized`": xxxIsClean |- xxxIsInitialized
VIOLATION (TXT "{EX} InsPair;xxxIsInitialized;XXXX;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Delete XX if it is not persistent and created imcomplete"
RULE "Delete XX if it is not persistent and created imcomplete": 
   I-xxxIsPersistent |- xxxIsClean \/ sfUpdatingXX~;sfUpdatingXX \/ sfUpdReqForXX~;sfUpdReqForXX
VIOLATION (TXT "{EX} DelAtom;XXXX;", SRC I)

--[XXXX Selection - Basics]
-- An XXXX can be selected by requesting this. A request is done by populating `sfSelReqForXX`. 
-- This can be done e.g. using `BOX <OBJECTDROPDOWN>`, or by a RULE that is specified in the application.
-- The result of this request is the requested XXXX is selected, if that such is allowed by `sfAllowSelectOnXX`.
-- The process that produces this result is partly in the following lines,
-- and partly in the application, because the application may have dependencies between XXXX and (say) YYYY atoms.
-- So, the actual selection takes place only after the application has signaled completion of its process,
-- which it can do by populating `sfAppAllowsXXSelReq`.
-- Note that aelecting a new XXXX terminates any editing/updating functions.
sfAllowSelectOnXX :: XXContext * XXXX -- Permission, where the user is allowed to select (view) the XX
sfSelectedXX :: XXContext * XXXX [UNI] -- the XXXX-atom that is selected in/focussed on by the session

RULE "An XXXX can only be selected if that is allowed": sfSelectedXX |- sfAllowSelectOnXX

sfSelReqForXX :: XXContext * XXXX [UNI] -- Event, that requests XXXX to be selected
sfAppAllowsXXSelReq :: XXContext * XXContext [PROP] -- Event, that signals that the application has processed whatever was needed before `sfSelReqForXX` could be processed

ROLE ExecEngine MAINTAINS "Decline `sfSelReqForXX`"
RULE "Decline `sfSelReqForXX`": sfSelReqForXX |- sfAllowSelectOnXX
VIOLATION (TXT "{EX} DelPair;sfSelReqForXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfAppAllowsXXSelReq;XXContext;", SRC I, TXT ";XXContext;", SRC I
          )

ROLE ExecEngine MAINTAINS "Service `sfSelReqForXX`"
RULE "Service `sfSelReqForXX`": sfAppAllowsXXSelReq;sfSelReqForXX /\ sfAllowSelectOnXX |- sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfSelectedXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfAppAllowsXXSelReq;XXContext;", SRC I, TXT ";XXContext;", SRC I
          ,TXT "{EX} InsPair;sessionCurrentPortalIfc;SESSION;", SRC sessionXXContext~, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/AfterEventSelectXXXX/", SRC I
          )

{-- In cases where a new XXXX is selected, we may need to refresh the (entire) web page.
-- However `SetNavToOnCommit` does not do that, so we need a work-around, that consists of
-- us alternatingly navigating to two different interfaces that will refer to the one we need.
-- To do this, we use two slighly different ways of servicing a `sfSelReqForXX`.
-- The alternating nature of this is implemented using `sfXXSelSwitchProp`.
sfXXSelSwitchProp :: XXContext * XXContext [PROP]
ROLE ExecEngine MAINTAINS "Service `sfSelReqForXX`"
RULE "Service `sfSelReqForXX`": sfSelReqForXX /\ sfSelectedXX;sfAllowSelectOnXX~ |- sfXXSelSwitchProp
VIOLATION (TXT "{EX} DelPair;sfSelReqForXX;XXContext;", SRC I, TXT ";XXContext;", TGT I
      --  ,TXT "{EX} DelPair;sfUpdatingXX;XXContext;", SRC I, TXT ";XXXX;", TGT sfUpdatingXX
          ,TXT "{EX} InsPair;sfXXSelSwitchProp;XXContext;", SRC I, TXT ";XXContext;", TGT I -- The next time, rule `AlternativeService sfSelReqForXX` will fire
          ,TXT "{EX} InsPair;sessionCurrentPortalIfc;SESSION;", SRC sessionXXContext~, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/AfterEventSelectXXXX/", SRC I
          )

ROLE ExecEngine MAINTAINS "AlternativeService `sfSelReqForXX`"
RULE "AlternativeService `sfSelReqForXX`": sfSelReqForXX /\ sfSelectedXX;sfAllowSelectOnXX~ |- -sfXXSelSwitchProp
VIOLATION (TXT "{EX} DelPair;sfSelReqForXX;XXContext;", SRC I, TXT ";XXContext;", TGT I
      --  ,TXT "{EX} DelPair;sfUpdatingXX;XXContext;", SRC I, TXT ";XXXX;", TGT sfUpdatingXX
          ,TXT "{EX} DelPair;sfXXSelSwitchProp;XXContext;", SRC I, TXT ";XXContext;", TGT I -- The next time, rule `Service sfSelReqForXX` will fire
          ,TXT "{EX} InsPair;sessionCurrentPortalIfc;SESSION;", SRC sessionXXContext~, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/AfterEventSelectXXXXAlternate"
          )
INTERFACE AfterEventSelectXXXXAlternate: I[XXContext] INTERFACE AfterEventSelectXXXX --}

--[XXXX Selection - Properties that flag (No)Selection]
-- Sometimes we need to know whether or not an XX is focused on. Therefore, we define properties that we can use for this
sfXXIsSelected    :: XXContext * XXContext [PROP] -- Status/Property, where the session has an XX that the user focuses on
sfXXIsNotSelected :: XXContext * XXContext [PROP] -- Status/Property, where the session does not have an XX that the user can focus on
ROLE ExecEngine MAINTAINS "InsPair sfXXIsSelected/DelPair sfXXIsUnSelected"
RULE "InsPair sfXXIsSelected/DelPair sfXXIsUnSelected": I /\ sfSelectedXX;sfSelectedXX~ |- sfXXIsSelected-sfXXIsNotSelected
VIOLATION (TXT "{EX} InsPair;sfXXIsSelected;XXContext;", SRC I, TXT ";XXContext;", TGT I
          ,TXT "{EX} DelPair;sfXXIsNotSelected;XXContext;", SRC I, TXT ";XXContext;", TGT I
          )
ROLE ExecEngine MAINTAINS "DelPair sfXXIsSelected/InsPair sfXXIsUnSelected"
RULE "DelPair sfXXIsSelected/InsPair sfXXIsUnSelected": I - sfSelectedXX;sfSelectedXX~ |- sfXXIsNotSelected-sfXXIsSelected
VIOLATION (TXT "{EX} InsPair;sfXXIsNotSelected;XXContext;", SRC I, TXT ";XXContext;", TGT I
          ,TXT "{EX} DelPair;sfXXIsSelected;XXContext;", SRC I, TXT ";XXContext;", TGT I
          )

--[XXXX Selection - Selecting a specific XXXX]
xxxSelectReq :: XXXX * XXXX [PROP] -- Event, that requests to select the XXXX (to further focus on) if not already selected
ROLE ExecEngine MAINTAINS "Decline xxxSelectReq"
RULE "Decline xxxSelectReq": xxxSelectReq |- sfAllowSelectOnXX~;sessionXXContext~;"_SESSION"[SESSION];sessionXXContext;sfAllowSelectOnXX
VIOLATION (TXT "{EX} DelPair;xxxSelectReq;XXXX;", SRC I, TXT ";XXXX;", TGT I
          )
ROLE ExecEngine MAINTAINS "Service xxxSelectReq"
RULE "Service xxxSelectReq": "_SESSION"[SESSION];sessionXXContext;sfAllowSelectOnXX;xxxSelectReq |- -V
VIOLATION (TXT "{EX} DelPair;xxxSelectReq;XXXX;", TGT I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfSelectedXX;XXContext;", SRC sessionXXContext, TXT ";XXXX;", SRC sessionXXContext;sfSelectedXX
          ,TXT "{EX} InsPair;sfSelReqForXX;XXContext;", SRC sessionXXContext, TXT ";XXXX;", TGT I
          )

--[XXXX Selection - Automated selections]
--#IFNOT DoNotAutoSelectSingleXX
ROLE ExecEngine MAINTAINS "Auto Service sfXXSelectReq - there is only one choice" -- If there's only one choice, then take it.
RULE "Auto Service sfXXSelectReq - there is only one choice": sfAllowSelectOnXX - sfAllowSelectOnXX;-I |- sfSelReqForXX \/ sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfSelReqForXX;XXContext;", SRC I, TXT ";XXXX;", TGT I)
--#ENDIF DoNotAutoSelectSingleXX

--[XXXX Selection - Deselecting the selected XXXX]
sfXXDeselectReq :: XXContext * XXContext [PROP] -- Event, that requests to deselect the selected XXXX
ROLE ExecEngine MAINTAINS "Decline sfXXDeselectReq" -- Decline servicing sfXXDeselectReq
RULE "Decline sfXXDeselectReq": sfXXDeselectReq |- sfSelectedXX;sfSelectedXX~
VIOLATION (TXT "{EX} DelPair;sfXXDeselectReq;XXContext;", SRC I, TXT ";XXContext;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfXXDeselectReq" -- Service sfXXDeselectReq when set
RULE "Service sfXXDeselectReq": sfXXDeselectReq;sfSelectedXX |- -V
VIOLATION (TXT "{EX} DelPair;sfXXDeselectReq;XXContext;", SRC I, TXT ";XXContext;", SRC I
          ,TXT "{EX} DelPair;sfSelReqForXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfSelectedXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sessionCurrentPortalIfc;SESSION;", SRC sessionXXContext~, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDeselectXXXX/", SRC I
          )

--[XXXX Updating - Basics]
-- Updating is done using `BOX <OBJECTDROPDOWN>`, which populates `sfUpdReqForXX`
-- Updating ensures that the updated XX becomes and remains the selected XXXX for at least as long as it is being updated.
-- Note that when one XX is being updated and at that time another one is being selected another XXXX while 
sfAllowUpdateOnXX :: XXContext * XXXX -- Permission, where the user is allowed to update (edit) the XX
sfUpdatingXX :: XXContext * XXXX [UNI] -- the XXXX-atom that is selected in/focussed on by the session

RULE "An XXXX can only be updated if that is allowed": sfUpdatingXX |- sfAllowUpdateOnXX
RULE "A session that is allowed to UPDATE an XX must also be allowed to SELECT an XX": sfAllowUpdateOnXX |- sfAllowSelectOnXX
-- We do not provide ExecEngine solutions here so that errors in the population of `sfAllowUpdateOnXX` do not go unnoticed

ROLE ExecEngine MAINTAINS "Auto depopulate sfUpdatingXX"
RULE "Auto depopulate sfUpdatingXX": sfUpdatingXX |- sfSelectedXX
VIOLATION (TXT "{EX} DelPair;sfUpdatingXX;XXContext;", SRC I, TXT ";XXXX;", TGT I)

sfUpdReqForXX :: XXContext * XXXX [UNI] -- Event, that requests XXXX to be updated

ROLE ExecEngine MAINTAINS "Decline `sfUpdReqForXX`"
RULE "Decline `sfUpdReqForXX`": sfUpdReqForXX |- sfAllowUpdateOnXX
VIOLATION (TXT "{EX} DelPair;sfUpdReqForXX;XXContext;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Service `sfUpdReqForXX`"
RULE "Service `sfUpdReqForXX`": sfUpdReqForXX /\ sfAllowUpdateOnXX |- sfUpdatingXX /\ sfSelReqForXX /\ sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfUpdatingXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfSelReqForXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfSelectedXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sessionCurrentPortalIfc;SESSION;", SRC sessionXXContext~, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/AfterEventUpdateXXXX/", SRC I
          )

--[XXXX Updating - Properties that flag (No)Updation]
-- Sometimes we need to know whether or not an XX is focused on. Therefore, we define properties that we can use for this
sfXXIsUpdating :: XXContext * XXContext [PROP] -- Status/Property, where the session has an XX that the user focuses on for updating/editing
ROLE ExecEngine MAINTAINS "InsPair sfXXIsUpdating"
RULE "InsPair sfXXIsUpdating": I /\ sfUpdatingXX;sfUpdatingXX~ |- sfXXIsUpdating
VIOLATION (TXT "{EX} InsPair;sfXXIsUpdating;XXContext;", SRC I, TXT ";XXContext;", TGT I)
ROLE ExecEngine MAINTAINS "DelPair sfXXIsUpdating"
RULE "DelPair sfXXIsUpdating": sfXXIsUpdating |- I /\ sfUpdatingXX;sfUpdatingXX~
VIOLATION (TXT "{EX} DelPair;sfXXIsUpdating;XXContext;", SRC I, TXT ";XXContext;", TGT I)

--[XXXX Updating - Updating a specified XXXX (that may not have been selected)]
xxxUpdateReq :: XXXX * XXXX [PROP] -- Event, that requests to select the XXXX (to further focus on) if not already selected
ROLE ExecEngine MAINTAINS "Decline xxxUpdateReq"
RULE "Decline xxxUpdateReq": xxxUpdateReq |- sfAllowUpdateOnXX~;sessionXXContext~;"_SESSION"[SESSION];sessionXXContext;sfAllowUpdateOnXX
VIOLATION (TXT "{EX} DelPair;xxxUpdateReq;XXXX;", SRC I, TXT ";XXXX;", TGT I
          )
ROLE ExecEngine MAINTAINS "Service xxxUpdateReq"
RULE "Service xxxUpdateReq": "_SESSION"[SESSION];sessionXXContext;sfAllowUpdateOnXX;xxxUpdateReq |- -V
VIOLATION (TXT "{EX} DelPair;xxxUpdateReq;XXXX;", TGT I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfUpdReqForXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          )

--[XXXX Updating - Updating the already selected XXXX]
sfEditSelectedXXReq :: XXContext * XXContext [PROP]
ROLE ExecEngine MAINTAINS "Decline sfEditSelectedXXReq"
RULE "Decline sfEditSelectedXXReq": sfEditSelectedXXReq |- sfSelectedXX;sfAllowUpdateOnXX~
VIOLATION (TXT "{EX} DelPair;sfEditSelectedXXReq;XXContext;", SRC I, TXT ";XXContext;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfEditSelectedXXReq"
RULE "Service sfEditSelectedXXReq": sfEditSelectedXXReq;(sfSelectedXX /\ sfAllowUpdateOnXX) |- sfUpdatingXX
VIOLATION (TXT "{EX} DelPair;sfEditSelectedXXReq;XXContext;", SRC I, TXT ";XXContext;", SRC I
          ,TXT "{EX} InsPair;sfUpdReqForXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          )

--[XXXX Updating - Terminate updating of XXXX]
sfXXDoneUpdReq :: XXContext * XXContext [PROP] -- Event, that requests updating/editing of XXXX to terminate
ROLE ExecEngine MAINTAINS "Decline sfXXDoneUpdReq" -- Service sfXXDoneUpdReq when set
RULE "Decline sfXXDoneUpdReq": sfXXDoneUpdReq |- sfUpdatingXX;sfUpdatingXX~
VIOLATION (TXT "{EX} DelPair;sfXXDoneUpdReq;XXContext;", SRC I, TXT ";XXContext;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfXXDoneUpdReq" -- Service sfXXDoneUpdReq when set
RULE "Service sfXXDoneUpdReq": sfXXDoneUpdReq;sfUpdatingXX |- -V
VIOLATION (TXT "{EX} DelPair;sfXXDoneUpdReq;XXContext;", SRC I, TXT ";XXContext;", SRC I
          ,TXT "{EX} DelPair;sfUpdReqForXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfUpdatingXX;XXContext;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sessionCurrentPortalIfc;SESSION;", SRC sessionXXContext~, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDoneUpdXXXX/", SRC I
          )

--[XXXX Creation - and automatically starting to update]
-- An XX is created when `sfXXCreateReq` is populated, and `sfCreateXXIsAllowed` is set (permits the creation)
-- When an XX is created, it is usually not clean, so we take it to be updated after creation.
-- Because of this, we do not allow for the creation of an XX when an XX is being updated.
sfCreateXXIsAllowed :: XXContext * XXContext [PROP] -- Permission, where the user is allowed to request the creation of a new XX
sfXXCreateReq       :: XXContext * XXContext [PROP] -- Event, where the user requests to create a new XX

ROLE ExecEngine MAINTAINS "Decline/Prevent sfXXCreateReq" -- i.e. if there is no permission, or an XX is being updated in this session.
RULE "Decline/Prevent sfXXCreateReq": sfXXCreateReq |- sfCreateXXIsAllowed - sfXXIsUpdating
VIOLATION (TXT "{EX} DelPair;sfXXCreateReq;XXContext;", SRC I, TXT ";XXContext;", SRC I)

ROLE ExecEngine MAINTAINS "Service sfXXCreateReq" -- Create an XX if there is no XX being edited, and creation is allowed
RULE "Service sfXXCreateReq": sfXXCreateReq /\ sfCreateXXIsAllowed |- sfXXIsUpdating
VIOLATION (TXT "{EX} InsAtom;XXXX"
          ,TXT "{EX} InsPair;sfAllowSelectOnXX;XXContext;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfAllowUpdateOnXX;XXContext;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfAllowDeleteOnXX;XXContext;", SRC I, TXT ";XXXX;_NEW"

          ,TXT "{EX} InsPair;sfUpdReqForXX;XXContext;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} DelPair;sfXXCreateReq;XXContext;", SRC I, TXT ";XXContext;", SRC I
          )

--[XXXX Deleting - Basics ]
sfAllowDeleteOnXX :: XXContext * XXXX -- Permission, where the user is allowed to delete the XX
RULE "A session that is allowed to DELETE an XX must also be allowed to SELECT that XX": sfAllowDeleteOnXX |- sfAllowSelectOnXX
-- We do not provide ExecEngine solutions here so that errors in the population of `sfAllowDeleteOnXX` do not go unnoticed

sfXXDeleteReq :: XXContext * XXContext [PROP] -- Event, where the user requests the XX to be (completely) deleted

ROLE ExecEngine MAINTAINS "Decline sfXXDeleteReq"
RULE "Decline sfXXDeleteReq": sfXXDeleteReq |- sfSelectedXX;sfAllowDeleteOnXX~
VIOLATION (TXT "{EX} DelPair;sfXXDeleteReq;XXContext;", SRC I, TXT ";XXContext;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfXXDeleteReq"
RULE "Service sfXXDeleteReq": sfXXDeleteReq;(sfSelectedXX /\ sfAllowDeleteOnXX) |- -V
VIOLATION (TXT "{EX} DelAtom;XXXX;", TGT I
          ,TXT "{EX} InsPair;sessionCurrentPortalIfc;SESSION;", SRC sessionXXContext~, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDeleteXXXX/", SRC I
          )

--[Switching between XXXXPortal and other portals (e.g. YYYYPortal or ZZZZPortal)]
-- The purpose of the following code is to allow applications to switch between the XXXXPortal (as defined below)
-- and other portals, e.g. a YYYYPortal or a ZZZZPortal that may be defined elsewhere in the application.
--#IFNOT NoGoToXXXXPortalButton
sessionCurrentPortalIfc :: SESSION * IfcName [UNI]    REPRESENT IfcName TYPE ALPHANUMERIC
sfChangePortalToXXReq :: XXContext * XXContext [PROP] -- Event, where the user requests to focus on a XX
ROLE ExecEngine MAINTAINS "Service sfChangePortalToXXReq"
RULE "Service sfChangePortalToXXReq": sfChangePortalToXXReq |- -I
VIOLATION (TXT "{EX} DelPair;sfChangePortalToXXReq;XXContext;", SRC I, TXT ";XXContext;", TGT I
          ,TXT "{EX} InsPair;sessionCurrentPortalIfc;SESSION;", SRC sessionXXContext~, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/XXXXPortal/", SRC I
          )
-- The below interface can be called e.g. from `INTERFACE "XXXXHeaderBar"` to navigate to the XXXXPortal
INTERFACE "GoToXXXXPortalButton": I[XXContext] cRud BOX <DIV>
   [  "XXXXs": (I[XXContext] /\ sfAllowSelectOnXX;sfAllowSelectOnXX~) \/ sfCreateXXIsAllowed cRud BOX <PROPBUTTON>
      [ property: sfChangePortalToXXReq cRUd
      , disabled: sessionXXContext~;sessionCurrentPortalIfc;"/XXXXPortal" cRud
      ]
   ]
--#ENDIF NoGoToXXXXPortalButton

--[INTERFACES]
--#IFNOT ApplicationDefinesAllXXInterfaces
-- Every interface defined here can optionally be left out by setting `No<interfacename>Ifc` when including this file.

--#IFNOT NoXXXXPortalIfc
--**Hier is nog wat onderhoud nodig om applicaties te accommoderen die naast XXXX ook YYYY, ZZZZ e.d. hebben.
INTERFACE "XXXXPortal": (I[XXContext] /\ sfAllowSelectOnXX;sfAllowSelectOnXX~) \/ sfCreateXXIsAllowed cRud BOX <DIV>
   [ "XXXXHeaderBar":  I INTERFACE "XXXXHeaderBar" -- Breadcrumbs, global navigation buttons
   , "XXXXButtonBar":  I INTERFACE "XXXXPortalButtonBar" -- Navigation within XXXXs
   , "XXXXWorkArea":   I INTERFACE "XXXXWorkArea"
   ]
--#ENDIF NoXXXXPortalIfc

--#IFNOT NoXXXXWorkAreaIfc -- This allows users to define their own WorkArea interface
INTERFACE "XXXXWorkArea": I[XXContext] cRud BOX <DIV>
   [ "Listing XX": I-sfXXIsSelected INTERFACE "OverviewXX"
   --#IF NoEditingOfXXXXs
   , "Showing XX": sfSelectedXX INTERFACE "ShowXX"
   --#ELSE
   , "Showing XX": sfSelectedXX-sfUpdatingXX INTERFACE "ShowXX"
   , "Initing XX": sfUpdatingXX;(I-xxxIsInitialized) INTERFACE "InitXX"
   , "Updating XX": sfUpdatingXX;xxxIsInitialized INTERFACE "EditXX"
      --#IF ButtonBarEditXXIfc
      , "Updatebar XX": sfXXIsUpdating INTERFACE "ButtonBarEditXX"
      --#ENDIF ButtonBarEditXXIfc
   --#ENDIF NoEditingOfXXXXs
   ]
--#ENDIF NoXXXXWorkAreaIfc

--[Example INTERFACEs for portal construction]

--#IFNOT NoXXXXSelectIfc -- This allows users to define their own selection interface
INTERFACE "XXXXSelect": I[XXContext] cRud BOX <DIV>
   [ "Non-editing mode": I-sfXXIsUpdating cRud BOX <OBJECTDROPDOWN>
      [ "selectfrom": sfAllowSelectOnXX cRud <XXSelectionSummary>
      , "setrelation": sfSelReqForXX cRUd
--    , "selectflag":  cRUd
      ]
   , "Editing mode": sfXXIsUpdating cRud BOX <OBJECTDROPDOWN>
      [ "selectfrom": sfUpdatingXX cRud <XXSelectionSummary>
      , "setrelation": sfUpdReqForXX cRUd
--    , "selectflag":  cRUd
      ]
   ]
--#ENDIF NoXXXXSelectIfc

--#IFNOT NoXXXXOverviewIfc -- This allows users to define their own Overview interface
POPULATION IfcText CONTAINS [ "There is nothing to show" ]
INTERFACE "XXXXOverview": I[XXContext] cRud BOX <DIV>
   [ "Nothing to do": (I - sfAllowSelectOnXX;sfAllowSelectOnXX~);V;"There is nothing to show"[IfcText] <STRONG>
   , "Listing XXs": sfAllowSelectOnXX cRud <XXOverviewSummary>
   ]
--#ENDIF NoXXXXOverviewIfc

--[INTERFACEs - Button bars]
-- Button bars can be used in Interfaces for (re)setting events for the purpose of CRUDing XXXX's

--#IFNOT NoXXXXPortalButtonBarIfc
-- The following buttonbar is designed for the general context in which a user wants to work with XX's
POPULATION IfcText CONTAINS [ "There is no current XX." ]
POPULATION IfcText CONTAINS [ "Please contact your system administrator." ]
POPULATION IfcText CONTAINS [ "You may create a XXXX." ]
POPULATION IfcText CONTAINS [ "Please select one." ]
POPULATION IfcText CONTAINS [ "Please select or create one." ]
POPULATION IfcText CONTAINS [ "Current XX: " ]
POPULATION IfcText CONTAINS [ "Select XX: " ]
POPULATION IfcText CONTAINS [ "Editing XX: " ]
POPULATION IfcText CONTAINS [ "unknown" ]

INTERFACE "XXXXPortalButtonBar": I[XXContext] cRud BOX <CDIV>
   [ "No XX selected": sfXXIsNotSelected cRud BOX <CDIV>
      [ "No XX selectable": I-sfAllowSelectOnXX;sfAllowSelectOnXX~ BOX <CDIV>
         [ "MSG: Get help": (I-sfCreateXXIsAllowed);V;"Please contact your system administrator."[IfcText] cRud <STRONG>
         , "MSG: Create XX": sfCreateXXIsAllowed;V;"You may create a XXXX."[IfcText] cRud <STRONG>
         ]
      , "XX can be selected": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~ BOX <CDIV>
         [ "MSG: Select XX": V;"Select XX: "[IfcText] cRud <STRONG>
         , "Select XX": I INTERFACE "XXXXSelect"
         ] 
      , "New": sfCreateXXIsAllowed cRud BOX <PROPBUTTON> [ property: sfXXCreateReq cRUd ]
      ]
   , "XX is selected, NOT editing": sfXXIsSelected - sfXXIsUpdating  cRud BOX <CDIV>
      [ "MSG: Current XX": V;"Current XX: "[IfcText] cRud <STRONG>
      , "Current XX": I INTERFACE "XXXXSelect"
   --#IFNOT NoEditingOfXXXXs
      , "Edit": I /\ sfSelectedXX;sfAllowUpdateOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfEditSelectedXXReq cRUd
         , disabled: I /\ sfUpdatingXX;sfAllowUpdateOnXX~ cRud
         ]
   --#ENDIF NoEditingOfXXXXs
      , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXDeleteReq cRUd
   --    , disabled: I cRud
         ]
      , "New": sfCreateXXIsAllowed cRud BOX <PROPBUTTON>
         [ property: sfXXCreateReq cRUd
         , disabled: I /\ sfSelectedXX;sfUpdatingXX~ cRud -- because that interferes with the updating of XX
         ]
      , "Overview": sfXXIsSelected cRud BOX <PROPBUTTON> -- This is deselecting the current XX
         [ property: sfXXDeselectReq cRUd
         , disabled: I - sfAllowSelectOnXX;-I;sfAllowSelectOnXX~ cRud
         ]
      ]
   --#IFNOT NoEditingOfXXXXs
   , "XX is (selected, AND) editing": sfXXIsSelected /\ sfXXIsUpdating cRud BOX <CDIV>
      [ "MSG: Editing XX": V;"Editing XX: "[IfcText] cRud <STRONG>
      , "Editing XX": I INTERFACE "XXXXSelect"
      , "OK": sfXXIsUpdating cRud BOX <PROPBUTTON>
         [ property: sfXXDoneUpdReq cRUd
         , disabled: I /\ sfUpdatingXX;(I-xxxIsClean);sfUpdatingXX~ cRud
         ]
      , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXDeleteReq cRUd
   --    , disabled: I cRud
         ]
      , "Overview": sfXXIsSelected cRud BOX <PROPBUTTON> -- This is deselecting the current XX
         [ property: sfXXDeselectReq cRUd
   --    , disabled: sfXXIsSelecting cRud
         ]
      ]
   --#ENDIF NoEditingOfXXXXs
   ]
--#ENDIF NoXXXXPortalButtonBarIfc

--#IF ButtonBarEditXXIfc
-- The following buttonbar is designed for the context in which the user is updating (editing) a specific XX
INTERFACE "ButtonBarEditXX": I[XXContext] cRud BOX <CDIV>
   [ "OK": sfXXIsUpdating cRud BOX <PROPBUTTON>
      [ property: sfXXCommitReq cRUd
      , disabled: I /\ sfUpdatingXX;(I-xxxIsClean);sfUpdatingXX~ cRud
      ]
   , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
      [ property: sfXXDeleteReq cRUd
--    , disabled: I cRud
      ]
   ]
--#ENDIF ButtonBarEditXXIfc

--#ENDIF ApplicationDefinesAllXXInterfaces
ENDCONTEXT