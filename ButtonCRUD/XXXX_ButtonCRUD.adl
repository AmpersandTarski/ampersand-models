CONTEXT "XXXX_ButtonCRUD" IN ENGLISH
{- This file serves as a template for creating, selecting, editing/updating, and deleting objects of type XXXX
This is done in a 'button-driven' fashion, i.e. providing  user-interfaces that initialize such functionalities.
These interfaces assume they work on (atoms in) the concept XXXX;
It provides templates for various generic interface-types, e.g. an XXXX-portal, button bars, etc.
Also, it provides the ExecEngine rules that implement the CRUD functionalities for XXXX-objects.

This template is designed such that you are not required to change anything
apart from the strings `XXXX`, `xxx` and `XX` (see point 1 below).
However, you do need to add some stuff in your own project.
Here are the steps that show you how to make it work:

--[XXXX_ButtonCRUD - Prerequisites]
-- 0. The working of ButtonCRUD is based on the idea that a SESSION is the users working context.
--    As a result, most interfaces take a SESSION as their source atom. One of the consequences of this is
--    that such interfaces show up in the NavBar, which has a very polluting effect. If you want to prevent
--    this from happening, you must copy the following code to your main script:

RELATION isVisible[PF_NavMenuItem*PF_NavMenuItem] [PROP] -- Defined in SystemContext.adl
RELATION isInvisible[PF_NavMenuItem*PF_NavMenuItem] [PROP]
ROLE ExecEngine MAINTAINS "DelPair `isInvisible`"
RULE "DelPair `isInvisible`": isInvisible |- I-isVisible
VIOLATION (TXT "{EX} DelPair;isVisible;PF_NavMenuItem;", SRC I, TXT ";PF_NavMenuItem;", TGT I)
ROLE ExecEngine MAINTAINS "InsPair `isInvisible`"
RULE "InsPair `isInvisible`": I-isInvisible |- isVisible
VIOLATION (TXT "{EX} InsPair;isVisible;PF_NavMenuItem;", SRC I, TXT ";PF_NavMenuItem;", TGT I)

--[XXXX_ButtonCRUD - Making the XXXX_ButtonCRUD available]
-- 1. Copy this file and do some renaming:
--    - copy this file to your project, and rename it appropriately.
--    - rename `XXXX` into `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `xxx` into whatever few characters you use to name relations whose SRC is `ThePossiblyLengthyNameOfTheConceptIUse`.
--    - rename `XX` into `ShortName` that you use as an abbreviation for `ThePossiblyLengthyNameOfTheConceptIUse`
--      but of course, if `ThePossiblyLengthyNameOfTheConceptIUse` is short, then it can be the same as `ShortName`.
--    - INCLUDE this file into your script, and apply any conditional-compiler variables that you might need, e.g. as follows

INCLUDE "XXXX_ButtonCRUD.adl" -- --# [ "No<interfacename>Ifc", "ApplicationDefinesAllXXInterfaces", "NoEditingOfXXXXs" ]

--[XXXX_ButtonCRUD - Rules that maintain required populations]
-- 2a. You _MUST_ create rules that maintain the population of (the equivalents of)
--    - `xxxIsClean` :: XXXX * XXXX [PROP] -- Property that allows XXXX to be accepted/registered in the database
--    Here is some example-code that you can use if you replace **expression4xxxIsClean** with what you think is appropriate

xxxIsClean :: XXXX * XXXX [PROP] -- define relation xxxIsClean as shorthand for I /\ expression4xxxIsClean
ROLE ExecEngine MAINTAINS "Equivalence - InsPair xxxIsClean"
RULE "Equivalence - InsPair xxxIsClean": expression4xxxIsClean |- xxxIsClean
VIOLATION (TXT "{EX} InsPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)
ROLE ExecEngine MAINTAINS "Equivalence - DelPair xxxIsClean"
RULE "Equivalence - DelPair xxxIsClean": xxxIsClean |- I /\ expression4xxxIsClean
VIOLATION (TXT "{EX} DelPair;xxxIsClean;XXXX;", SRC I, TXT ";XXXX;", TGT I)

-- 2b. You _MUST_ create one or more rules that maintain the population of (the equivalents of)
--    - `sfCreateXXIsAllowed` :: SESSION * SESSION [PROP] -- User is allowed to create a new XX in the session
--    - `sfAllowSelectOnXX`   :: SESSION * XXXX           -- User is allowed to select (view) the XX in the session
--    - `sfAllowUpdateOnXX`   :: SESSION * XXXX           -- User is allowed to update (edit) the XX in the session
--    - `sfAllowDeleteOnXX`   :: SESSION * XXXX           -- User is allowed to delete the XX in the session
--    and/or make sure that you have INTERFACEs by which this population can be maintained. 
--    If you want everyone to be able to do everything with XXs, you can use the following example code:

ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to create a XXXX"
RULE "XXXX_ButtonCRUD allows all users to create a XXXX": I |- sfCreateXXIsAllowed
VIOLATION (TXT "InsPair;sfCreateXXIsAllowed;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX"
RULE "XXXX_ButtonCRUD allows all users to Select, Update, Delete every XXXX": V |- sfAllowSelectOnXX /\ sfAllowUpdateOnXX /\ sfAllowDeleteOnXX
VIOLATION (TXT "InsPair;sfAllowSelectOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "InsPair;sfAllowUpdateOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "InsPair;sfAllowDeleteOnXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          )

--[XXXX_ButtonCRUD - Define VIEWs to summarize what XXXX is about, for several purposes]
-- 3a. You _MUST_ define a VIEW called `XXSelectionSummary`, which is used in the selection dropdown box
-- 3b. You _MUST_ define a VIEW called `XXOverviewSummary`, which is used in the default Overview view
--    In the code provided below, change `I` to something more appropriate

VIEW XXSelectionSummary: XXXX { "Summary": I } ENDVIEW
VIEW XXOverviewSummary:  XXXX { "Summary": I } ENDVIEW

--[XXXX_ButtonCRUD - Interfaces]
-- 4a. The code in this template file has several predefined interfaces that need to be integrated with your application.
--    One way to do that is to copy them into your own code and adapt them there 
--    (you can prevent them being compiled in this file by specifying conditional-compilation variable `No<interfacename>Ifc`)
--    Alternatively, you can use them (i.e.: refer to them from your application script).
--    In that case, you still must define some interfaces, specifically the following:
--    - `INTERFACE "ShowXX": I[XXXX]` (etc.) -- This interface must allow the user to see the details of the XXXX
--    - `INTERFACE "InitXX": I[XXXX]` (etc.) -- This interface must allow the user to make a just created XXXX 'clean'
--    - `INTERFACE "EditXX": I[XXXX]` (etc.) -- This interface must allow the user to edit the XXXX
--    N.B.: Define the interfaces such that they do not show when there is nothing to do.
--          This means that the toplevel should be <DIV>, <CDIV>, <HROWS>, <HCOLS> or such.

-- 4b. If you want to use the interfaces provided in this file, you must also provide
--    - An interface that allows the user to see an overview of the XXXXs that he is allowed to work with, using
--      `INTERFACE "OverviewXX": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~`
--    If you do not have special requirements, you can use the following code to provide these interfaces:

POPULATION isInvisible CONTAINS [ ("OverviewXX","OverviewXX") ]
INTERFACE "OverviewXX": I[SESSION] INTERFACE "XXXXOverview"

--[XXXX_ButtonCRUD - Navigation]
-- 5. ButtonCRUD uses events (clicking a button) to compute the state of affairs.
--    Every such state typically has its own interface associated with it. 
--    In order to get a smooth user experience, changes of state should be accompanied with switching of interfaces.
--    In order to be flexible and give application developers the control they need,
--    every change in state will navigate to an interface with a predefined name, as listed below
--    You can easily define these interfaces as in instance of an existing interface, as exemplified in the code below.
--    The `INTERFACE "XXXXPortal"` has been designed to accommodate every state.
--    Thus, you can use it as the generic interface to navigate to.
--    Note that `INTERFACE "XXXXPortal"` has been made invisible, because in practice it will be called from the application's portal.
--    Conversely: be sure that you create a portal from which to call it if needed.

INTERFACE "AfterEventCreateXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- New XXXX has been created (and can/should be edited)
INTERFACE "AfterEventUpdateXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- Updating has started (ready to edit)
INTERFACE "AfterEventCommitXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- Updating has terminated (done editing)
INTERFACE "AfterEventSelectXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- Another XXXX has been selected (to further focus on)
INTERFACE "AfterEventDeselectXXXX": I[SESSION] INTERFACE "XXXXPortal" -- Currently selected XXXX has been deselected (so go to some overview)
INTERFACE "AfterEventDeleteXXXX":   I[SESSION] INTERFACE "XXXXPortal" -- XXXX has been deleted (so go to some overview)

--[XXXX_ButtonCRUD - Switching between different portals]
-- 6. If you choose to use `INTERFACE "XXXXPortal"` that is provided by this code
--    you then _MUST_ create `INTERFACE "XXXXHeaderBar"`
--    You may want this interface to provide a breadcrumb and/or buttons for navigation purposes.
--    Notes:
--    - this file specifies `INTERFACE "GoToXXXXPortalButton"`, that contains a single button that
--      when clicked, navigates the user to `INTERFACE "XXXXPortal"`.
--      You can use this as part of the headerbar navigation buttons.
--    - make sure you properly initialize the switching between portals, e.g. by checking whether
--      `sfCurrentPortalIfc` is populated, and if not, create a request to do so. 
--    Here is some example code for you to use and adapt in your application script:

ROLE ExecEngine MAINTAINS "Initialize sfCurrentPortalIfc"
RULE "Initialize sfCurrentPortalIfc": I - sfCurrentPortalIfc;sfCurrentPortalIfc~ |- sfChangeToPortalForXXReq
VIOLATION (TXT "{EX} InsPair;sfChangeToPortalForXXReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

POPULATION isInvisible CONTAINS [ ("XXXXHeaderBar", "XXXXHeaderBar") ]
INTERFACE "XXXXHeaderBar" FOR User: "_SESSION"[SESSION] cRud BOX <CDIV>
   [ "User": I cRud BOX <CDIV>
      [ "User": sessionAccount;accPersonRef cRud
      , "Logout": I cRud BOX <PROPBUTTON> [ property : sessionLogoutReq cRUd ]
      ]
   , "Portal Switch buttons": I[SESSION] cRud BOX <CDIV>
      [ "XXXXs" : I INTERFACE "GoToXXXXPortalButton"
      , "YYYYs" : I INTERFACE "GoToYYYYPortalButton"
      , "ZZZZs" : I INTERFACE "GoToZZZZPortalButton"
      ]
   ]
-}

--[Basics - Initialization, Being Clean, and (Auto)Deleting XXs]
xxxIsPersistent  :: XXXX * XXXX [PROP] -- Property, stating that XX should not be deleted by ButtonCRUD functionality
xxxIsClean       :: XXXX * XXXX [PROP] -- Property, stating that XX fulfills the minimum requirements for being registered
xxxIsInitialized :: XXXX * XXXX [PROP] -- Property, stating that XX has at some point in time been clean

RULE "Please make XXXX 'clean', or delete it": 
   xxxIsInitialized |- xxxIsPersistent \/ xxxIsClean \/ sfUpdateXX~;sfUpdateXX

ROLE ExecEngine MAINTAINS "InsPair `xxxIsInitialized`" -- This rule prevents inadvertent deletion of XX atoms when DB is inited
RULE "InsPair `xxxIsInitialized`": xxxIsClean |- xxxIsInitialized
VIOLATION (TXT "{EX} InsPair;xxxIsInitialized;XXXX;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Delete XX if it is not persistent and created imcomplete"
RULE "Delete XX if it is not persistent and created imcomplete": 
   I-xxxIsPersistent |- xxxIsClean \/ sfUpdateXX~;sfUpdateXX
VIOLATION (TXT "{EX} DelAtom;XXXX;", SRC I)

--[Basics - Selecting an XXXX]
-- Selecting is done using `BOX <OBJECTDROPDOWN>`, which populates `sfSelReqForXX`
-- Selecting a new XXXX terminates any editing/updating functions.
sfSelReqForXX :: SESSION * XXXX [UNI] -- Event, that requests to select XXXX (to further focus on) if not already selected
sfSelectedXX :: SESSION * XXXX [UNI] -- the XXXX-atom that is selected in/focussed on by the session
sfAllowSelectOnXX :: SESSION * XXXX -- Permission, where the user is allowed to select (view) the XX
RULE "An XXXX can only be selected if that is allowed": sfSelReqForXX \/ sfSelectedXX |- sfAllowSelectOnXX

xxxSelectReq :: XXXX * XXXX [PROP] -- Event, that requests to select the XXXX (to further focus on) if not already selected
ROLE ExecEngine MAINTAINS "Service xxxSelectReq"
RULE "Service xxxSelectReq": xxxSelectReq |- -V
VIOLATION (TXT "{EX} InsPair;sfSelReqForXX;SESSION;", SRC V;"_SESSION"[SESSION], TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;xxxSelectReq;XXXX;", SRC I, TXT ";XXXX;", TGT I
          )

ROLE ExecEngine MAINTAINS "Decline `sfSelReqForXX`"
RULE "Decline `sfSelReqForXX`": sfSelReqForXX |- sfAllowSelectOnXX
VIOLATION (TXT "{EX} DelPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Service `sfSelReqForXX`"
RULE "Service `sfSelReqForXX`": sfSelReqForXX /\ sfAllowSelectOnXX |- sfSelectedXX
VIOLATION (TXT "{EX} InsPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfXXSelCounter;SESSION;", SRC I, TXT ";XXSelCounter;{php}", SRC sfXXSelCounter, TXT "+1"
          ,TXT "{EX} DelPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventSelectXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventSelectXXXX", "AfterEventSelectXXXX") ]

--[Service: Select XX - Automated selections]
ROLE ExecEngine MAINTAINS "Auto Service sfXXSelectReq - there is only one choice" -- If there's only one choice, then take it.
RULE "Auto Service sfXXSelectReq - there is only one choice":
   sfAllowSelectOnXX - sfAllowSelectOnXX;-I |- sfSelReqForXX
VIOLATION (TXT "{EX} InsPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventSelectXXXX"
          )

--[Service: Counting changes in XX-Selection]
-- Counting the number of times that the XX-selection changes allows other modules to synchronize with the latest changes.
sfXXSelCounter :: SESSION * XXSelCounter [UNI]   REPRESENT XXSelCounter TYPE INTEGER

ROLE ExecEngine MAINTAINS "Initialize XXSelCounter"
RULE "Initialize XXSelCounter": I |- sfXXSelCounter;sfXXSelCounter~
VIOLATION (TXT "{EX} InsPair;sfXXSelCounter;SESSION;", SRC I, TXT ";XXSelCounter;0")

--[Basics - Deselecting the selected XXXX]
sfXXDeselectReq :: SESSION * SESSION [PROP] -- Event, that requests to deselect the selected XXXX
ROLE ExecEngine MAINTAINS "Service sfXXDeselectReq" -- Service sfXXDeselectReq when set
RULE "Service sfXXDeselectReq": sfXXDeselectReq |- -V
VIOLATION (TXT "{EX} DelPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT sfSelReqForXX
          ,TXT "{EX} DelPair;sfXXDeselectReq;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ) -- Note that this will be followed by the rule "DelPair `sfSelectedXX`"

ROLE ExecEngine MAINTAINS "DelPair `sfSelectedXX`"
RULE "DelPair `sfSelectedXX`": sfSelectedXX |- sfSelReqForXX
VIOLATION (TXT "{EX} DelPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfXXSelCounter;SESSION;", SRC I, TXT ";XXSelCounter;{php}", SRC sfXXSelCounter, TXT "+1"
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDeselectXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventDeselectXXXX", "AfterEventDeselectXXXX") ]

--[Basics: Properties that flag (No)Selection]
-- Sometimes we need to know whether or not an XX is focused on. Therefore, we define properties that we can use for this
sfHasXXSelected :: SESSION * SESSION [PROP] -- Status/Property, where the session has an XX that the user focuses on
sfNoXXSelected :: SESSION * SESSION [PROP] -- Status/Property, where the session does not have an XX that the user can focus on
ROLE ExecEngine MAINTAINS "InsPair sfHasXXSelected/DelPair xfXXIsUnSelected"
RULE "InsPair sfHasXXSelected/DelPair xfXXIsUnSelected": I /\ sfSelectedXX;sfSelectedXX~ |- sfHasXXSelected-sfNoXXSelected
VIOLATION (TXT "{EX} InsPair;sfHasXXSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} DelPair;sfNoXXSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          )
ROLE ExecEngine MAINTAINS "DelPair sfHasXXSelected/InsPair xfXXIsUnSelected"
RULE "DelPair sfHasXXSelected/InsPair xfXXIsUnSelected": I - sfSelectedXX;sfSelectedXX~ |- sfNoXXSelected-sfHasXXSelected
VIOLATION (TXT "{EX} InsPair;sfNoXXSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} DelPair;sfHasXXSelected;SESSION;", SRC I, TXT ";SESSION;", TGT I
          )

--[Basics - Updating and Being Updated]
-- Updating or edition an XX means that the session user wants to change attributes/relations of this XX
-- This can only be done while the user is not in the process of selection on some XX.
sfUpdateXX :: SESSION * XXXX [UNI] -- the XXXX-atom that is being updated/edited in the session (and hence must have been selected)
sfAllowUpdateOnXX :: SESSION * XXXX -- Permission, where the user is allowed to update (edit) the specified XX
RULE "In order to be UPDATEing, the user must be permitted to update the selected XXXX":  sfXXIsUpdating |- sfSelectedXX;sfAllowUpdateOnXX~
RULE "An XXXX can only be updated/edited if that is allowed": sfUpdateXX |- sfAllowUpdateOnXX
RULE "Cannot update XXXX because it is being updated in another session": sfUpdateXX |- sfSelectedXX - (sfUpdateXX;-I)

sfXXIsUpdating :: SESSION * SESSION [PROP] -- Status, where the user is in the process of updating (editing) the XX that is focused on

ROLE ExecEngine MAINTAINS "Equivalence - InsPair sfXXIsUpdating"
RULE "Equivalence - InsPair sfXXIsUpdating": I /\ sfUpdateXX;sfUpdateXX~ |- sfXXIsUpdating
VIOLATION (TXT "{EX} InsPair;sfXXIsUpdating;SESSION;", SRC I, TXT ";SESSION;", TGT I)
ROLE ExecEngine MAINTAINS "Equivalence - DelPair sfXXIsUpdating"
RULE "Equivalence - DelPair sfXXIsUpdating": sfXXIsUpdating |- I /\ sfUpdateXX;sfUpdateXX~
VIOLATION (TXT "{EX} DelPair;sfXXIsUpdating;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} DelPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", SRC sfUpdateXX
          )
ROLE ExecEngine MAINTAINS "Auto DelPair `sfUpdateXX`"
RULE "Auto DelPair `sfUpdateXX`": sfUpdateXX |- sfSelectedXX
VIOLATION (TXT "{EX} DelPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", TGT I)

--[Service: Create XX]
-- An XX is created when `sfXXCreateReq` is populated, and `sfCreateXXIsAllowed` is set (permits the creation)
-- When an XX is created, it is usually not clean, so we take it to be updated after creation.
-- Because of this, we do not allow for the creation of an XX when an XX is being updated.
sfCreateXXIsAllowed :: SESSION * SESSION [PROP] -- Permission, where the user is allowed to request the creation of a new XX
sfXXCreateReq       :: SESSION * SESSION [PROP] -- Event, where the user requests to create a new XX

ROLE ExecEngine MAINTAINS "Decline/Prevent sfXXCreateReq" -- i.e. if there is no permission, or an XX is being updated in this session.
RULE "Decline/Prevent sfXXCreateReq": sfXXCreateReq |- sfCreateXXIsAllowed - sfXXIsUpdating
VIOLATION (TXT "{EX} DelPair;sfXXCreateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Service sfXXCreateReq" -- Create an XX if there is no XX being edited, and creation is allowed
RULE "Service sfXXCreateReq": sfXXCreateReq /\ sfCreateXXIsAllowed |- sfXXIsUpdating
VIOLATION (TXT "{EX} InsAtom;XXXX"
          ,TXT "{EX} InsPair;sfAllowSelectOnXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfAllowUpdateOnXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfAllowDeleteOnXX;SESSION;", SRC I, TXT ";XXXX;_NEW"

          ,TXT "{EX} InsPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} InsPair;sfXXSelCounter;SESSION;", SRC I, TXT ";XXSelCounter;{php}", SRC sfXXSelCounter, TXT "+1"
          ,TXT "{EX} InsPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;_NEW"
          ,TXT "{EX} DelPair;xxxUpdateReq;XXXX;", TGT I, TXT ";XXXX;_NEW"
          
          ,TXT "{EX} DelPair;sfXXCreateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventCreateXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventCreateXXXX", "AfterEventCreateXXXX") ]

--[Service: Update XX - Start editing process following a request on a specific XXXX]
xxxUpdateReq :: XXXX * XXXX [PROP] -- Event, where the user requests to update (edit) the specified XX

ROLE ExecEngine MAINTAINS "Decline xxxUpdateReq"
RULE "Decline xxxUpdateReq": xxxUpdateReq |- sfAllowSelectOnXX~;sfAllowUpdateOnXX
VIOLATION (TXT "{EX} DelPair;xxxUpdateReq;XXXX;", TGT I, TXT ";XXXX;", TGT I)

ROLE ExecEngine MAINTAINS "Service xxxUpdateReq" -- i.e.: Start the updating/editing of XX
RULE "Service xxxUpdateReq": (sfAllowSelectOnXX /\ sfAllowUpdateOnXX);xxxUpdateReq |- sfSelReqForXX /\ sfSelectedXX /\ sfUpdateXX
VIOLATION (TXT "{EX} InsPair;sfSelReqForXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfSelectedXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} InsPair;sfXXSelCounter;SESSION;", SRC I, TXT ";XXSelCounter;{php}", SRC sfXXSelCounter, TXT "+1"
          ,TXT "{EX} InsPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;xxxUpdateReq;XXXX;", TGT I, TXT ";XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventUpdateXXXX"
          )

--[Service: Update XX - Start editing process following a request in the session]
sfXXUpdateReq :: SESSION * SESSION [PROP] -- Event, where the user requests to update (edit) the XX that is currently selected

RULE "A session that can update an XX must be able to focus on that XX": sfAllowUpdateOnXX |- sfAllowSelectOnXX
-- We do not provide ExecEngine solutions here so that errors in the population of `sfAllowUpdateOnXX` do not go unnoticed
-- ROLE ExecEngine MAINTAINS "DelPair `sfAllowUpdateOnXX`"
-- RULE "DelPair `sfAllowUpdateOnXX`": sfAllowUpdateOnXX |- sfAllowSelectOnXX
-- VIOLATION (TXT "{EX} DelPair;sfAllowUpdateOnXX;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Decline sfXXUpdateReq"
RULE "Decline sfXXUpdateReq": sfXXUpdateReq |- sfAllowUpdateOnXX;sfSelectedXX~
VIOLATION (TXT "{EX} DelPair;sfXXUpdateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Prevent sfXXUpdateReq" -- this is when XX is being edited in another session
RULE "Prevent sfXXUpdateReq": sfXXUpdateReq;(sfSelectedXX /\ sfAllowUpdateOnXX) |- -(-I;sfUpdateXX)
VIOLATION (TXT "{EX} DelPair;sfXXUpdateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Service sfXXUpdateReq" -- i.e.: Start the updating/editing of XX
RULE "Service sfXXUpdateReq": sfXXUpdateReq;(sfSelectedXX /\ sfAllowUpdateOnXX) |- sfUpdateXX
VIOLATION (TXT "{EX} InsPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXUpdateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventUpdateXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventUpdateXXXX", "AfterEventUpdateXXXX") ]

--[Service: Update XX - Terminate editing process]
sfXXCommitReq :: SESSION * SESSION [PROP] -- Event, where the user requests to commit to the changes for XX

ROLE ExecEngine MAINTAINS "Decline sfXXCommitReq" -- e.g. in sessions other than that where XX is edited
RULE "Decline sfXXCommitReq": sfXXCommitReq |- sfUpdateXX;sfAllowUpdateOnXX~
VIOLATION (TXT "{EX} DelPair;sfXXUpdateReq;SESSION;", SRC I, TXT ";SESSION;", SRC I)

ROLE ExecEngine MAINTAINS "Service sfXXCommitReq by deleting XX"
RULE "Service sfXXCommitReq by deleting XX": sfXXCommitReq;sfUpdateXX |- sfAllowUpdateOnXX;xxxIsClean
VIOLATION (TXT "{EX} DelAtom;XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXCommitReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventCommitXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventCommitXXXX", "AfterEventCommitXXXX") ]

ROLE ExecEngine MAINTAINS "Service sfXXCommitReq by retaining XX"
RULE "Service sfXXCommitReq by retaining XX": sfUpdateXX;xxxIsClean |- (I-sfXXCommitReq);sfAllowUpdateOnXX
VIOLATION (TXT "{EX} DelPair;sfUpdateXX;SESSION;", SRC I, TXT ";XXXX;", TGT I
          ,TXT "{EX} DelPair;sfXXCommitReq;SESSION;", SRC I, TXT ";SESSION;", SRC I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventCommitXXXX"
          )


--[Service: Delete XX ]
sfAllowDeleteOnXX :: SESSION * XXXX -- Permission, where the user is allowed to delete the XX
sfXXDeleteReq :: SESSION * SESSION [PROP] -- Event, where the user requests the XX to be (completely) deleted

RULE "A session that can delete an XX must be able to focus on that XX": sfAllowDeleteOnXX |- sfAllowSelectOnXX
-- We do not provide ExecEngine solutions here so that errors in the population of `sfAllowDeleteOnXX` do not go unnoticed
-- ROLE ExecEngine MAINTAINS "DelPair `sfAllowDeleteOnXX`"
-- RULE "DelPair `sfAllowDeleteOnXX`": sfAllowDeleteOnXX |- sfAllowSelectOnXX
-- VIOLATION (TXT "{EX} DelPair;sfAllowDeleteOnXX;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Decline sfXXDeleteReq"
RULE "Decline sfXXDeleteReq": sfXXDeleteReq |- sfSelectedXX;sfAllowDeleteOnXX~
VIOLATION (TXT "{EX} DelPair;sfXXDeleteReq;SESSION;", SRC I, TXT ";SESSION;", TGT I)

ROLE ExecEngine MAINTAINS "Service sfXXDeleteReq"
RULE "Service sfXXDeleteReq": sfXXDeleteReq;(sfSelectedXX /\ sfAllowDeleteOnXX) |- -V
VIOLATION (TXT "{EX} DelAtom;XXXX;", TGT I
          ,TXT "{EX} SetNavToOnCommit;/AfterEventDeleteXXXX"
          )
POPULATION isInvisible CONTAINS [ ("AfterEventDeleteXXXX", "AfterEventDeleteXXXX") ]

--[Switching between XXXXPortal and other portals (e.g. YYYYPortal or ZZZZPortal)]
-- The purpose of the following code is to allow applications to switch between the XXXXPortal (as defined below)
-- and other portals, e.g. a YYYYPortal or a ZZZZPortal that are defined elsewhere in the application.
--#IFNOT NoGoToXXXXPortalButton
sfCurrentPortalIfc :: SESSION * IfcName [UNI]    REPRESENT IfcName TYPE ALPHANUMERIC
sfChangeToPortalForXXReq :: SESSION * SESSION [PROP] -- Event, where the user requests to focus on a XX
ROLE ExecEngine MAINTAINS "Service sfChangeToPortalForXXReq"
RULE "Service sfChangeToPortalForXXReq": sfChangeToPortalForXXReq |- -I
VIOLATION (TXT "{EX} DelPair;sfChangeToPortalForXXReq;SESSION;", SRC I, TXT ";SESSION;", TGT I
          ,TXT "{EX} InsPair;sfCurrentPortalIfc;SESSION;", SRC I, TXT ";IfcName;/XXXXPortal"
          ,TXT "{EX} SetNavToOnCommit;/XXXXPortal"
          )
-- The below interface can be called e.g. from `INTERFACE "XXXXHeaderBar"` to navigate to the XXXXPortal
POPULATION isInvisible CONTAINS [ ("GoToXXXXPortalButton", "GoToXXXXPortalButton") ]
INTERFACE "GoToXXXXPortalButton": I[SESSION] cRud BOX <DIV>
   [  "XXXXs": (I[SESSION] /\ sfAllowSelectOnXX;sfAllowSelectOnXX~) \/ sfCreateXXIsAllowed cRud BOX <PROPBUTTON>
      [ property: sfChangeToPortalForXXReq cRUd
      , disabled: I /\ sfCurrentPortalIfc;"/XXXXPortal";sfCurrentPortalIfc~ cRud
      ]
   ]
--#ENDIF NoGoToXXXXPortalButton

--[INTERFACES]
--#IFNOT ApplicationDefinesAllXXInterfaces
-- Every interface defined here can optionally be left out by setting `No<interfacename>Ifc` when including this file.

--Navigation interfaces do not show up in the menu bar:
POPULATION isInvisible CONTAINS [ ("AfterEventCreateXXXX","AfterEventCreateXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventUpdateXXXX","AfterEventUpdateXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventCommitXXXX","AfterEventCommitXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventSelectXXXX","AfterEventSelectXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventDeselectXXXX","AfterEventDeselectXXXX") ]
POPULATION isInvisible CONTAINS [ ("AfterEventDeleteXXXX","AfterEventDeleteXXXX") ]

--#IFNOT NoXXXXPortalIfc
POPULATION isInvisible CONTAINS [ ("XXXXPortal", "XXXXPortal")]
INTERFACE "XXXXPortal": (I[SESSION] /\ sfAllowSelectOnXX;sfAllowSelectOnXX~) \/ sfCreateXXIsAllowed cRud BOX <DIV>
   [ "XXXXHeaderBar":  I INTERFACE "XXXXHeaderBar", -- Breadcrumbs, global navigation buttons
     "XXXXButtonBar":  I INTERFACE "XXXXPortalButtonBar", -- Navigation within XXXXs
     "XXXXWorkArea":   I INTERFACE "XXXXWorkArea"
   ]
--#ENDIF NoXXXXPortalIfc

--#IFNOT NoXXXXWorkAreaIfc -- This allows users to define their own WorkArea interface
POPULATION isInvisible CONTAINS [ ("XXXXWorkArea", "XXXXWorkArea") ]
INTERFACE "XXXXWorkArea": I[SESSION] cRud BOX <DIV>
   [ "Listing XX": I-sfHasXXSelected INTERFACE "OverviewXX"
   --#IF NoEditingOfXXXXs
   , "Showing XX": sfSelectedXX INTERFACE "ShowXX"
   --#ELSE
   , "Showing XX": sfSelectedXX-sfUpdateXX INTERFACE "ShowXX"
   , "Initing XX": sfUpdateXX;(I-xxxIsInitialized) INTERFACE "InitXX"
   , "Updating XX": sfUpdateXX;xxxIsInitialized INTERFACE "EditXX"
      --#IF ButtonBarEditXXIfc
      , "Updatebar XX": sfXXIsUpdating INTERFACE "ButtonBarEditXX"
      --#ENDIF ButtonBarEditXXIfc
   --#ENDIF NoEditingOfXXXXs
   ]
--#ENDIF NoXXXXWorkAreaIfc

--[Example INTERFACEs for portal construction]

--#IFNOT NoXXXXSelectIfc -- This allows users to define their own selection interface
POPULATION IfcText CONTAINS [ "There is nothing to show" ]
POPULATION isInvisible CONTAINS [ ("XXXXSelect", "XXXXSelect") ]
INTERFACE "XXXXSelect": "_SESSION"[SESSION] cRud BOX <OBJECTDROPDOWN>
   [ "selectfrom": sfAllowSelectOnXX cRud <XXSelectionSummary>
   , "setrelation": sfSelReqForXX cRUd
   ]
--#ENDIF NoXXXXSelectIfc

--#IFNOT NoXXXXOverviewIfc -- This allows users to define their own Overview interface
POPULATION IfcText CONTAINS [ "There is nothing to show" ]
POPULATION isInvisible CONTAINS [ ("XXXXOverview", "XXXXOverview") ]
INTERFACE "XXXXOverview": I cRud BOX <DIV>
   [ "Nothing to do": (I - sfAllowSelectOnXX;sfAllowSelectOnXX~);V;"There is nothing to show"[IfcText] <STRONG>
   , "Listing XXs": sfAllowSelectOnXX cRud <XXOverviewSummary>
   ]
--#ENDIF NoXXXXOverviewIfc

--[INTERFACEs - Button bars]
-- Button bars can be used in Interfaces for (re)setting events for the purpose of CRUDing XXXX's

--#IFNOT NoXXXXPortalButtonBarIfc
-- The following buttonbar is designed for the general context in which a user wants to work with XX's
POPULATION IfcText CONTAINS [ "There is no current XX." ]
POPULATION IfcText CONTAINS [ "Please contact your system administrator." ]
POPULATION IfcText CONTAINS [ "You may create one." ]
POPULATION IfcText CONTAINS [ "Please select one." ]
POPULATION IfcText CONTAINS [ "Please select or create one." ]
POPULATION IfcText CONTAINS [ "Current XX: " ]
POPULATION IfcText CONTAINS [ "unknown" ]

POPULATION isInvisible CONTAINS [ ("XXXXPortalButtonBar", "XXXXPortalButtonBar")]
INTERFACE "XXXXPortalButtonBar": "_SESSION"[SESSION] cRud BOX <CDIV>
   [ "No XX selected": sfNoXXSelected cRud BOX <CDIV>
      [ "No XX selectable": I-sfAllowSelectOnXX;sfAllowSelectOnXX~ BOX <CDIV>
         [ "MSG: Get help": (I-sfCreateXXIsAllowed);V;"Please contact your system administrator."[IfcText] cRud <STRONG>
         , "MSG: Create XX": sfCreateXXIsAllowed;V;"You may create one."[IfcText] cRud <STRONG>
         ]
      , "XX can be selected": I /\ sfAllowSelectOnXX;sfAllowSelectOnXX~ BOX <CDIV>
         [ "MSG: Current XX": V;"Current XX: "[IfcText] cRud <STRONG>
         , "Selected XX": I INTERFACE "XXXXSelect"
         ] 
      , "New": sfCreateXXIsAllowed cRud BOX <PROPBUTTON> [ property: sfXXCreateReq cRUd ]
      ]
   , "XX is selected, NOT editing": sfHasXXSelected - sfXXIsUpdating  cRud BOX <CDIV>
      [ "MSG: Current XX": V;"Current XX: "[IfcText] cRud <STRONG>
      , "Selected XX": I INTERFACE "XXXXSelect"
      , "Edit": I /\ sfSelectedXX;sfAllowUpdateOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXUpdateReq cRUd
         , disabled: I /\ sfUpdateXX;sfAllowUpdateOnXX~ cRud
         ]
      , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXDeleteReq cRUd
   --    , disabled: I cRud
         ]
      , "New": sfCreateXXIsAllowed cRud BOX <PROPBUTTON>
         [ property: sfXXCreateReq cRUd
         , disabled: I /\ sfSelectedXX;sfUpdateXX~ cRud -- because that interferes with the updating of XX
         ]
      , "Overview": sfHasXXSelected cRud BOX <PROPBUTTON> -- This is deselecting the current XX
         [ property: sfXXDeselectReq cRUd
         , disabled: I - sfAllowSelectOnXX;-I;sfAllowSelectOnXX~ cRud
         ]
      ]
   --#IFNOT NoEditingOfXXXXs
   , "XX is (selected, AND) editing": sfHasXXSelected /\ sfXXIsUpdating cRud BOX <CDIV>
      [ "MSG: Current XX": V;"Current XX: "[IfcText] cRud <STRONG>
      , "Selected XX": I INTERFACE "XXXXSelect"
      , "OK": sfXXIsUpdating cRud BOX <PROPBUTTON>
         [ property: sfXXCommitReq cRUd
         , disabled: I /\ sfUpdateXX;(I-xxxIsClean);sfUpdateXX~ cRud
         ]
      , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
         [ property: sfXXDeleteReq cRUd
   --    , disabled: I cRud
         ]
      , "Overview": sfHasXXSelected cRud BOX <PROPBUTTON> -- This is deselecting the current XX
         [ property: sfXXDeselectReq cRUd
   --    , disabled: sfXXIsSelecting cRud
         ]
      ]
   --#ENDIF NoEditingOfXXXXs
   ]
--#ENDIF NoXXXXPortalButtonBarIfc

--#IF ButtonBarEditXXIfc
-- The following buttonbar is designed for the context in which the user is updating (editing) a specific XX
POPULATION isInvisible CONTAINS [ ("ButtonBarEditXX", "ButtonBarEditXX")]
INTERFACE "ButtonBarEditXX": "_SESSION"[SESSION] cRud BOX <CDIV>
   [ "OK": sfXXIsUpdating cRud BOX <PROPBUTTON>
      [ property: sfXXCommitReq cRUd
      , disabled: I /\ sfUpdateXX;(I-xxxIsClean);sfUpdateXX~ cRud
      ]
   , "Delete": I /\ sfSelectedXX;sfAllowDeleteOnXX~ cRud BOX <PROPBUTTON>
      [ property: sfXXDeleteReq cRUd
--    , disabled: I cRud
      ]
   ]
--#ENDIF ButtonBarEditXXIfc

--#ENDIF ApplicationDefinesAllXXInterfaces
ENDCONTEXT