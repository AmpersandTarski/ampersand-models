CONTEXT History IN ENGLISH LATEX
PURPOSE PATTERN "Historic records"
{+Maintaining historic records of specific data is a recurring theme in database design.
The pattern ``Historic records'' defines a notion of variable with history.
A variable can be adapted to a specific situation by means of specialization.
-}

PURPOSE CONCEPT Variable
{+Let us use the word variable to denote something that stores an element of data.
Each historic record is kept in a variable.
The idea is that all changes in the past will be accessible at all times.
-}
CONCEPT Variable "A variable is a device that is meant to contain data and its history of changes."

PURPOSE CONCEPT Assignment
{+Let us use the word assignment to denote a change made to a data element.
We assume that the most recent assignment represents the actual value of the variable.
The idea is to store all past assignments in temporal order.
-}
CONCEPT Assignment "An assignment is a change that has occured to a variable."

PURPOSE RELATION trace
{+In order to keep track of history, each variable points to a list of assignments.
Consequently, we apply the usual recursive definition of lists:
A list is either empty, or it has a head (one element) and a tail (a list).
If the list is not empty, its head is the most recent assignment.
We say that the list ``starts with'' that assignment.
The tail is a list that contains the remaining history, i.e. all assignments that are older.
-}

PURPOSE RELATION pred
{+In order to keep track of history, the temporal order in which assignments have taken place must be registered.
If assignment $a$ is more recent than assignment $a'$, we say that $a$ has succeded $a'$ or (equivalently) $a'$ has preceded $a$.
So we need a relation, $\id{pred}$, that represents a temporal order between assignments.
The successor relation needs no separate representation, because it is equal to $\flip{\id{pred}}$.
-}

PURPOSE RULE "head of trace"
{+If the head of a trace is the most recent assignment, there cannot be any assignments that are more recent.
Without a predecessor, the assignment represents the oldest value ever assigned to a variable.
If an assignment has no successor, it represents the last (most recent) value assigned to a variable.
We need a rule to state that each variable refers to the most recent assignment of a trace.
-}

PURPOSE RULE "attached assignments"
{+In order to detect any ``dangling'' assignments,
we require that assignments without a successor must be attached to a variable.
-}

{-PURPOSE RULE "transitive pred"
{+In order to ensure that each trace is actually a list,
we require that relation $\kleenestar{\id{pred}}$ is transitive.
-}

PATTERN "Historic records"
--TODO: making the function trace TOT exposes bugs in the prototype. Please test this after Michiel has finished the transactions in the new frontend.
RELATION trace[Variable*Assignment] [UNI] -- For the purpose of initializing a variable, `trace` may not be total.
MEANING "A variable may be related to an assignment, referring to the most recent value of that variable."
RELATION pred[Assignment*Assignment] [UNI]
MEANING "An assignment may be related to another assignment, referring to its immediate predecessor."

RULE "head of trace" : -(trace;pred~)
MEANING "The trace of each variable starts with an assignment that has no successors."

RULE "attached assignments" : V[ONE*Assignment];pred \/ V[ONE*Variable];trace
MEANING "Every assignment either has a successor (which is an assignment) or it represents the current value of a variable."

--RULE "transitive pred" : pred*;pred |- pred*
--MEANING "The predecessor relation corresponds to its transitive closure."
ENDPATTERN

--!RJ: Onderstaand concept wordt niet gebruikt binnen CONTEXT History. Daarom kan hij weg.
--PURPOSE CONCEPT Value
--{+Let us use a concept called $\id{Value}$ to represent the type of values that are assigned to variables in the actual system.
-}
--CONCEPT Value "A value represents the contents of a variable."

PURPOSE RELATION var
{+In order to quickly select all assignments that are related to a variable,
we register the variable of each assignment.
-}

PURPOSE RULE precedence
{+If the system registers the variable to which each assignment belongs,
we need a rule to say that two assignments refer to the same variable if they are related by precedence.
-}

RELATION var[Assignment*Variable] [UNI,TOT]
MEANING "Every assignment belongs to precisely one variable."

RULE precedence : var~;pred;var |- I
MEANING "If one assignment precedes another, they affect the same variable."

PROCESS AutoMaintainHistory
PURPOSE PROCESS AutoMaintainHistory
{+This process maintains history sequences automatically.
Usage: create a new assignment and fill out the var relation (so the system knows to which variable this assignment is bound).
Effect: the pred and trace relations will be updated, maintaining rules precedence, trace~|-var,  and UpdateAssignment.
-}

PURPOSE RULE UpdateAssignment
{+Als reactie op het wijzigen van de grond van een variabele maakt het systeem een nieuwe assignment.
Een wijziging is te herkennen aan het feit dat er al een trace is; dwz er bestaat een variabele/assignment paar in de relatie trace.
De nieuwe assignment wordt gevuld met de naam en grond van de bijbehorende variabele, en de bestaande assignment wordt met de relatie pred
in het rijtje gehangen.
-}

ROLE ExecEngine MAINTAINS UpdateAssignment
RULE UpdateAssignment: I[Assignment] /\ var;var~ |- pred~;pred \/ trace~;trace    -- type is [Assignment*Assignment]
MEANING "The predecessor of a changed variable is its previous trace."
VIOLATION ( TXT "{EX} InsPair;pred;Assignment;", SRC I[Assignment], TXT ";Assignment;", SRC var;trace
          , TXT "{EX} InsPair;trace;Variable;", SRC var, TXT ";Assignment;", SRC I[Assignment]
          )
ENDPROCESS

{-The above rule 'UpdateAssignment' may/will result in a database error in cases where 'trace' does not exist, as it will then attempt to call InsPair with an empty target atom. As a rule of thumb, you should NOT use possibly empty expressions as an argument for InsPair, DelPair, etc. 
The following pair of rules do not have this issue, and can replace the above rule.:

ROLE ExecEngine MAINTAINS InitialAssignment
RULE InitialAssignment: I[Assignment] /\ var;var~ |- var;trace;trace~;var~
MEANING "A variable for which there is an assignment must have a trace."
VIOLATION ( TXT "{EX} InsPair;trace;Variable;", SRC var, TXT ";Assignment;", TGT I)

ROLE ExecEngine MAINTAINS UpdateAssignment
RULE UpdateAssignment: I[Assignment] /\ var;trace;-I |- pred~;pred
MEANING "The predecessor of a changed variable is its previous trace."
VIOLATION ( TXT "{EX} InsPair;pred;Assignment;", SRC I, TXT ";Assignment;", TGT var;trace
          , TXT "{EX} InsPair;trace;Variable;", SRC var, TXT ";Assignment;", TGT I
          )
-}
ENDCONTEXT